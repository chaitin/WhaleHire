// Code generated by ent, DO NOT EDIT.

package db

import "context"

// PageInfo 分页信息
type PageInfo struct {
	NextToken   string `json:"next_token,omitempty"`
	HasNextPage bool   `json:"has_next_page"`
	TotalCount  int64  `json:"total_count"`
}

func (a *AdminQuery) Page(ctx context.Context, page, size int) ([]*Admin, *PageInfo, error) {
	cnt, err := a.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := a.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (alh *AdminLoginHistoryQuery) Page(ctx context.Context, page, size int) ([]*AdminLoginHistory, *PageInfo, error) {
	cnt, err := alh.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := alh.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (ar *AdminRoleQuery) Page(ctx context.Context, page, size int) ([]*AdminRole, *PageInfo, error) {
	cnt, err := ar.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := ar.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (a *AttachmentQuery) Page(ctx context.Context, page, size int) ([]*Attachment, *PageInfo, error) {
	cnt, err := a.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := a.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (c *ConversationQuery) Page(ctx context.Context, page, size int) ([]*Conversation, *PageInfo, error) {
	cnt, err := c.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := c.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (d *DepartmentQuery) Page(ctx context.Context, page, size int) ([]*Department, *PageInfo, error) {
	cnt, err := d.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := d.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (jer *JobEducationRequirementQuery) Page(ctx context.Context, page, size int) ([]*JobEducationRequirement, *PageInfo, error) {
	cnt, err := jer.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := jer.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (jer *JobExperienceRequirementQuery) Page(ctx context.Context, page, size int) ([]*JobExperienceRequirement, *PageInfo, error) {
	cnt, err := jer.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := jer.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (jir *JobIndustryRequirementQuery) Page(ctx context.Context, page, size int) ([]*JobIndustryRequirement, *PageInfo, error) {
	cnt, err := jir.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := jir.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (jp *JobPositionQuery) Page(ctx context.Context, page, size int) ([]*JobPosition, *PageInfo, error) {
	cnt, err := jp.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := jp.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (jr *JobResponsibilityQuery) Page(ctx context.Context, page, size int) ([]*JobResponsibility, *PageInfo, error) {
	cnt, err := jr.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := jr.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (js *JobSkillQuery) Page(ctx context.Context, page, size int) ([]*JobSkill, *PageInfo, error) {
	cnt, err := js.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := js.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (jsm *JobSkillMetaQuery) Page(ctx context.Context, page, size int) ([]*JobSkillMeta, *PageInfo, error) {
	cnt, err := jsm.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := jsm.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (m *MessageQuery) Page(ctx context.Context, page, size int) ([]*Message, *PageInfo, error) {
	cnt, err := m.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := m.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (r *ResumeQuery) Page(ctx context.Context, page, size int) ([]*Resume, *PageInfo, error) {
	cnt, err := r.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := r.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (rdp *ResumeDocumentParseQuery) Page(ctx context.Context, page, size int) ([]*ResumeDocumentParse, *PageInfo, error) {
	cnt, err := rdp.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := rdp.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (re *ResumeEducationQuery) Page(ctx context.Context, page, size int) ([]*ResumeEducation, *PageInfo, error) {
	cnt, err := re.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := re.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (re *ResumeExperienceQuery) Page(ctx context.Context, page, size int) ([]*ResumeExperience, *PageInfo, error) {
	cnt, err := re.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := re.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (rja *ResumeJobApplicationQuery) Page(ctx context.Context, page, size int) ([]*ResumeJobApplication, *PageInfo, error) {
	cnt, err := rja.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := rja.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (rl *ResumeLogQuery) Page(ctx context.Context, page, size int) ([]*ResumeLog, *PageInfo, error) {
	cnt, err := rl.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := rl.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (rp *ResumeProjectQuery) Page(ctx context.Context, page, size int) ([]*ResumeProject, *PageInfo, error) {
	cnt, err := rp.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := rp.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (rs *ResumeSkillQuery) Page(ctx context.Context, page, size int) ([]*ResumeSkill, *PageInfo, error) {
	cnt, err := rs.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := rs.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (r *RoleQuery) Page(ctx context.Context, page, size int) ([]*Role, *PageInfo, error) {
	cnt, err := r.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := r.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (sr *ScreeningResultQuery) Page(ctx context.Context, page, size int) ([]*ScreeningResult, *PageInfo, error) {
	cnt, err := sr.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := sr.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (srm *ScreeningRunMetricQuery) Page(ctx context.Context, page, size int) ([]*ScreeningRunMetric, *PageInfo, error) {
	cnt, err := srm.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := srm.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (st *ScreeningTaskQuery) Page(ctx context.Context, page, size int) ([]*ScreeningTask, *PageInfo, error) {
	cnt, err := st.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := st.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (str *ScreeningTaskResumeQuery) Page(ctx context.Context, page, size int) ([]*ScreeningTaskResume, *PageInfo, error) {
	cnt, err := str.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := str.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (s *SettingQuery) Page(ctx context.Context, page, size int) ([]*Setting, *PageInfo, error) {
	cnt, err := s.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := s.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (u *UserQuery) Page(ctx context.Context, page, size int) ([]*User, *PageInfo, error) {
	cnt, err := u.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := u.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (ui *UserIdentityQuery) Page(ctx context.Context, page, size int) ([]*UserIdentity, *PageInfo, error) {
	cnt, err := ui.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := ui.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}

func (ulh *UserLoginHistoryQuery) Page(ctx context.Context, page, size int) ([]*UserLoginHistory, *PageInfo, error) {
	cnt, err := ulh.Count(ctx)
	if err != nil {
		return nil, nil, err
	}
	offset := size * (page - 1)
	items, err := ulh.Offset(offset).Limit(size).All(ctx)
	if err != nil {
		return nil, nil, err
	}
	has := (page * size) < cnt
	return items, &PageInfo{HasNextPage: has, TotalCount: int64(cnt)}, nil
}
