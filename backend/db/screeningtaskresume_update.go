// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/chaitin/WhaleHire/backend/db/predicate"
	"github.com/chaitin/WhaleHire/backend/db/resume"
	"github.com/chaitin/WhaleHire/backend/db/screeningnoderun"
	"github.com/chaitin/WhaleHire/backend/db/screeningtask"
	"github.com/chaitin/WhaleHire/backend/db/screeningtaskresume"
	"github.com/google/uuid"
)

// ScreeningTaskResumeUpdate is the builder for updating ScreeningTaskResume entities.
type ScreeningTaskResumeUpdate struct {
	config
	hooks     []Hook
	mutation  *ScreeningTaskResumeMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the ScreeningTaskResumeUpdate builder.
func (stru *ScreeningTaskResumeUpdate) Where(ps ...predicate.ScreeningTaskResume) *ScreeningTaskResumeUpdate {
	stru.mutation.Where(ps...)
	return stru
}

// SetDeletedAt sets the "deleted_at" field.
func (stru *ScreeningTaskResumeUpdate) SetDeletedAt(t time.Time) *ScreeningTaskResumeUpdate {
	stru.mutation.SetDeletedAt(t)
	return stru
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (stru *ScreeningTaskResumeUpdate) SetNillableDeletedAt(t *time.Time) *ScreeningTaskResumeUpdate {
	if t != nil {
		stru.SetDeletedAt(*t)
	}
	return stru
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (stru *ScreeningTaskResumeUpdate) ClearDeletedAt() *ScreeningTaskResumeUpdate {
	stru.mutation.ClearDeletedAt()
	return stru
}

// SetTaskID sets the "task_id" field.
func (stru *ScreeningTaskResumeUpdate) SetTaskID(u uuid.UUID) *ScreeningTaskResumeUpdate {
	stru.mutation.SetTaskID(u)
	return stru
}

// SetNillableTaskID sets the "task_id" field if the given value is not nil.
func (stru *ScreeningTaskResumeUpdate) SetNillableTaskID(u *uuid.UUID) *ScreeningTaskResumeUpdate {
	if u != nil {
		stru.SetTaskID(*u)
	}
	return stru
}

// SetResumeID sets the "resume_id" field.
func (stru *ScreeningTaskResumeUpdate) SetResumeID(u uuid.UUID) *ScreeningTaskResumeUpdate {
	stru.mutation.SetResumeID(u)
	return stru
}

// SetNillableResumeID sets the "resume_id" field if the given value is not nil.
func (stru *ScreeningTaskResumeUpdate) SetNillableResumeID(u *uuid.UUID) *ScreeningTaskResumeUpdate {
	if u != nil {
		stru.SetResumeID(*u)
	}
	return stru
}

// SetStatus sets the "status" field.
func (stru *ScreeningTaskResumeUpdate) SetStatus(s string) *ScreeningTaskResumeUpdate {
	stru.mutation.SetStatus(s)
	return stru
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (stru *ScreeningTaskResumeUpdate) SetNillableStatus(s *string) *ScreeningTaskResumeUpdate {
	if s != nil {
		stru.SetStatus(*s)
	}
	return stru
}

// SetErrorMessage sets the "error_message" field.
func (stru *ScreeningTaskResumeUpdate) SetErrorMessage(s string) *ScreeningTaskResumeUpdate {
	stru.mutation.SetErrorMessage(s)
	return stru
}

// SetNillableErrorMessage sets the "error_message" field if the given value is not nil.
func (stru *ScreeningTaskResumeUpdate) SetNillableErrorMessage(s *string) *ScreeningTaskResumeUpdate {
	if s != nil {
		stru.SetErrorMessage(*s)
	}
	return stru
}

// ClearErrorMessage clears the value of the "error_message" field.
func (stru *ScreeningTaskResumeUpdate) ClearErrorMessage() *ScreeningTaskResumeUpdate {
	stru.mutation.ClearErrorMessage()
	return stru
}

// SetRanking sets the "ranking" field.
func (stru *ScreeningTaskResumeUpdate) SetRanking(i int) *ScreeningTaskResumeUpdate {
	stru.mutation.ResetRanking()
	stru.mutation.SetRanking(i)
	return stru
}

// SetNillableRanking sets the "ranking" field if the given value is not nil.
func (stru *ScreeningTaskResumeUpdate) SetNillableRanking(i *int) *ScreeningTaskResumeUpdate {
	if i != nil {
		stru.SetRanking(*i)
	}
	return stru
}

// AddRanking adds i to the "ranking" field.
func (stru *ScreeningTaskResumeUpdate) AddRanking(i int) *ScreeningTaskResumeUpdate {
	stru.mutation.AddRanking(i)
	return stru
}

// ClearRanking clears the value of the "ranking" field.
func (stru *ScreeningTaskResumeUpdate) ClearRanking() *ScreeningTaskResumeUpdate {
	stru.mutation.ClearRanking()
	return stru
}

// SetScore sets the "score" field.
func (stru *ScreeningTaskResumeUpdate) SetScore(f float64) *ScreeningTaskResumeUpdate {
	stru.mutation.ResetScore()
	stru.mutation.SetScore(f)
	return stru
}

// SetNillableScore sets the "score" field if the given value is not nil.
func (stru *ScreeningTaskResumeUpdate) SetNillableScore(f *float64) *ScreeningTaskResumeUpdate {
	if f != nil {
		stru.SetScore(*f)
	}
	return stru
}

// AddScore adds f to the "score" field.
func (stru *ScreeningTaskResumeUpdate) AddScore(f float64) *ScreeningTaskResumeUpdate {
	stru.mutation.AddScore(f)
	return stru
}

// ClearScore clears the value of the "score" field.
func (stru *ScreeningTaskResumeUpdate) ClearScore() *ScreeningTaskResumeUpdate {
	stru.mutation.ClearScore()
	return stru
}

// SetProcessedAt sets the "processed_at" field.
func (stru *ScreeningTaskResumeUpdate) SetProcessedAt(t time.Time) *ScreeningTaskResumeUpdate {
	stru.mutation.SetProcessedAt(t)
	return stru
}

// SetNillableProcessedAt sets the "processed_at" field if the given value is not nil.
func (stru *ScreeningTaskResumeUpdate) SetNillableProcessedAt(t *time.Time) *ScreeningTaskResumeUpdate {
	if t != nil {
		stru.SetProcessedAt(*t)
	}
	return stru
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (stru *ScreeningTaskResumeUpdate) ClearProcessedAt() *ScreeningTaskResumeUpdate {
	stru.mutation.ClearProcessedAt()
	return stru
}

// SetUpdatedAt sets the "updated_at" field.
func (stru *ScreeningTaskResumeUpdate) SetUpdatedAt(t time.Time) *ScreeningTaskResumeUpdate {
	stru.mutation.SetUpdatedAt(t)
	return stru
}

// SetTask sets the "task" edge to the ScreeningTask entity.
func (stru *ScreeningTaskResumeUpdate) SetTask(s *ScreeningTask) *ScreeningTaskResumeUpdate {
	return stru.SetTaskID(s.ID)
}

// SetResume sets the "resume" edge to the Resume entity.
func (stru *ScreeningTaskResumeUpdate) SetResume(r *Resume) *ScreeningTaskResumeUpdate {
	return stru.SetResumeID(r.ID)
}

// AddNodeRunIDs adds the "node_runs" edge to the ScreeningNodeRun entity by IDs.
func (stru *ScreeningTaskResumeUpdate) AddNodeRunIDs(ids ...uuid.UUID) *ScreeningTaskResumeUpdate {
	stru.mutation.AddNodeRunIDs(ids...)
	return stru
}

// AddNodeRuns adds the "node_runs" edges to the ScreeningNodeRun entity.
func (stru *ScreeningTaskResumeUpdate) AddNodeRuns(s ...*ScreeningNodeRun) *ScreeningTaskResumeUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return stru.AddNodeRunIDs(ids...)
}

// Mutation returns the ScreeningTaskResumeMutation object of the builder.
func (stru *ScreeningTaskResumeUpdate) Mutation() *ScreeningTaskResumeMutation {
	return stru.mutation
}

// ClearTask clears the "task" edge to the ScreeningTask entity.
func (stru *ScreeningTaskResumeUpdate) ClearTask() *ScreeningTaskResumeUpdate {
	stru.mutation.ClearTask()
	return stru
}

// ClearResume clears the "resume" edge to the Resume entity.
func (stru *ScreeningTaskResumeUpdate) ClearResume() *ScreeningTaskResumeUpdate {
	stru.mutation.ClearResume()
	return stru
}

// ClearNodeRuns clears all "node_runs" edges to the ScreeningNodeRun entity.
func (stru *ScreeningTaskResumeUpdate) ClearNodeRuns() *ScreeningTaskResumeUpdate {
	stru.mutation.ClearNodeRuns()
	return stru
}

// RemoveNodeRunIDs removes the "node_runs" edge to ScreeningNodeRun entities by IDs.
func (stru *ScreeningTaskResumeUpdate) RemoveNodeRunIDs(ids ...uuid.UUID) *ScreeningTaskResumeUpdate {
	stru.mutation.RemoveNodeRunIDs(ids...)
	return stru
}

// RemoveNodeRuns removes "node_runs" edges to ScreeningNodeRun entities.
func (stru *ScreeningTaskResumeUpdate) RemoveNodeRuns(s ...*ScreeningNodeRun) *ScreeningTaskResumeUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return stru.RemoveNodeRunIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (stru *ScreeningTaskResumeUpdate) Save(ctx context.Context) (int, error) {
	if err := stru.defaults(); err != nil {
		return 0, err
	}
	return withHooks(ctx, stru.sqlSave, stru.mutation, stru.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (stru *ScreeningTaskResumeUpdate) SaveX(ctx context.Context) int {
	affected, err := stru.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (stru *ScreeningTaskResumeUpdate) Exec(ctx context.Context) error {
	_, err := stru.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (stru *ScreeningTaskResumeUpdate) ExecX(ctx context.Context) {
	if err := stru.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (stru *ScreeningTaskResumeUpdate) defaults() error {
	if _, ok := stru.mutation.UpdatedAt(); !ok {
		if screeningtaskresume.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("db: uninitialized screeningtaskresume.UpdateDefaultUpdatedAt (forgotten import db/runtime?)")
		}
		v := screeningtaskresume.UpdateDefaultUpdatedAt()
		stru.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (stru *ScreeningTaskResumeUpdate) check() error {
	if stru.mutation.TaskCleared() && len(stru.mutation.TaskIDs()) > 0 {
		return errors.New(`db: clearing a required unique edge "ScreeningTaskResume.task"`)
	}
	if stru.mutation.ResumeCleared() && len(stru.mutation.ResumeIDs()) > 0 {
		return errors.New(`db: clearing a required unique edge "ScreeningTaskResume.resume"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (stru *ScreeningTaskResumeUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *ScreeningTaskResumeUpdate {
	stru.modifiers = append(stru.modifiers, modifiers...)
	return stru
}

func (stru *ScreeningTaskResumeUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := stru.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(screeningtaskresume.Table, screeningtaskresume.Columns, sqlgraph.NewFieldSpec(screeningtaskresume.FieldID, field.TypeUUID))
	if ps := stru.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := stru.mutation.DeletedAt(); ok {
		_spec.SetField(screeningtaskresume.FieldDeletedAt, field.TypeTime, value)
	}
	if stru.mutation.DeletedAtCleared() {
		_spec.ClearField(screeningtaskresume.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := stru.mutation.Status(); ok {
		_spec.SetField(screeningtaskresume.FieldStatus, field.TypeString, value)
	}
	if value, ok := stru.mutation.ErrorMessage(); ok {
		_spec.SetField(screeningtaskresume.FieldErrorMessage, field.TypeString, value)
	}
	if stru.mutation.ErrorMessageCleared() {
		_spec.ClearField(screeningtaskresume.FieldErrorMessage, field.TypeString)
	}
	if value, ok := stru.mutation.Ranking(); ok {
		_spec.SetField(screeningtaskresume.FieldRanking, field.TypeInt, value)
	}
	if value, ok := stru.mutation.AddedRanking(); ok {
		_spec.AddField(screeningtaskresume.FieldRanking, field.TypeInt, value)
	}
	if stru.mutation.RankingCleared() {
		_spec.ClearField(screeningtaskresume.FieldRanking, field.TypeInt)
	}
	if value, ok := stru.mutation.Score(); ok {
		_spec.SetField(screeningtaskresume.FieldScore, field.TypeFloat64, value)
	}
	if value, ok := stru.mutation.AddedScore(); ok {
		_spec.AddField(screeningtaskresume.FieldScore, field.TypeFloat64, value)
	}
	if stru.mutation.ScoreCleared() {
		_spec.ClearField(screeningtaskresume.FieldScore, field.TypeFloat64)
	}
	if value, ok := stru.mutation.ProcessedAt(); ok {
		_spec.SetField(screeningtaskresume.FieldProcessedAt, field.TypeTime, value)
	}
	if stru.mutation.ProcessedAtCleared() {
		_spec.ClearField(screeningtaskresume.FieldProcessedAt, field.TypeTime)
	}
	if value, ok := stru.mutation.UpdatedAt(); ok {
		_spec.SetField(screeningtaskresume.FieldUpdatedAt, field.TypeTime, value)
	}
	if stru.mutation.TaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   screeningtaskresume.TaskTable,
			Columns: []string{screeningtaskresume.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningtask.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := stru.mutation.TaskIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   screeningtaskresume.TaskTable,
			Columns: []string{screeningtaskresume.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningtask.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if stru.mutation.ResumeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   screeningtaskresume.ResumeTable,
			Columns: []string{screeningtaskresume.ResumeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(resume.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := stru.mutation.ResumeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   screeningtaskresume.ResumeTable,
			Columns: []string{screeningtaskresume.ResumeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(resume.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if stru.mutation.NodeRunsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   screeningtaskresume.NodeRunsTable,
			Columns: []string{screeningtaskresume.NodeRunsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningnoderun.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := stru.mutation.RemovedNodeRunsIDs(); len(nodes) > 0 && !stru.mutation.NodeRunsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   screeningtaskresume.NodeRunsTable,
			Columns: []string{screeningtaskresume.NodeRunsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningnoderun.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := stru.mutation.NodeRunsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   screeningtaskresume.NodeRunsTable,
			Columns: []string{screeningtaskresume.NodeRunsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningnoderun.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.AddModifiers(stru.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, stru.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{screeningtaskresume.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	stru.mutation.done = true
	return n, nil
}

// ScreeningTaskResumeUpdateOne is the builder for updating a single ScreeningTaskResume entity.
type ScreeningTaskResumeUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *ScreeningTaskResumeMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetDeletedAt sets the "deleted_at" field.
func (struo *ScreeningTaskResumeUpdateOne) SetDeletedAt(t time.Time) *ScreeningTaskResumeUpdateOne {
	struo.mutation.SetDeletedAt(t)
	return struo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (struo *ScreeningTaskResumeUpdateOne) SetNillableDeletedAt(t *time.Time) *ScreeningTaskResumeUpdateOne {
	if t != nil {
		struo.SetDeletedAt(*t)
	}
	return struo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (struo *ScreeningTaskResumeUpdateOne) ClearDeletedAt() *ScreeningTaskResumeUpdateOne {
	struo.mutation.ClearDeletedAt()
	return struo
}

// SetTaskID sets the "task_id" field.
func (struo *ScreeningTaskResumeUpdateOne) SetTaskID(u uuid.UUID) *ScreeningTaskResumeUpdateOne {
	struo.mutation.SetTaskID(u)
	return struo
}

// SetNillableTaskID sets the "task_id" field if the given value is not nil.
func (struo *ScreeningTaskResumeUpdateOne) SetNillableTaskID(u *uuid.UUID) *ScreeningTaskResumeUpdateOne {
	if u != nil {
		struo.SetTaskID(*u)
	}
	return struo
}

// SetResumeID sets the "resume_id" field.
func (struo *ScreeningTaskResumeUpdateOne) SetResumeID(u uuid.UUID) *ScreeningTaskResumeUpdateOne {
	struo.mutation.SetResumeID(u)
	return struo
}

// SetNillableResumeID sets the "resume_id" field if the given value is not nil.
func (struo *ScreeningTaskResumeUpdateOne) SetNillableResumeID(u *uuid.UUID) *ScreeningTaskResumeUpdateOne {
	if u != nil {
		struo.SetResumeID(*u)
	}
	return struo
}

// SetStatus sets the "status" field.
func (struo *ScreeningTaskResumeUpdateOne) SetStatus(s string) *ScreeningTaskResumeUpdateOne {
	struo.mutation.SetStatus(s)
	return struo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (struo *ScreeningTaskResumeUpdateOne) SetNillableStatus(s *string) *ScreeningTaskResumeUpdateOne {
	if s != nil {
		struo.SetStatus(*s)
	}
	return struo
}

// SetErrorMessage sets the "error_message" field.
func (struo *ScreeningTaskResumeUpdateOne) SetErrorMessage(s string) *ScreeningTaskResumeUpdateOne {
	struo.mutation.SetErrorMessage(s)
	return struo
}

// SetNillableErrorMessage sets the "error_message" field if the given value is not nil.
func (struo *ScreeningTaskResumeUpdateOne) SetNillableErrorMessage(s *string) *ScreeningTaskResumeUpdateOne {
	if s != nil {
		struo.SetErrorMessage(*s)
	}
	return struo
}

// ClearErrorMessage clears the value of the "error_message" field.
func (struo *ScreeningTaskResumeUpdateOne) ClearErrorMessage() *ScreeningTaskResumeUpdateOne {
	struo.mutation.ClearErrorMessage()
	return struo
}

// SetRanking sets the "ranking" field.
func (struo *ScreeningTaskResumeUpdateOne) SetRanking(i int) *ScreeningTaskResumeUpdateOne {
	struo.mutation.ResetRanking()
	struo.mutation.SetRanking(i)
	return struo
}

// SetNillableRanking sets the "ranking" field if the given value is not nil.
func (struo *ScreeningTaskResumeUpdateOne) SetNillableRanking(i *int) *ScreeningTaskResumeUpdateOne {
	if i != nil {
		struo.SetRanking(*i)
	}
	return struo
}

// AddRanking adds i to the "ranking" field.
func (struo *ScreeningTaskResumeUpdateOne) AddRanking(i int) *ScreeningTaskResumeUpdateOne {
	struo.mutation.AddRanking(i)
	return struo
}

// ClearRanking clears the value of the "ranking" field.
func (struo *ScreeningTaskResumeUpdateOne) ClearRanking() *ScreeningTaskResumeUpdateOne {
	struo.mutation.ClearRanking()
	return struo
}

// SetScore sets the "score" field.
func (struo *ScreeningTaskResumeUpdateOne) SetScore(f float64) *ScreeningTaskResumeUpdateOne {
	struo.mutation.ResetScore()
	struo.mutation.SetScore(f)
	return struo
}

// SetNillableScore sets the "score" field if the given value is not nil.
func (struo *ScreeningTaskResumeUpdateOne) SetNillableScore(f *float64) *ScreeningTaskResumeUpdateOne {
	if f != nil {
		struo.SetScore(*f)
	}
	return struo
}

// AddScore adds f to the "score" field.
func (struo *ScreeningTaskResumeUpdateOne) AddScore(f float64) *ScreeningTaskResumeUpdateOne {
	struo.mutation.AddScore(f)
	return struo
}

// ClearScore clears the value of the "score" field.
func (struo *ScreeningTaskResumeUpdateOne) ClearScore() *ScreeningTaskResumeUpdateOne {
	struo.mutation.ClearScore()
	return struo
}

// SetProcessedAt sets the "processed_at" field.
func (struo *ScreeningTaskResumeUpdateOne) SetProcessedAt(t time.Time) *ScreeningTaskResumeUpdateOne {
	struo.mutation.SetProcessedAt(t)
	return struo
}

// SetNillableProcessedAt sets the "processed_at" field if the given value is not nil.
func (struo *ScreeningTaskResumeUpdateOne) SetNillableProcessedAt(t *time.Time) *ScreeningTaskResumeUpdateOne {
	if t != nil {
		struo.SetProcessedAt(*t)
	}
	return struo
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (struo *ScreeningTaskResumeUpdateOne) ClearProcessedAt() *ScreeningTaskResumeUpdateOne {
	struo.mutation.ClearProcessedAt()
	return struo
}

// SetUpdatedAt sets the "updated_at" field.
func (struo *ScreeningTaskResumeUpdateOne) SetUpdatedAt(t time.Time) *ScreeningTaskResumeUpdateOne {
	struo.mutation.SetUpdatedAt(t)
	return struo
}

// SetTask sets the "task" edge to the ScreeningTask entity.
func (struo *ScreeningTaskResumeUpdateOne) SetTask(s *ScreeningTask) *ScreeningTaskResumeUpdateOne {
	return struo.SetTaskID(s.ID)
}

// SetResume sets the "resume" edge to the Resume entity.
func (struo *ScreeningTaskResumeUpdateOne) SetResume(r *Resume) *ScreeningTaskResumeUpdateOne {
	return struo.SetResumeID(r.ID)
}

// AddNodeRunIDs adds the "node_runs" edge to the ScreeningNodeRun entity by IDs.
func (struo *ScreeningTaskResumeUpdateOne) AddNodeRunIDs(ids ...uuid.UUID) *ScreeningTaskResumeUpdateOne {
	struo.mutation.AddNodeRunIDs(ids...)
	return struo
}

// AddNodeRuns adds the "node_runs" edges to the ScreeningNodeRun entity.
func (struo *ScreeningTaskResumeUpdateOne) AddNodeRuns(s ...*ScreeningNodeRun) *ScreeningTaskResumeUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return struo.AddNodeRunIDs(ids...)
}

// Mutation returns the ScreeningTaskResumeMutation object of the builder.
func (struo *ScreeningTaskResumeUpdateOne) Mutation() *ScreeningTaskResumeMutation {
	return struo.mutation
}

// ClearTask clears the "task" edge to the ScreeningTask entity.
func (struo *ScreeningTaskResumeUpdateOne) ClearTask() *ScreeningTaskResumeUpdateOne {
	struo.mutation.ClearTask()
	return struo
}

// ClearResume clears the "resume" edge to the Resume entity.
func (struo *ScreeningTaskResumeUpdateOne) ClearResume() *ScreeningTaskResumeUpdateOne {
	struo.mutation.ClearResume()
	return struo
}

// ClearNodeRuns clears all "node_runs" edges to the ScreeningNodeRun entity.
func (struo *ScreeningTaskResumeUpdateOne) ClearNodeRuns() *ScreeningTaskResumeUpdateOne {
	struo.mutation.ClearNodeRuns()
	return struo
}

// RemoveNodeRunIDs removes the "node_runs" edge to ScreeningNodeRun entities by IDs.
func (struo *ScreeningTaskResumeUpdateOne) RemoveNodeRunIDs(ids ...uuid.UUID) *ScreeningTaskResumeUpdateOne {
	struo.mutation.RemoveNodeRunIDs(ids...)
	return struo
}

// RemoveNodeRuns removes "node_runs" edges to ScreeningNodeRun entities.
func (struo *ScreeningTaskResumeUpdateOne) RemoveNodeRuns(s ...*ScreeningNodeRun) *ScreeningTaskResumeUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return struo.RemoveNodeRunIDs(ids...)
}

// Where appends a list predicates to the ScreeningTaskResumeUpdate builder.
func (struo *ScreeningTaskResumeUpdateOne) Where(ps ...predicate.ScreeningTaskResume) *ScreeningTaskResumeUpdateOne {
	struo.mutation.Where(ps...)
	return struo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (struo *ScreeningTaskResumeUpdateOne) Select(field string, fields ...string) *ScreeningTaskResumeUpdateOne {
	struo.fields = append([]string{field}, fields...)
	return struo
}

// Save executes the query and returns the updated ScreeningTaskResume entity.
func (struo *ScreeningTaskResumeUpdateOne) Save(ctx context.Context) (*ScreeningTaskResume, error) {
	if err := struo.defaults(); err != nil {
		return nil, err
	}
	return withHooks(ctx, struo.sqlSave, struo.mutation, struo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (struo *ScreeningTaskResumeUpdateOne) SaveX(ctx context.Context) *ScreeningTaskResume {
	node, err := struo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (struo *ScreeningTaskResumeUpdateOne) Exec(ctx context.Context) error {
	_, err := struo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (struo *ScreeningTaskResumeUpdateOne) ExecX(ctx context.Context) {
	if err := struo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (struo *ScreeningTaskResumeUpdateOne) defaults() error {
	if _, ok := struo.mutation.UpdatedAt(); !ok {
		if screeningtaskresume.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("db: uninitialized screeningtaskresume.UpdateDefaultUpdatedAt (forgotten import db/runtime?)")
		}
		v := screeningtaskresume.UpdateDefaultUpdatedAt()
		struo.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (struo *ScreeningTaskResumeUpdateOne) check() error {
	if struo.mutation.TaskCleared() && len(struo.mutation.TaskIDs()) > 0 {
		return errors.New(`db: clearing a required unique edge "ScreeningTaskResume.task"`)
	}
	if struo.mutation.ResumeCleared() && len(struo.mutation.ResumeIDs()) > 0 {
		return errors.New(`db: clearing a required unique edge "ScreeningTaskResume.resume"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (struo *ScreeningTaskResumeUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *ScreeningTaskResumeUpdateOne {
	struo.modifiers = append(struo.modifiers, modifiers...)
	return struo
}

func (struo *ScreeningTaskResumeUpdateOne) sqlSave(ctx context.Context) (_node *ScreeningTaskResume, err error) {
	if err := struo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(screeningtaskresume.Table, screeningtaskresume.Columns, sqlgraph.NewFieldSpec(screeningtaskresume.FieldID, field.TypeUUID))
	id, ok := struo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`db: missing "ScreeningTaskResume.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := struo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, screeningtaskresume.FieldID)
		for _, f := range fields {
			if !screeningtaskresume.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("db: invalid field %q for query", f)}
			}
			if f != screeningtaskresume.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := struo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := struo.mutation.DeletedAt(); ok {
		_spec.SetField(screeningtaskresume.FieldDeletedAt, field.TypeTime, value)
	}
	if struo.mutation.DeletedAtCleared() {
		_spec.ClearField(screeningtaskresume.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := struo.mutation.Status(); ok {
		_spec.SetField(screeningtaskresume.FieldStatus, field.TypeString, value)
	}
	if value, ok := struo.mutation.ErrorMessage(); ok {
		_spec.SetField(screeningtaskresume.FieldErrorMessage, field.TypeString, value)
	}
	if struo.mutation.ErrorMessageCleared() {
		_spec.ClearField(screeningtaskresume.FieldErrorMessage, field.TypeString)
	}
	if value, ok := struo.mutation.Ranking(); ok {
		_spec.SetField(screeningtaskresume.FieldRanking, field.TypeInt, value)
	}
	if value, ok := struo.mutation.AddedRanking(); ok {
		_spec.AddField(screeningtaskresume.FieldRanking, field.TypeInt, value)
	}
	if struo.mutation.RankingCleared() {
		_spec.ClearField(screeningtaskresume.FieldRanking, field.TypeInt)
	}
	if value, ok := struo.mutation.Score(); ok {
		_spec.SetField(screeningtaskresume.FieldScore, field.TypeFloat64, value)
	}
	if value, ok := struo.mutation.AddedScore(); ok {
		_spec.AddField(screeningtaskresume.FieldScore, field.TypeFloat64, value)
	}
	if struo.mutation.ScoreCleared() {
		_spec.ClearField(screeningtaskresume.FieldScore, field.TypeFloat64)
	}
	if value, ok := struo.mutation.ProcessedAt(); ok {
		_spec.SetField(screeningtaskresume.FieldProcessedAt, field.TypeTime, value)
	}
	if struo.mutation.ProcessedAtCleared() {
		_spec.ClearField(screeningtaskresume.FieldProcessedAt, field.TypeTime)
	}
	if value, ok := struo.mutation.UpdatedAt(); ok {
		_spec.SetField(screeningtaskresume.FieldUpdatedAt, field.TypeTime, value)
	}
	if struo.mutation.TaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   screeningtaskresume.TaskTable,
			Columns: []string{screeningtaskresume.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningtask.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := struo.mutation.TaskIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   screeningtaskresume.TaskTable,
			Columns: []string{screeningtaskresume.TaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningtask.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if struo.mutation.ResumeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   screeningtaskresume.ResumeTable,
			Columns: []string{screeningtaskresume.ResumeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(resume.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := struo.mutation.ResumeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   screeningtaskresume.ResumeTable,
			Columns: []string{screeningtaskresume.ResumeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(resume.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if struo.mutation.NodeRunsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   screeningtaskresume.NodeRunsTable,
			Columns: []string{screeningtaskresume.NodeRunsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningnoderun.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := struo.mutation.RemovedNodeRunsIDs(); len(nodes) > 0 && !struo.mutation.NodeRunsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   screeningtaskresume.NodeRunsTable,
			Columns: []string{screeningtaskresume.NodeRunsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningnoderun.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := struo.mutation.NodeRunsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   screeningtaskresume.NodeRunsTable,
			Columns: []string{screeningtaskresume.NodeRunsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(screeningnoderun.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.AddModifiers(struo.modifiers...)
	_node = &ScreeningTaskResume{config: struo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, struo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{screeningtaskresume.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	struo.mutation.done = true
	return _node, nil
}
