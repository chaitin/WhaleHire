// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/chaitin/WhaleHire/backend/consts"
	"github.com/chaitin/WhaleHire/backend/db/admin"
	"github.com/chaitin/WhaleHire/backend/db/adminloginhistory"
	"github.com/chaitin/WhaleHire/backend/db/adminrole"
	"github.com/chaitin/WhaleHire/backend/db/attachment"
	"github.com/chaitin/WhaleHire/backend/db/conversation"
	"github.com/chaitin/WhaleHire/backend/db/message"
	"github.com/chaitin/WhaleHire/backend/db/predicate"
	"github.com/chaitin/WhaleHire/backend/db/resume"
	"github.com/chaitin/WhaleHire/backend/db/resumedocumentparse"
	"github.com/chaitin/WhaleHire/backend/db/resumeeducation"
	"github.com/chaitin/WhaleHire/backend/db/resumeexperience"
	"github.com/chaitin/WhaleHire/backend/db/resumelog"
	"github.com/chaitin/WhaleHire/backend/db/resumeskill"
	"github.com/chaitin/WhaleHire/backend/db/role"
	"github.com/chaitin/WhaleHire/backend/db/setting"
	"github.com/chaitin/WhaleHire/backend/db/user"
	"github.com/chaitin/WhaleHire/backend/db/useridentity"
	"github.com/chaitin/WhaleHire/backend/db/userloginhistory"
	"github.com/chaitin/WhaleHire/backend/ent/types"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin               = "Admin"
	TypeAdminLoginHistory   = "AdminLoginHistory"
	TypeAdminRole           = "AdminRole"
	TypeAttachment          = "Attachment"
	TypeConversation        = "Conversation"
	TypeMessage             = "Message"
	TypeResume              = "Resume"
	TypeResumeDocumentParse = "ResumeDocumentParse"
	TypeResumeEducation     = "ResumeEducation"
	TypeResumeExperience    = "ResumeExperience"
	TypeResumeLog           = "ResumeLog"
	TypeResumeSkill         = "ResumeSkill"
	TypeRole                = "Role"
	TypeSetting             = "Setting"
	TypeUser                = "User"
	TypeUserIdentity        = "UserIdentity"
	TypeUserLoginHistory    = "UserLoginHistory"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	username               *string
	password               *string
	status                 *consts.AdminStatus
	last_active_at         *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	login_histories        map[uuid.UUID]struct{}
	removedlogin_histories map[uuid.UUID]struct{}
	clearedlogin_histories bool
	roles                  map[int64]struct{}
	removedroles           map[int64]struct{}
	clearedroles           bool
	admin_roles            map[uuid.UUID]struct{}
	removedadmin_roles     map[uuid.UUID]struct{}
	clearedadmin_roles     bool
	done                   bool
	oldValue               func(context.Context) (*Admin, error)
	predicates             []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id uuid.UUID) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Admin entities.
func (m *AdminMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// SetStatus sets the "status" field.
func (m *AdminMutation) SetStatus(cs consts.AdminStatus) {
	m.status = &cs
}

// Status returns the value of the "status" field in the mutation.
func (m *AdminMutation) Status() (r consts.AdminStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldStatus(ctx context.Context) (v consts.AdminStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AdminMutation) ResetStatus() {
	m.status = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *AdminMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *AdminMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldLastActiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *AdminMutation) ResetLastActiveAt() {
	m.last_active_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddLoginHistoryIDs adds the "login_histories" edge to the AdminLoginHistory entity by ids.
func (m *AdminMutation) AddLoginHistoryIDs(ids ...uuid.UUID) {
	if m.login_histories == nil {
		m.login_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.login_histories[ids[i]] = struct{}{}
	}
}

// ClearLoginHistories clears the "login_histories" edge to the AdminLoginHistory entity.
func (m *AdminMutation) ClearLoginHistories() {
	m.clearedlogin_histories = true
}

// LoginHistoriesCleared reports if the "login_histories" edge to the AdminLoginHistory entity was cleared.
func (m *AdminMutation) LoginHistoriesCleared() bool {
	return m.clearedlogin_histories
}

// RemoveLoginHistoryIDs removes the "login_histories" edge to the AdminLoginHistory entity by IDs.
func (m *AdminMutation) RemoveLoginHistoryIDs(ids ...uuid.UUID) {
	if m.removedlogin_histories == nil {
		m.removedlogin_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.login_histories, ids[i])
		m.removedlogin_histories[ids[i]] = struct{}{}
	}
}

// RemovedLoginHistories returns the removed IDs of the "login_histories" edge to the AdminLoginHistory entity.
func (m *AdminMutation) RemovedLoginHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedlogin_histories {
		ids = append(ids, id)
	}
	return
}

// LoginHistoriesIDs returns the "login_histories" edge IDs in the mutation.
func (m *AdminMutation) LoginHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.login_histories {
		ids = append(ids, id)
	}
	return
}

// ResetLoginHistories resets all changes to the "login_histories" edge.
func (m *AdminMutation) ResetLoginHistories() {
	m.login_histories = nil
	m.clearedlogin_histories = false
	m.removedlogin_histories = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *AdminMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *AdminMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *AdminMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *AdminMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *AdminMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AdminMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AdminMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddAdminRoleIDs adds the "admin_roles" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleIDs(ids ...uuid.UUID) {
	if m.admin_roles == nil {
		m.admin_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.admin_roles[ids[i]] = struct{}{}
	}
}

// ClearAdminRoles clears the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoles() {
	m.clearedadmin_roles = true
}

// AdminRolesCleared reports if the "admin_roles" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRolesCleared() bool {
	return m.clearedadmin_roles
}

// RemoveAdminRoleIDs removes the "admin_roles" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleIDs(ids ...uuid.UUID) {
	if m.removedadmin_roles == nil {
		m.removedadmin_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.admin_roles, ids[i])
		m.removedadmin_roles[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoles returns the removed IDs of the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedadmin_roles {
		ids = append(ids, id)
	}
	return
}

// AdminRolesIDs returns the "admin_roles" edge IDs in the mutation.
func (m *AdminMutation) AdminRolesIDs() (ids []uuid.UUID) {
	for id := range m.admin_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoles resets all changes to the "admin_roles" edge.
func (m *AdminMutation) ResetAdminRoles() {
	m.admin_roles = nil
	m.clearedadmin_roles = false
	m.removedadmin_roles = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Admin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, admin.FieldStatus)
	}
	if m.last_active_at != nil {
		fields = append(fields, admin.FieldLastActiveAt)
	}
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	case admin.FieldStatus:
		return m.Status()
	case admin.FieldLastActiveAt:
		return m.LastActiveAt()
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	case admin.FieldStatus:
		return m.OldStatus(ctx)
	case admin.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case admin.FieldStatus:
		v, ok := value.(consts.AdminStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case admin.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	case admin.FieldStatus:
		m.ResetStatus()
		return nil
	case admin.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.login_histories != nil {
		edges = append(edges, admin.EdgeLoginHistories)
	}
	if m.roles != nil {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.admin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeLoginHistories:
		ids := make([]ent.Value, 0, len(m.login_histories))
		for id := range m.login_histories {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.admin_roles))
		for id := range m.admin_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlogin_histories != nil {
		edges = append(edges, admin.EdgeLoginHistories)
	}
	if m.removedroles != nil {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.removedadmin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeLoginHistories:
		ids := make([]ent.Value, 0, len(m.removedlogin_histories))
		for id := range m.removedlogin_histories {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.removedadmin_roles))
		for id := range m.removedadmin_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlogin_histories {
		edges = append(edges, admin.EdgeLoginHistories)
	}
	if m.clearedroles {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.clearedadmin_roles {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeLoginHistories:
		return m.clearedlogin_histories
	case admin.EdgeRoles:
		return m.clearedroles
	case admin.EdgeAdminRoles:
		return m.clearedadmin_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeLoginHistories:
		m.ResetLoginHistories()
		return nil
	case admin.EdgeRoles:
		m.ResetRoles()
		return nil
	case admin.EdgeAdminRoles:
		m.ResetAdminRoles()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AdminLoginHistoryMutation represents an operation that mutates the AdminLoginHistory nodes in the graph.
type AdminLoginHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	ip             *string
	country        *string
	province       *string
	city           *string
	isp            *string
	asn            *string
	client_version *string
	device         *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	owner          *uuid.UUID
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*AdminLoginHistory, error)
	predicates     []predicate.AdminLoginHistory
}

var _ ent.Mutation = (*AdminLoginHistoryMutation)(nil)

// adminloginhistoryOption allows management of the mutation configuration using functional options.
type adminloginhistoryOption func(*AdminLoginHistoryMutation)

// newAdminLoginHistoryMutation creates new mutation for the AdminLoginHistory entity.
func newAdminLoginHistoryMutation(c config, op Op, opts ...adminloginhistoryOption) *AdminLoginHistoryMutation {
	m := &AdminLoginHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminLoginHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminLoginHistoryID sets the ID field of the mutation.
func withAdminLoginHistoryID(id uuid.UUID) adminloginhistoryOption {
	return func(m *AdminLoginHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminLoginHistory
		)
		m.oldValue = func(ctx context.Context) (*AdminLoginHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminLoginHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminLoginHistory sets the old AdminLoginHistory of the mutation.
func withAdminLoginHistory(node *AdminLoginHistory) adminloginhistoryOption {
	return func(m *AdminLoginHistoryMutation) {
		m.oldValue = func(context.Context) (*AdminLoginHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminLoginHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminLoginHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminLoginHistory entities.
func (m *AdminLoginHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminLoginHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminLoginHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminLoginHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAdminID sets the "admin_id" field.
func (m *AdminLoginHistoryMutation) SetAdminID(u uuid.UUID) {
	m.owner = &u
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *AdminLoginHistoryMutation) AdminID() (r uuid.UUID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldAdminID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ClearAdminID clears the value of the "admin_id" field.
func (m *AdminLoginHistoryMutation) ClearAdminID() {
	m.owner = nil
	m.clearedFields[adminloginhistory.FieldAdminID] = struct{}{}
}

// AdminIDCleared returns if the "admin_id" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) AdminIDCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldAdminID]
	return ok
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *AdminLoginHistoryMutation) ResetAdminID() {
	m.owner = nil
	delete(m.clearedFields, adminloginhistory.FieldAdminID)
}

// SetIP sets the "ip" field.
func (m *AdminLoginHistoryMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AdminLoginHistoryMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AdminLoginHistoryMutation) ResetIP() {
	m.ip = nil
}

// SetCountry sets the "country" field.
func (m *AdminLoginHistoryMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AdminLoginHistoryMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *AdminLoginHistoryMutation) ResetCountry() {
	m.country = nil
}

// SetProvince sets the "province" field.
func (m *AdminLoginHistoryMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *AdminLoginHistoryMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *AdminLoginHistoryMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *AdminLoginHistoryMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AdminLoginHistoryMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AdminLoginHistoryMutation) ResetCity() {
	m.city = nil
}

// SetIsp sets the "isp" field.
func (m *AdminLoginHistoryMutation) SetIsp(s string) {
	m.isp = &s
}

// Isp returns the value of the "isp" field in the mutation.
func (m *AdminLoginHistoryMutation) Isp() (r string, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIsp returns the old "isp" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldIsp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsp: %w", err)
	}
	return oldValue.Isp, nil
}

// ClearIsp clears the value of the "isp" field.
func (m *AdminLoginHistoryMutation) ClearIsp() {
	m.isp = nil
	m.clearedFields[adminloginhistory.FieldIsp] = struct{}{}
}

// IspCleared returns if the "isp" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) IspCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldIsp]
	return ok
}

// ResetIsp resets all changes to the "isp" field.
func (m *AdminLoginHistoryMutation) ResetIsp() {
	m.isp = nil
	delete(m.clearedFields, adminloginhistory.FieldIsp)
}

// SetAsn sets the "asn" field.
func (m *AdminLoginHistoryMutation) SetAsn(s string) {
	m.asn = &s
}

// Asn returns the value of the "asn" field in the mutation.
func (m *AdminLoginHistoryMutation) Asn() (r string, exists bool) {
	v := m.asn
	if v == nil {
		return
	}
	return *v, true
}

// OldAsn returns the old "asn" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldAsn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAsn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAsn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAsn: %w", err)
	}
	return oldValue.Asn, nil
}

// ClearAsn clears the value of the "asn" field.
func (m *AdminLoginHistoryMutation) ClearAsn() {
	m.asn = nil
	m.clearedFields[adminloginhistory.FieldAsn] = struct{}{}
}

// AsnCleared returns if the "asn" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) AsnCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldAsn]
	return ok
}

// ResetAsn resets all changes to the "asn" field.
func (m *AdminLoginHistoryMutation) ResetAsn() {
	m.asn = nil
	delete(m.clearedFields, adminloginhistory.FieldAsn)
}

// SetClientVersion sets the "client_version" field.
func (m *AdminLoginHistoryMutation) SetClientVersion(s string) {
	m.client_version = &s
}

// ClientVersion returns the value of the "client_version" field in the mutation.
func (m *AdminLoginHistoryMutation) ClientVersion() (r string, exists bool) {
	v := m.client_version
	if v == nil {
		return
	}
	return *v, true
}

// OldClientVersion returns the old "client_version" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldClientVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientVersion: %w", err)
	}
	return oldValue.ClientVersion, nil
}

// ClearClientVersion clears the value of the "client_version" field.
func (m *AdminLoginHistoryMutation) ClearClientVersion() {
	m.client_version = nil
	m.clearedFields[adminloginhistory.FieldClientVersion] = struct{}{}
}

// ClientVersionCleared returns if the "client_version" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) ClientVersionCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldClientVersion]
	return ok
}

// ResetClientVersion resets all changes to the "client_version" field.
func (m *AdminLoginHistoryMutation) ResetClientVersion() {
	m.client_version = nil
	delete(m.clearedFields, adminloginhistory.FieldClientVersion)
}

// SetDevice sets the "device" field.
func (m *AdminLoginHistoryMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *AdminLoginHistoryMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *AdminLoginHistoryMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[adminloginhistory.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *AdminLoginHistoryMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, adminloginhistory.FieldDevice)
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminLoginHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminLoginHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminLoginHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the Admin entity by id.
func (m *AdminLoginHistoryMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Admin entity.
func (m *AdminLoginHistoryMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[adminloginhistory.FieldAdminID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Admin entity was cleared.
func (m *AdminLoginHistoryMutation) OwnerCleared() bool {
	return m.AdminIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AdminLoginHistoryMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AdminLoginHistoryMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AdminLoginHistoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AdminLoginHistoryMutation builder.
func (m *AdminLoginHistoryMutation) Where(ps ...predicate.AdminLoginHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminLoginHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminLoginHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminLoginHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminLoginHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminLoginHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminLoginHistory).
func (m *AdminLoginHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminLoginHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.owner != nil {
		fields = append(fields, adminloginhistory.FieldAdminID)
	}
	if m.ip != nil {
		fields = append(fields, adminloginhistory.FieldIP)
	}
	if m.country != nil {
		fields = append(fields, adminloginhistory.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, adminloginhistory.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, adminloginhistory.FieldCity)
	}
	if m.isp != nil {
		fields = append(fields, adminloginhistory.FieldIsp)
	}
	if m.asn != nil {
		fields = append(fields, adminloginhistory.FieldAsn)
	}
	if m.client_version != nil {
		fields = append(fields, adminloginhistory.FieldClientVersion)
	}
	if m.device != nil {
		fields = append(fields, adminloginhistory.FieldDevice)
	}
	if m.created_at != nil {
		fields = append(fields, adminloginhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminLoginHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminloginhistory.FieldAdminID:
		return m.AdminID()
	case adminloginhistory.FieldIP:
		return m.IP()
	case adminloginhistory.FieldCountry:
		return m.Country()
	case adminloginhistory.FieldProvince:
		return m.Province()
	case adminloginhistory.FieldCity:
		return m.City()
	case adminloginhistory.FieldIsp:
		return m.Isp()
	case adminloginhistory.FieldAsn:
		return m.Asn()
	case adminloginhistory.FieldClientVersion:
		return m.ClientVersion()
	case adminloginhistory.FieldDevice:
		return m.Device()
	case adminloginhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminLoginHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminloginhistory.FieldAdminID:
		return m.OldAdminID(ctx)
	case adminloginhistory.FieldIP:
		return m.OldIP(ctx)
	case adminloginhistory.FieldCountry:
		return m.OldCountry(ctx)
	case adminloginhistory.FieldProvince:
		return m.OldProvince(ctx)
	case adminloginhistory.FieldCity:
		return m.OldCity(ctx)
	case adminloginhistory.FieldIsp:
		return m.OldIsp(ctx)
	case adminloginhistory.FieldAsn:
		return m.OldAsn(ctx)
	case adminloginhistory.FieldClientVersion:
		return m.OldClientVersion(ctx)
	case adminloginhistory.FieldDevice:
		return m.OldDevice(ctx)
	case adminloginhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminLoginHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminLoginHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminloginhistory.FieldAdminID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case adminloginhistory.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case adminloginhistory.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case adminloginhistory.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case adminloginhistory.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case adminloginhistory.FieldIsp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsp(v)
		return nil
	case adminloginhistory.FieldAsn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAsn(v)
		return nil
	case adminloginhistory.FieldClientVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientVersion(v)
		return nil
	case adminloginhistory.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case adminloginhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminLoginHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminLoginHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminLoginHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminLoginHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminLoginHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminloginhistory.FieldAdminID) {
		fields = append(fields, adminloginhistory.FieldAdminID)
	}
	if m.FieldCleared(adminloginhistory.FieldIsp) {
		fields = append(fields, adminloginhistory.FieldIsp)
	}
	if m.FieldCleared(adminloginhistory.FieldAsn) {
		fields = append(fields, adminloginhistory.FieldAsn)
	}
	if m.FieldCleared(adminloginhistory.FieldClientVersion) {
		fields = append(fields, adminloginhistory.FieldClientVersion)
	}
	if m.FieldCleared(adminloginhistory.FieldDevice) {
		fields = append(fields, adminloginhistory.FieldDevice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminLoginHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminLoginHistoryMutation) ClearField(name string) error {
	switch name {
	case adminloginhistory.FieldAdminID:
		m.ClearAdminID()
		return nil
	case adminloginhistory.FieldIsp:
		m.ClearIsp()
		return nil
	case adminloginhistory.FieldAsn:
		m.ClearAsn()
		return nil
	case adminloginhistory.FieldClientVersion:
		m.ClearClientVersion()
		return nil
	case adminloginhistory.FieldDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminLoginHistoryMutation) ResetField(name string) error {
	switch name {
	case adminloginhistory.FieldAdminID:
		m.ResetAdminID()
		return nil
	case adminloginhistory.FieldIP:
		m.ResetIP()
		return nil
	case adminloginhistory.FieldCountry:
		m.ResetCountry()
		return nil
	case adminloginhistory.FieldProvince:
		m.ResetProvince()
		return nil
	case adminloginhistory.FieldCity:
		m.ResetCity()
		return nil
	case adminloginhistory.FieldIsp:
		m.ResetIsp()
		return nil
	case adminloginhistory.FieldAsn:
		m.ResetAsn()
		return nil
	case adminloginhistory.FieldClientVersion:
		m.ResetClientVersion()
		return nil
	case adminloginhistory.FieldDevice:
		m.ResetDevice()
		return nil
	case adminloginhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminLoginHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, adminloginhistory.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminLoginHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminloginhistory.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminLoginHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminLoginHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminLoginHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, adminloginhistory.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminLoginHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case adminloginhistory.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminLoginHistoryMutation) ClearEdge(name string) error {
	switch name {
	case adminloginhistory.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminLoginHistoryMutation) ResetEdge(name string) error {
	switch name {
	case adminloginhistory.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory edge %s", name)
}

// AdminRoleMutation represents an operation that mutates the AdminRole nodes in the graph.
type AdminRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	admin         *uuid.UUID
	clearedadmin  bool
	role          *int64
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*AdminRole, error)
	predicates    []predicate.AdminRole
}

var _ ent.Mutation = (*AdminRoleMutation)(nil)

// adminroleOption allows management of the mutation configuration using functional options.
type adminroleOption func(*AdminRoleMutation)

// newAdminRoleMutation creates new mutation for the AdminRole entity.
func newAdminRoleMutation(c config, op Op, opts ...adminroleOption) *AdminRoleMutation {
	m := &AdminRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminRoleID sets the ID field of the mutation.
func withAdminRoleID(id uuid.UUID) adminroleOption {
	return func(m *AdminRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminRole
		)
		m.oldValue = func(ctx context.Context) (*AdminRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminRole sets the old AdminRole of the mutation.
func withAdminRole(node *AdminRole) adminroleOption {
	return func(m *AdminRoleMutation) {
		m.oldValue = func(context.Context) (*AdminRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminRole entities.
func (m *AdminRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAdminID sets the "admin_id" field.
func (m *AdminRoleMutation) SetAdminID(u uuid.UUID) {
	m.admin = &u
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *AdminRoleMutation) AdminID() (r uuid.UUID, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldAdminID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *AdminRoleMutation) ResetAdminID() {
	m.admin = nil
}

// SetRoleID sets the "role_id" field.
func (m *AdminRoleMutation) SetRoleID(i int64) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AdminRoleMutation) RoleID() (r int64, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AdminRoleMutation) ResetRoleID() {
	m.role = nil
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *AdminRoleMutation) ClearAdmin() {
	m.clearedadmin = true
	m.clearedFields[adminrole.FieldAdminID] = struct{}{}
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) AdminIDs() (ids []uuid.UUID) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *AdminRoleMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *AdminRoleMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[adminrole.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *AdminRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) RoleIDs() (ids []int64) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *AdminRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the AdminRoleMutation builder.
func (m *AdminRoleMutation) Where(ps ...predicate.AdminRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminRole).
func (m *AdminRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminRoleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.admin != nil {
		fields = append(fields, adminrole.FieldAdminID)
	}
	if m.role != nil {
		fields = append(fields, adminrole.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminrole.FieldAdminID:
		return m.AdminID()
	case adminrole.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminrole.FieldAdminID:
		return m.OldAdminID(ctx)
	case adminrole.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown AdminRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminrole.FieldAdminID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case adminrole.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdminRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminRoleMutation) ResetField(name string) error {
	switch name {
	case adminrole.FieldAdminID:
		m.ResetAdminID()
		return nil
	case adminrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.admin != nil {
		edges = append(edges, adminrole.EdgeAdmin)
	}
	if m.role != nil {
		edges = append(edges, adminrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminrole.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case adminrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedadmin {
		edges = append(edges, adminrole.EdgeAdmin)
	}
	if m.clearedrole {
		edges = append(edges, adminrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case adminrole.EdgeAdmin:
		return m.clearedadmin
	case adminrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminRoleMutation) ClearEdge(name string) error {
	switch name {
	case adminrole.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case adminrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown AdminRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminRoleMutation) ResetEdge(name string) error {
	switch name {
	case adminrole.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case adminrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown AdminRole edge %s", name)
}

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	deleted_at     *time.Time
	_type          *string
	url            *string
	metadata       *map[string]interface{}
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	message        *uuid.UUID
	clearedmessage bool
	done           bool
	oldValue       func(context.Context) (*Attachment, error)
	predicates     []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttachmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttachmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttachmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attachment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttachmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttachmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attachment.FieldDeletedAt)
}

// SetMessageID sets the "message_id" field.
func (m *AttachmentMutation) SetMessageID(u uuid.UUID) {
	m.message = &u
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *AttachmentMutation) MessageID() (r uuid.UUID, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMessageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *AttachmentMutation) ResetMessageID() {
	m.message = nil
}

// SetType sets the "type" field.
func (m *AttachmentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AttachmentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AttachmentMutation) ResetType() {
	m._type = nil
}

// SetURL sets the "url" field.
func (m *AttachmentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AttachmentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AttachmentMutation) ResetURL() {
	m.url = nil
}

// SetMetadata sets the "metadata" field.
func (m *AttachmentMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AttachmentMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AttachmentMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[attachment.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AttachmentMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[attachment.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AttachmentMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, attachment.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *AttachmentMutation) ClearMessage() {
	m.clearedmessage = true
	m.clearedFields[attachment.FieldMessageID] = struct{}{}
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *AttachmentMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *AttachmentMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.message != nil {
		fields = append(fields, attachment.FieldMessageID)
	}
	if m._type != nil {
		fields = append(fields, attachment.FieldType)
	}
	if m.url != nil {
		fields = append(fields, attachment.FieldURL)
	}
	if m.metadata != nil {
		fields = append(fields, attachment.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldDeletedAt:
		return m.DeletedAt()
	case attachment.FieldMessageID:
		return m.MessageID()
	case attachment.FieldType:
		return m.GetType()
	case attachment.FieldURL:
		return m.URL()
	case attachment.FieldMetadata:
		return m.Metadata()
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attachment.FieldMessageID:
		return m.OldMessageID(ctx)
	case attachment.FieldType:
		return m.OldType(ctx)
	case attachment.FieldURL:
		return m.OldURL(ctx)
	case attachment.FieldMetadata:
		return m.OldMetadata(ctx)
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attachment.FieldMessageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case attachment.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case attachment.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case attachment.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldDeletedAt) {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.FieldCleared(attachment.FieldMetadata) {
		fields = append(fields, attachment.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attachment.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attachment.FieldMessageID:
		m.ResetMessageID()
		return nil
	case attachment.FieldType:
		m.ResetType()
		return nil
	case attachment.FieldURL:
		m.ResetURL()
		return nil
	case attachment.FieldMetadata:
		m.ResetMetadata()
		return nil
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.message != nil {
		edges = append(edges, attachment.EdgeMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmessage {
		edges = append(edges, attachment.EdgeMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeMessage:
		return m.clearedmessage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	deleted_at      *time.Time
	title           *string
	agent_name      *string
	metadata        *map[string]interface{}
	status          *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	user            *uuid.UUID
	cleareduser     bool
	messages        map[uuid.UUID]struct{}
	removedmessages map[uuid.UUID]struct{}
	clearedmessages bool
	done            bool
	oldValue        func(context.Context) (*Conversation, error)
	predicates      []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id uuid.UUID) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Conversation entities.
func (m *ConversationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ConversationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ConversationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ConversationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[conversation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ConversationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[conversation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ConversationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, conversation.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *ConversationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConversationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConversationMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *ConversationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConversationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ConversationMutation) ResetTitle() {
	m.title = nil
}

// SetAgentName sets the "agent_name" field.
func (m *ConversationMutation) SetAgentName(s string) {
	m.agent_name = &s
}

// AgentName returns the value of the "agent_name" field in the mutation.
func (m *ConversationMutation) AgentName() (r string, exists bool) {
	v := m.agent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentName returns the old "agent_name" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldAgentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentName: %w", err)
	}
	return oldValue.AgentName, nil
}

// ClearAgentName clears the value of the "agent_name" field.
func (m *ConversationMutation) ClearAgentName() {
	m.agent_name = nil
	m.clearedFields[conversation.FieldAgentName] = struct{}{}
}

// AgentNameCleared returns if the "agent_name" field was cleared in this mutation.
func (m *ConversationMutation) AgentNameCleared() bool {
	_, ok := m.clearedFields[conversation.FieldAgentName]
	return ok
}

// ResetAgentName resets all changes to the "agent_name" field.
func (m *ConversationMutation) ResetAgentName() {
	m.agent_name = nil
	delete(m.clearedFields, conversation.FieldAgentName)
}

// SetMetadata sets the "metadata" field.
func (m *ConversationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ConversationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ConversationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[conversation.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ConversationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[conversation.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ConversationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, conversation.FieldMetadata)
}

// SetStatus sets the "status" field.
func (m *ConversationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConversationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConversationMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConversationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConversationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConversationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ConversationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[conversation.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ConversationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ConversationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ConversationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ConversationMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ConversationMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ConversationMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ConversationMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ConversationMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ConversationMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ConversationMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.deleted_at != nil {
		fields = append(fields, conversation.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, conversation.FieldTitle)
	}
	if m.agent_name != nil {
		fields = append(fields, conversation.FieldAgentName)
	}
	if m.metadata != nil {
		fields = append(fields, conversation.FieldMetadata)
	}
	if m.status != nil {
		fields = append(fields, conversation.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, conversation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldDeletedAt:
		return m.DeletedAt()
	case conversation.FieldUserID:
		return m.UserID()
	case conversation.FieldTitle:
		return m.Title()
	case conversation.FieldAgentName:
		return m.AgentName()
	case conversation.FieldMetadata:
		return m.Metadata()
	case conversation.FieldStatus:
		return m.Status()
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case conversation.FieldUserID:
		return m.OldUserID(ctx)
	case conversation.FieldTitle:
		return m.OldTitle(ctx)
	case conversation.FieldAgentName:
		return m.OldAgentName(ctx)
	case conversation.FieldMetadata:
		return m.OldMetadata(ctx)
	case conversation.FieldStatus:
		return m.OldStatus(ctx)
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case conversation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case conversation.FieldAgentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentName(v)
		return nil
	case conversation.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case conversation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldDeletedAt) {
		fields = append(fields, conversation.FieldDeletedAt)
	}
	if m.FieldCleared(conversation.FieldAgentName) {
		fields = append(fields, conversation.FieldAgentName)
	}
	if m.FieldCleared(conversation.FieldMetadata) {
		fields = append(fields, conversation.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case conversation.FieldAgentName:
		m.ClearAgentName()
		return nil
	case conversation.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case conversation.FieldUserID:
		m.ResetUserID()
		return nil
	case conversation.FieldTitle:
		m.ResetTitle()
		return nil
	case conversation.FieldAgentName:
		m.ResetAgentName()
		return nil
	case conversation.FieldMetadata:
		m.ResetMetadata()
		return nil
	case conversation.FieldStatus:
		m.ResetStatus()
		return nil
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, conversation.EdgeUser)
	}
	if m.messages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, conversation.EdgeUser)
	}
	if m.clearedmessages {
		edges = append(edges, conversation.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	switch name {
	case conversation.EdgeUser:
		return m.cleareduser
	case conversation.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	switch name {
	case conversation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	switch name {
	case conversation.EdgeUser:
		m.ResetUser()
		return nil
	case conversation.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	deleted_at          *time.Time
	role                *string
	agent_name          *string
	_type               *string
	content             *string
	media_url           *string
	sequence            *int
	addsequence         *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	conversation        *uuid.UUID
	clearedconversation bool
	attachments         map[uuid.UUID]struct{}
	removedattachments  map[uuid.UUID]struct{}
	clearedattachments  bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[message.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, message.FieldDeletedAt)
}

// SetConversationID sets the "conversation_id" field.
func (m *MessageMutation) SetConversationID(u uuid.UUID) {
	m.conversation = &u
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *MessageMutation) ConversationID() (r uuid.UUID, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldConversationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *MessageMutation) ResetConversationID() {
	m.conversation = nil
}

// SetRole sets the "role" field.
func (m *MessageMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *MessageMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MessageMutation) ResetRole() {
	m.role = nil
}

// SetAgentName sets the "agent_name" field.
func (m *MessageMutation) SetAgentName(s string) {
	m.agent_name = &s
}

// AgentName returns the value of the "agent_name" field in the mutation.
func (m *MessageMutation) AgentName() (r string, exists bool) {
	v := m.agent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentName returns the old "agent_name" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldAgentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentName: %w", err)
	}
	return oldValue.AgentName, nil
}

// ClearAgentName clears the value of the "agent_name" field.
func (m *MessageMutation) ClearAgentName() {
	m.agent_name = nil
	m.clearedFields[message.FieldAgentName] = struct{}{}
}

// AgentNameCleared returns if the "agent_name" field was cleared in this mutation.
func (m *MessageMutation) AgentNameCleared() bool {
	_, ok := m.clearedFields[message.FieldAgentName]
	return ok
}

// ResetAgentName resets all changes to the "agent_name" field.
func (m *MessageMutation) ResetAgentName() {
	m.agent_name = nil
	delete(m.clearedFields, message.FieldAgentName)
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MessageMutation) ClearContent() {
	m.content = nil
	m.clearedFields[message.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MessageMutation) ContentCleared() bool {
	_, ok := m.clearedFields[message.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, message.FieldContent)
}

// SetMediaURL sets the "media_url" field.
func (m *MessageMutation) SetMediaURL(s string) {
	m.media_url = &s
}

// MediaURL returns the value of the "media_url" field in the mutation.
func (m *MessageMutation) MediaURL() (r string, exists bool) {
	v := m.media_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaURL returns the old "media_url" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldMediaURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaURL: %w", err)
	}
	return oldValue.MediaURL, nil
}

// ClearMediaURL clears the value of the "media_url" field.
func (m *MessageMutation) ClearMediaURL() {
	m.media_url = nil
	m.clearedFields[message.FieldMediaURL] = struct{}{}
}

// MediaURLCleared returns if the "media_url" field was cleared in this mutation.
func (m *MessageMutation) MediaURLCleared() bool {
	_, ok := m.clearedFields[message.FieldMediaURL]
	return ok
}

// ResetMediaURL resets all changes to the "media_url" field.
func (m *MessageMutation) ResetMediaURL() {
	m.media_url = nil
	delete(m.clearedFields, message.FieldMediaURL)
}

// SetSequence sets the "sequence" field.
func (m *MessageMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *MessageMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *MessageMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *MessageMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *MessageMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *MessageMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[message.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *MessageMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ConversationIDs() (ids []uuid.UUID) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *MessageMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *MessageMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *MessageMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *MessageMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *MessageMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *MessageMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *MessageMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *MessageMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.conversation != nil {
		fields = append(fields, message.FieldConversationID)
	}
	if m.role != nil {
		fields = append(fields, message.FieldRole)
	}
	if m.agent_name != nil {
		fields = append(fields, message.FieldAgentName)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.media_url != nil {
		fields = append(fields, message.FieldMediaURL)
	}
	if m.sequence != nil {
		fields = append(fields, message.FieldSequence)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldDeletedAt:
		return m.DeletedAt()
	case message.FieldConversationID:
		return m.ConversationID()
	case message.FieldRole:
		return m.Role()
	case message.FieldAgentName:
		return m.AgentName()
	case message.FieldType:
		return m.GetType()
	case message.FieldContent:
		return m.Content()
	case message.FieldMediaURL:
		return m.MediaURL()
	case message.FieldSequence:
		return m.Sequence()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case message.FieldConversationID:
		return m.OldConversationID(ctx)
	case message.FieldRole:
		return m.OldRole(ctx)
	case message.FieldAgentName:
		return m.OldAgentName(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldMediaURL:
		return m.OldMediaURL(ctx)
	case message.FieldSequence:
		return m.OldSequence(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case message.FieldConversationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case message.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case message.FieldAgentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentName(v)
		return nil
	case message.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldMediaURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaURL(v)
		return nil
	case message.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, message.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case message.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldDeletedAt) {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.FieldCleared(message.FieldAgentName) {
		fields = append(fields, message.FieldAgentName)
	}
	if m.FieldCleared(message.FieldContent) {
		fields = append(fields, message.FieldContent)
	}
	if m.FieldCleared(message.FieldMediaURL) {
		fields = append(fields, message.FieldMediaURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case message.FieldAgentName:
		m.ClearAgentName()
		return nil
	case message.FieldContent:
		m.ClearContent()
		return nil
	case message.FieldMediaURL:
		m.ClearMediaURL()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case message.FieldConversationID:
		m.ResetConversationID()
		return nil
	case message.FieldRole:
		m.ResetRole()
		return nil
	case message.FieldAgentName:
		m.ResetAgentName()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldMediaURL:
		m.ResetMediaURL()
		return nil
	case message.FieldSequence:
		m.ResetSequence()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.conversation != nil {
		edges = append(edges, message.EdgeConversation)
	}
	if m.attachments != nil {
		edges = append(edges, message.EdgeAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattachments != nil {
		edges = append(edges, message.EdgeAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconversation {
		edges = append(edges, message.EdgeConversation)
	}
	if m.clearedattachments {
		edges = append(edges, message.EdgeAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeConversation:
		return m.clearedconversation
	case message.EdgeAttachments:
		return m.clearedattachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ClearConversation()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ResetConversation()
		return nil
	case message.EdgeAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// ResumeMutation represents an operation that mutates the Resume nodes in the graph.
type ResumeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	deleted_at            *time.Time
	name                  *string
	gender                *string
	birthday              *time.Time
	email                 *string
	phone                 *string
	current_city          *string
	highest_education     *string
	years_experience      *float64
	addyears_experience   *float64
	resume_file_url       *string
	status                *string
	error_message         *string
	parsed_at             *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	educations            map[uuid.UUID]struct{}
	removededucations     map[uuid.UUID]struct{}
	clearededucations     bool
	experiences           map[uuid.UUID]struct{}
	removedexperiences    map[uuid.UUID]struct{}
	clearedexperiences    bool
	skills                map[uuid.UUID]struct{}
	removedskills         map[uuid.UUID]struct{}
	clearedskills         bool
	logs                  map[uuid.UUID]struct{}
	removedlogs           map[uuid.UUID]struct{}
	clearedlogs           bool
	document_parse        map[uuid.UUID]struct{}
	removeddocument_parse map[uuid.UUID]struct{}
	cleareddocument_parse bool
	done                  bool
	oldValue              func(context.Context) (*Resume, error)
	predicates            []predicate.Resume
}

var _ ent.Mutation = (*ResumeMutation)(nil)

// resumeOption allows management of the mutation configuration using functional options.
type resumeOption func(*ResumeMutation)

// newResumeMutation creates new mutation for the Resume entity.
func newResumeMutation(c config, op Op, opts ...resumeOption) *ResumeMutation {
	m := &ResumeMutation{
		config:        c,
		op:            op,
		typ:           TypeResume,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeID sets the ID field of the mutation.
func withResumeID(id uuid.UUID) resumeOption {
	return func(m *ResumeMutation) {
		var (
			err   error
			once  sync.Once
			value *Resume
		)
		m.oldValue = func(ctx context.Context) (*Resume, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resume.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResume sets the old Resume of the mutation.
func withResume(node *Resume) resumeOption {
	return func(m *ResumeMutation) {
		m.oldValue = func(context.Context) (*Resume, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Resume entities.
func (m *ResumeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resume.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resume.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resume.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resume.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *ResumeMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ResumeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ResumeMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *ResumeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResumeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ResumeMutation) ClearName() {
	m.name = nil
	m.clearedFields[resume.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ResumeMutation) NameCleared() bool {
	_, ok := m.clearedFields[resume.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ResumeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, resume.FieldName)
}

// SetGender sets the "gender" field.
func (m *ResumeMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *ResumeMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *ResumeMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[resume.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *ResumeMutation) GenderCleared() bool {
	_, ok := m.clearedFields[resume.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *ResumeMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, resume.FieldGender)
}

// SetBirthday sets the "birthday" field.
func (m *ResumeMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *ResumeMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *ResumeMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[resume.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *ResumeMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[resume.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *ResumeMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, resume.FieldBirthday)
}

// SetEmail sets the "email" field.
func (m *ResumeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ResumeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ResumeMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[resume.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ResumeMutation) EmailCleared() bool {
	_, ok := m.clearedFields[resume.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ResumeMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, resume.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *ResumeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ResumeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *ResumeMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[resume.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *ResumeMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[resume.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *ResumeMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, resume.FieldPhone)
}

// SetCurrentCity sets the "current_city" field.
func (m *ResumeMutation) SetCurrentCity(s string) {
	m.current_city = &s
}

// CurrentCity returns the value of the "current_city" field in the mutation.
func (m *ResumeMutation) CurrentCity() (r string, exists bool) {
	v := m.current_city
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentCity returns the old "current_city" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldCurrentCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentCity: %w", err)
	}
	return oldValue.CurrentCity, nil
}

// ClearCurrentCity clears the value of the "current_city" field.
func (m *ResumeMutation) ClearCurrentCity() {
	m.current_city = nil
	m.clearedFields[resume.FieldCurrentCity] = struct{}{}
}

// CurrentCityCleared returns if the "current_city" field was cleared in this mutation.
func (m *ResumeMutation) CurrentCityCleared() bool {
	_, ok := m.clearedFields[resume.FieldCurrentCity]
	return ok
}

// ResetCurrentCity resets all changes to the "current_city" field.
func (m *ResumeMutation) ResetCurrentCity() {
	m.current_city = nil
	delete(m.clearedFields, resume.FieldCurrentCity)
}

// SetHighestEducation sets the "highest_education" field.
func (m *ResumeMutation) SetHighestEducation(s string) {
	m.highest_education = &s
}

// HighestEducation returns the value of the "highest_education" field in the mutation.
func (m *ResumeMutation) HighestEducation() (r string, exists bool) {
	v := m.highest_education
	if v == nil {
		return
	}
	return *v, true
}

// OldHighestEducation returns the old "highest_education" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldHighestEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighestEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighestEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighestEducation: %w", err)
	}
	return oldValue.HighestEducation, nil
}

// ClearHighestEducation clears the value of the "highest_education" field.
func (m *ResumeMutation) ClearHighestEducation() {
	m.highest_education = nil
	m.clearedFields[resume.FieldHighestEducation] = struct{}{}
}

// HighestEducationCleared returns if the "highest_education" field was cleared in this mutation.
func (m *ResumeMutation) HighestEducationCleared() bool {
	_, ok := m.clearedFields[resume.FieldHighestEducation]
	return ok
}

// ResetHighestEducation resets all changes to the "highest_education" field.
func (m *ResumeMutation) ResetHighestEducation() {
	m.highest_education = nil
	delete(m.clearedFields, resume.FieldHighestEducation)
}

// SetYearsExperience sets the "years_experience" field.
func (m *ResumeMutation) SetYearsExperience(f float64) {
	m.years_experience = &f
	m.addyears_experience = nil
}

// YearsExperience returns the value of the "years_experience" field in the mutation.
func (m *ResumeMutation) YearsExperience() (r float64, exists bool) {
	v := m.years_experience
	if v == nil {
		return
	}
	return *v, true
}

// OldYearsExperience returns the old "years_experience" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldYearsExperience(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYearsExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYearsExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearsExperience: %w", err)
	}
	return oldValue.YearsExperience, nil
}

// AddYearsExperience adds f to the "years_experience" field.
func (m *ResumeMutation) AddYearsExperience(f float64) {
	if m.addyears_experience != nil {
		*m.addyears_experience += f
	} else {
		m.addyears_experience = &f
	}
}

// AddedYearsExperience returns the value that was added to the "years_experience" field in this mutation.
func (m *ResumeMutation) AddedYearsExperience() (r float64, exists bool) {
	v := m.addyears_experience
	if v == nil {
		return
	}
	return *v, true
}

// ClearYearsExperience clears the value of the "years_experience" field.
func (m *ResumeMutation) ClearYearsExperience() {
	m.years_experience = nil
	m.addyears_experience = nil
	m.clearedFields[resume.FieldYearsExperience] = struct{}{}
}

// YearsExperienceCleared returns if the "years_experience" field was cleared in this mutation.
func (m *ResumeMutation) YearsExperienceCleared() bool {
	_, ok := m.clearedFields[resume.FieldYearsExperience]
	return ok
}

// ResetYearsExperience resets all changes to the "years_experience" field.
func (m *ResumeMutation) ResetYearsExperience() {
	m.years_experience = nil
	m.addyears_experience = nil
	delete(m.clearedFields, resume.FieldYearsExperience)
}

// SetResumeFileURL sets the "resume_file_url" field.
func (m *ResumeMutation) SetResumeFileURL(s string) {
	m.resume_file_url = &s
}

// ResumeFileURL returns the value of the "resume_file_url" field in the mutation.
func (m *ResumeMutation) ResumeFileURL() (r string, exists bool) {
	v := m.resume_file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeFileURL returns the old "resume_file_url" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldResumeFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeFileURL: %w", err)
	}
	return oldValue.ResumeFileURL, nil
}

// ClearResumeFileURL clears the value of the "resume_file_url" field.
func (m *ResumeMutation) ClearResumeFileURL() {
	m.resume_file_url = nil
	m.clearedFields[resume.FieldResumeFileURL] = struct{}{}
}

// ResumeFileURLCleared returns if the "resume_file_url" field was cleared in this mutation.
func (m *ResumeMutation) ResumeFileURLCleared() bool {
	_, ok := m.clearedFields[resume.FieldResumeFileURL]
	return ok
}

// ResetResumeFileURL resets all changes to the "resume_file_url" field.
func (m *ResumeMutation) ResetResumeFileURL() {
	m.resume_file_url = nil
	delete(m.clearedFields, resume.FieldResumeFileURL)
}

// SetStatus sets the "status" field.
func (m *ResumeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ResumeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ResumeMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ResumeMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ResumeMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ResumeMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[resume.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ResumeMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[resume.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ResumeMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, resume.FieldErrorMessage)
}

// SetParsedAt sets the "parsed_at" field.
func (m *ResumeMutation) SetParsedAt(t time.Time) {
	m.parsed_at = &t
}

// ParsedAt returns the value of the "parsed_at" field in the mutation.
func (m *ResumeMutation) ParsedAt() (r time.Time, exists bool) {
	v := m.parsed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldParsedAt returns the old "parsed_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldParsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParsedAt: %w", err)
	}
	return oldValue.ParsedAt, nil
}

// ClearParsedAt clears the value of the "parsed_at" field.
func (m *ResumeMutation) ClearParsedAt() {
	m.parsed_at = nil
	m.clearedFields[resume.FieldParsedAt] = struct{}{}
}

// ParsedAtCleared returns if the "parsed_at" field was cleared in this mutation.
func (m *ResumeMutation) ParsedAtCleared() bool {
	_, ok := m.clearedFields[resume.FieldParsedAt]
	return ok
}

// ResetParsedAt resets all changes to the "parsed_at" field.
func (m *ResumeMutation) ResetParsedAt() {
	m.parsed_at = nil
	delete(m.clearedFields, resume.FieldParsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ResumeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[resume.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ResumeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ResumeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ResumeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEducationIDs adds the "educations" edge to the ResumeEducation entity by ids.
func (m *ResumeMutation) AddEducationIDs(ids ...uuid.UUID) {
	if m.educations == nil {
		m.educations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.educations[ids[i]] = struct{}{}
	}
}

// ClearEducations clears the "educations" edge to the ResumeEducation entity.
func (m *ResumeMutation) ClearEducations() {
	m.clearededucations = true
}

// EducationsCleared reports if the "educations" edge to the ResumeEducation entity was cleared.
func (m *ResumeMutation) EducationsCleared() bool {
	return m.clearededucations
}

// RemoveEducationIDs removes the "educations" edge to the ResumeEducation entity by IDs.
func (m *ResumeMutation) RemoveEducationIDs(ids ...uuid.UUID) {
	if m.removededucations == nil {
		m.removededucations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.educations, ids[i])
		m.removededucations[ids[i]] = struct{}{}
	}
}

// RemovedEducations returns the removed IDs of the "educations" edge to the ResumeEducation entity.
func (m *ResumeMutation) RemovedEducationsIDs() (ids []uuid.UUID) {
	for id := range m.removededucations {
		ids = append(ids, id)
	}
	return
}

// EducationsIDs returns the "educations" edge IDs in the mutation.
func (m *ResumeMutation) EducationsIDs() (ids []uuid.UUID) {
	for id := range m.educations {
		ids = append(ids, id)
	}
	return
}

// ResetEducations resets all changes to the "educations" edge.
func (m *ResumeMutation) ResetEducations() {
	m.educations = nil
	m.clearededucations = false
	m.removededucations = nil
}

// AddExperienceIDs adds the "experiences" edge to the ResumeExperience entity by ids.
func (m *ResumeMutation) AddExperienceIDs(ids ...uuid.UUID) {
	if m.experiences == nil {
		m.experiences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.experiences[ids[i]] = struct{}{}
	}
}

// ClearExperiences clears the "experiences" edge to the ResumeExperience entity.
func (m *ResumeMutation) ClearExperiences() {
	m.clearedexperiences = true
}

// ExperiencesCleared reports if the "experiences" edge to the ResumeExperience entity was cleared.
func (m *ResumeMutation) ExperiencesCleared() bool {
	return m.clearedexperiences
}

// RemoveExperienceIDs removes the "experiences" edge to the ResumeExperience entity by IDs.
func (m *ResumeMutation) RemoveExperienceIDs(ids ...uuid.UUID) {
	if m.removedexperiences == nil {
		m.removedexperiences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.experiences, ids[i])
		m.removedexperiences[ids[i]] = struct{}{}
	}
}

// RemovedExperiences returns the removed IDs of the "experiences" edge to the ResumeExperience entity.
func (m *ResumeMutation) RemovedExperiencesIDs() (ids []uuid.UUID) {
	for id := range m.removedexperiences {
		ids = append(ids, id)
	}
	return
}

// ExperiencesIDs returns the "experiences" edge IDs in the mutation.
func (m *ResumeMutation) ExperiencesIDs() (ids []uuid.UUID) {
	for id := range m.experiences {
		ids = append(ids, id)
	}
	return
}

// ResetExperiences resets all changes to the "experiences" edge.
func (m *ResumeMutation) ResetExperiences() {
	m.experiences = nil
	m.clearedexperiences = false
	m.removedexperiences = nil
}

// AddSkillIDs adds the "skills" edge to the ResumeSkill entity by ids.
func (m *ResumeMutation) AddSkillIDs(ids ...uuid.UUID) {
	if m.skills == nil {
		m.skills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the ResumeSkill entity.
func (m *ResumeMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the ResumeSkill entity was cleared.
func (m *ResumeMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the ResumeSkill entity by IDs.
func (m *ResumeMutation) RemoveSkillIDs(ids ...uuid.UUID) {
	if m.removedskills == nil {
		m.removedskills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the ResumeSkill entity.
func (m *ResumeMutation) RemovedSkillsIDs() (ids []uuid.UUID) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *ResumeMutation) SkillsIDs() (ids []uuid.UUID) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *ResumeMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// AddLogIDs adds the "logs" edge to the ResumeLog entity by ids.
func (m *ResumeMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the ResumeLog entity.
func (m *ResumeMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the ResumeLog entity was cleared.
func (m *ResumeMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the ResumeLog entity by IDs.
func (m *ResumeMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the ResumeLog entity.
func (m *ResumeMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *ResumeMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *ResumeMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddDocumentParseIDs adds the "document_parse" edge to the ResumeDocumentParse entity by ids.
func (m *ResumeMutation) AddDocumentParseIDs(ids ...uuid.UUID) {
	if m.document_parse == nil {
		m.document_parse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.document_parse[ids[i]] = struct{}{}
	}
}

// ClearDocumentParse clears the "document_parse" edge to the ResumeDocumentParse entity.
func (m *ResumeMutation) ClearDocumentParse() {
	m.cleareddocument_parse = true
}

// DocumentParseCleared reports if the "document_parse" edge to the ResumeDocumentParse entity was cleared.
func (m *ResumeMutation) DocumentParseCleared() bool {
	return m.cleareddocument_parse
}

// RemoveDocumentParseIDs removes the "document_parse" edge to the ResumeDocumentParse entity by IDs.
func (m *ResumeMutation) RemoveDocumentParseIDs(ids ...uuid.UUID) {
	if m.removeddocument_parse == nil {
		m.removeddocument_parse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.document_parse, ids[i])
		m.removeddocument_parse[ids[i]] = struct{}{}
	}
}

// RemovedDocumentParse returns the removed IDs of the "document_parse" edge to the ResumeDocumentParse entity.
func (m *ResumeMutation) RemovedDocumentParseIDs() (ids []uuid.UUID) {
	for id := range m.removeddocument_parse {
		ids = append(ids, id)
	}
	return
}

// DocumentParseIDs returns the "document_parse" edge IDs in the mutation.
func (m *ResumeMutation) DocumentParseIDs() (ids []uuid.UUID) {
	for id := range m.document_parse {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentParse resets all changes to the "document_parse" edge.
func (m *ResumeMutation) ResetDocumentParse() {
	m.document_parse = nil
	m.cleareddocument_parse = false
	m.removeddocument_parse = nil
}

// Where appends a list predicates to the ResumeMutation builder.
func (m *ResumeMutation) Where(ps ...predicate.Resume) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resume, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resume).
func (m *ResumeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.deleted_at != nil {
		fields = append(fields, resume.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, resume.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, resume.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, resume.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, resume.FieldBirthday)
	}
	if m.email != nil {
		fields = append(fields, resume.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, resume.FieldPhone)
	}
	if m.current_city != nil {
		fields = append(fields, resume.FieldCurrentCity)
	}
	if m.highest_education != nil {
		fields = append(fields, resume.FieldHighestEducation)
	}
	if m.years_experience != nil {
		fields = append(fields, resume.FieldYearsExperience)
	}
	if m.resume_file_url != nil {
		fields = append(fields, resume.FieldResumeFileURL)
	}
	if m.status != nil {
		fields = append(fields, resume.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, resume.FieldErrorMessage)
	}
	if m.parsed_at != nil {
		fields = append(fields, resume.FieldParsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, resume.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resume.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resume.FieldDeletedAt:
		return m.DeletedAt()
	case resume.FieldUserID:
		return m.UserID()
	case resume.FieldName:
		return m.Name()
	case resume.FieldGender:
		return m.Gender()
	case resume.FieldBirthday:
		return m.Birthday()
	case resume.FieldEmail:
		return m.Email()
	case resume.FieldPhone:
		return m.Phone()
	case resume.FieldCurrentCity:
		return m.CurrentCity()
	case resume.FieldHighestEducation:
		return m.HighestEducation()
	case resume.FieldYearsExperience:
		return m.YearsExperience()
	case resume.FieldResumeFileURL:
		return m.ResumeFileURL()
	case resume.FieldStatus:
		return m.Status()
	case resume.FieldErrorMessage:
		return m.ErrorMessage()
	case resume.FieldParsedAt:
		return m.ParsedAt()
	case resume.FieldCreatedAt:
		return m.CreatedAt()
	case resume.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resume.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resume.FieldUserID:
		return m.OldUserID(ctx)
	case resume.FieldName:
		return m.OldName(ctx)
	case resume.FieldGender:
		return m.OldGender(ctx)
	case resume.FieldBirthday:
		return m.OldBirthday(ctx)
	case resume.FieldEmail:
		return m.OldEmail(ctx)
	case resume.FieldPhone:
		return m.OldPhone(ctx)
	case resume.FieldCurrentCity:
		return m.OldCurrentCity(ctx)
	case resume.FieldHighestEducation:
		return m.OldHighestEducation(ctx)
	case resume.FieldYearsExperience:
		return m.OldYearsExperience(ctx)
	case resume.FieldResumeFileURL:
		return m.OldResumeFileURL(ctx)
	case resume.FieldStatus:
		return m.OldStatus(ctx)
	case resume.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case resume.FieldParsedAt:
		return m.OldParsedAt(ctx)
	case resume.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resume.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Resume field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resume.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resume.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case resume.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resume.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case resume.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case resume.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case resume.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case resume.FieldCurrentCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentCity(v)
		return nil
	case resume.FieldHighestEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighestEducation(v)
		return nil
	case resume.FieldYearsExperience:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearsExperience(v)
		return nil
	case resume.FieldResumeFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeFileURL(v)
		return nil
	case resume.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resume.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case resume.FieldParsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParsedAt(v)
		return nil
	case resume.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resume.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Resume field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeMutation) AddedFields() []string {
	var fields []string
	if m.addyears_experience != nil {
		fields = append(fields, resume.FieldYearsExperience)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resume.FieldYearsExperience:
		return m.AddedYearsExperience()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resume.FieldYearsExperience:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYearsExperience(v)
		return nil
	}
	return fmt.Errorf("unknown Resume numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resume.FieldDeletedAt) {
		fields = append(fields, resume.FieldDeletedAt)
	}
	if m.FieldCleared(resume.FieldName) {
		fields = append(fields, resume.FieldName)
	}
	if m.FieldCleared(resume.FieldGender) {
		fields = append(fields, resume.FieldGender)
	}
	if m.FieldCleared(resume.FieldBirthday) {
		fields = append(fields, resume.FieldBirthday)
	}
	if m.FieldCleared(resume.FieldEmail) {
		fields = append(fields, resume.FieldEmail)
	}
	if m.FieldCleared(resume.FieldPhone) {
		fields = append(fields, resume.FieldPhone)
	}
	if m.FieldCleared(resume.FieldCurrentCity) {
		fields = append(fields, resume.FieldCurrentCity)
	}
	if m.FieldCleared(resume.FieldHighestEducation) {
		fields = append(fields, resume.FieldHighestEducation)
	}
	if m.FieldCleared(resume.FieldYearsExperience) {
		fields = append(fields, resume.FieldYearsExperience)
	}
	if m.FieldCleared(resume.FieldResumeFileURL) {
		fields = append(fields, resume.FieldResumeFileURL)
	}
	if m.FieldCleared(resume.FieldErrorMessage) {
		fields = append(fields, resume.FieldErrorMessage)
	}
	if m.FieldCleared(resume.FieldParsedAt) {
		fields = append(fields, resume.FieldParsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeMutation) ClearField(name string) error {
	switch name {
	case resume.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resume.FieldName:
		m.ClearName()
		return nil
	case resume.FieldGender:
		m.ClearGender()
		return nil
	case resume.FieldBirthday:
		m.ClearBirthday()
		return nil
	case resume.FieldEmail:
		m.ClearEmail()
		return nil
	case resume.FieldPhone:
		m.ClearPhone()
		return nil
	case resume.FieldCurrentCity:
		m.ClearCurrentCity()
		return nil
	case resume.FieldHighestEducation:
		m.ClearHighestEducation()
		return nil
	case resume.FieldYearsExperience:
		m.ClearYearsExperience()
		return nil
	case resume.FieldResumeFileURL:
		m.ClearResumeFileURL()
		return nil
	case resume.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case resume.FieldParsedAt:
		m.ClearParsedAt()
		return nil
	}
	return fmt.Errorf("unknown Resume nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeMutation) ResetField(name string) error {
	switch name {
	case resume.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resume.FieldUserID:
		m.ResetUserID()
		return nil
	case resume.FieldName:
		m.ResetName()
		return nil
	case resume.FieldGender:
		m.ResetGender()
		return nil
	case resume.FieldBirthday:
		m.ResetBirthday()
		return nil
	case resume.FieldEmail:
		m.ResetEmail()
		return nil
	case resume.FieldPhone:
		m.ResetPhone()
		return nil
	case resume.FieldCurrentCity:
		m.ResetCurrentCity()
		return nil
	case resume.FieldHighestEducation:
		m.ResetHighestEducation()
		return nil
	case resume.FieldYearsExperience:
		m.ResetYearsExperience()
		return nil
	case resume.FieldResumeFileURL:
		m.ResetResumeFileURL()
		return nil
	case resume.FieldStatus:
		m.ResetStatus()
		return nil
	case resume.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case resume.FieldParsedAt:
		m.ResetParsedAt()
		return nil
	case resume.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resume.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Resume field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.user != nil {
		edges = append(edges, resume.EdgeUser)
	}
	if m.educations != nil {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.experiences != nil {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.skills != nil {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.logs != nil {
		edges = append(edges, resume.EdgeLogs)
	}
	if m.document_parse != nil {
		edges = append(edges, resume.EdgeDocumentParse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resume.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case resume.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.educations))
		for id := range m.educations {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeExperiences:
		ids := make([]ent.Value, 0, len(m.experiences))
		for id := range m.experiences {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeDocumentParse:
		ids := make([]ent.Value, 0, len(m.document_parse))
		for id := range m.document_parse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removededucations != nil {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.removedexperiences != nil {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.removedskills != nil {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.removedlogs != nil {
		edges = append(edges, resume.EdgeLogs)
	}
	if m.removeddocument_parse != nil {
		edges = append(edges, resume.EdgeDocumentParse)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resume.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.removededucations))
		for id := range m.removededucations {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeExperiences:
		ids := make([]ent.Value, 0, len(m.removedexperiences))
		for id := range m.removedexperiences {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeDocumentParse:
		ids := make([]ent.Value, 0, len(m.removeddocument_parse))
		for id := range m.removeddocument_parse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareduser {
		edges = append(edges, resume.EdgeUser)
	}
	if m.clearededucations {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.clearedexperiences {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.clearedskills {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.clearedlogs {
		edges = append(edges, resume.EdgeLogs)
	}
	if m.cleareddocument_parse {
		edges = append(edges, resume.EdgeDocumentParse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeMutation) EdgeCleared(name string) bool {
	switch name {
	case resume.EdgeUser:
		return m.cleareduser
	case resume.EdgeEducations:
		return m.clearededucations
	case resume.EdgeExperiences:
		return m.clearedexperiences
	case resume.EdgeSkills:
		return m.clearedskills
	case resume.EdgeLogs:
		return m.clearedlogs
	case resume.EdgeDocumentParse:
		return m.cleareddocument_parse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeMutation) ClearEdge(name string) error {
	switch name {
	case resume.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Resume unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeMutation) ResetEdge(name string) error {
	switch name {
	case resume.EdgeUser:
		m.ResetUser()
		return nil
	case resume.EdgeEducations:
		m.ResetEducations()
		return nil
	case resume.EdgeExperiences:
		m.ResetExperiences()
		return nil
	case resume.EdgeSkills:
		m.ResetSkills()
		return nil
	case resume.EdgeLogs:
		m.ResetLogs()
		return nil
	case resume.EdgeDocumentParse:
		m.ResetDocumentParse()
		return nil
	}
	return fmt.Errorf("unknown Resume edge %s", name)
}

// ResumeDocumentParseMutation represents an operation that mutates the ResumeDocumentParse nodes in the graph.
type ResumeDocumentParseMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	file_id       *string
	content       *string
	file_type     *string
	filename      *string
	title         *string
	upload_at     *time.Time
	status        *string
	error_message *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeDocumentParse, error)
	predicates    []predicate.ResumeDocumentParse
}

var _ ent.Mutation = (*ResumeDocumentParseMutation)(nil)

// resumedocumentparseOption allows management of the mutation configuration using functional options.
type resumedocumentparseOption func(*ResumeDocumentParseMutation)

// newResumeDocumentParseMutation creates new mutation for the ResumeDocumentParse entity.
func newResumeDocumentParseMutation(c config, op Op, opts ...resumedocumentparseOption) *ResumeDocumentParseMutation {
	m := &ResumeDocumentParseMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeDocumentParse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeDocumentParseID sets the ID field of the mutation.
func withResumeDocumentParseID(id uuid.UUID) resumedocumentparseOption {
	return func(m *ResumeDocumentParseMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeDocumentParse
		)
		m.oldValue = func(ctx context.Context) (*ResumeDocumentParse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeDocumentParse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeDocumentParse sets the old ResumeDocumentParse of the mutation.
func withResumeDocumentParse(node *ResumeDocumentParse) resumedocumentparseOption {
	return func(m *ResumeDocumentParseMutation) {
		m.oldValue = func(context.Context) (*ResumeDocumentParse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeDocumentParseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeDocumentParseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeDocumentParse entities.
func (m *ResumeDocumentParseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeDocumentParseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeDocumentParseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeDocumentParse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeDocumentParseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeDocumentParseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeDocumentParseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumedocumentparse.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeDocumentParseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumedocumentparse.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeDocumentParseMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeDocumentParseMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeDocumentParseMutation) ResetResumeID() {
	m.resume = nil
}

// SetFileID sets the "file_id" field.
func (m *ResumeDocumentParseMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *ResumeDocumentParseMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *ResumeDocumentParseMutation) ClearFileID() {
	m.file_id = nil
	m.clearedFields[resumedocumentparse.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *ResumeDocumentParseMutation) ResetFileID() {
	m.file_id = nil
	delete(m.clearedFields, resumedocumentparse.FieldFileID)
}

// SetContent sets the "content" field.
func (m *ResumeDocumentParseMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ResumeDocumentParseMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ResumeDocumentParseMutation) ClearContent() {
	m.content = nil
	m.clearedFields[resumedocumentparse.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) ContentCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ResumeDocumentParseMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, resumedocumentparse.FieldContent)
}

// SetFileType sets the "file_type" field.
func (m *ResumeDocumentParseMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *ResumeDocumentParseMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ClearFileType clears the value of the "file_type" field.
func (m *ResumeDocumentParseMutation) ClearFileType() {
	m.file_type = nil
	m.clearedFields[resumedocumentparse.FieldFileType] = struct{}{}
}

// FileTypeCleared returns if the "file_type" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) FileTypeCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldFileType]
	return ok
}

// ResetFileType resets all changes to the "file_type" field.
func (m *ResumeDocumentParseMutation) ResetFileType() {
	m.file_type = nil
	delete(m.clearedFields, resumedocumentparse.FieldFileType)
}

// SetFilename sets the "filename" field.
func (m *ResumeDocumentParseMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *ResumeDocumentParseMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ClearFilename clears the value of the "filename" field.
func (m *ResumeDocumentParseMutation) ClearFilename() {
	m.filename = nil
	m.clearedFields[resumedocumentparse.FieldFilename] = struct{}{}
}

// FilenameCleared returns if the "filename" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) FilenameCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldFilename]
	return ok
}

// ResetFilename resets all changes to the "filename" field.
func (m *ResumeDocumentParseMutation) ResetFilename() {
	m.filename = nil
	delete(m.clearedFields, resumedocumentparse.FieldFilename)
}

// SetTitle sets the "title" field.
func (m *ResumeDocumentParseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ResumeDocumentParseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ResumeDocumentParseMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[resumedocumentparse.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) TitleCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ResumeDocumentParseMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, resumedocumentparse.FieldTitle)
}

// SetUploadAt sets the "upload_at" field.
func (m *ResumeDocumentParseMutation) SetUploadAt(t time.Time) {
	m.upload_at = &t
}

// UploadAt returns the value of the "upload_at" field in the mutation.
func (m *ResumeDocumentParseMutation) UploadAt() (r time.Time, exists bool) {
	v := m.upload_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadAt returns the old "upload_at" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldUploadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadAt: %w", err)
	}
	return oldValue.UploadAt, nil
}

// ClearUploadAt clears the value of the "upload_at" field.
func (m *ResumeDocumentParseMutation) ClearUploadAt() {
	m.upload_at = nil
	m.clearedFields[resumedocumentparse.FieldUploadAt] = struct{}{}
}

// UploadAtCleared returns if the "upload_at" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) UploadAtCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldUploadAt]
	return ok
}

// ResetUploadAt resets all changes to the "upload_at" field.
func (m *ResumeDocumentParseMutation) ResetUploadAt() {
	m.upload_at = nil
	delete(m.clearedFields, resumedocumentparse.FieldUploadAt)
}

// SetStatus sets the "status" field.
func (m *ResumeDocumentParseMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ResumeDocumentParseMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ResumeDocumentParseMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ResumeDocumentParseMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ResumeDocumentParseMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ResumeDocumentParseMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[resumedocumentparse.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ResumeDocumentParseMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, resumedocumentparse.FieldErrorMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeDocumentParseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeDocumentParseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeDocumentParseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeDocumentParseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeDocumentParseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeDocumentParseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeDocumentParseMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumedocumentparse.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeDocumentParseMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeDocumentParseMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeDocumentParseMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeDocumentParseMutation builder.
func (m *ResumeDocumentParseMutation) Where(ps ...predicate.ResumeDocumentParse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeDocumentParseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeDocumentParseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeDocumentParse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeDocumentParseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeDocumentParseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeDocumentParse).
func (m *ResumeDocumentParseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeDocumentParseMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.deleted_at != nil {
		fields = append(fields, resumedocumentparse.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumedocumentparse.FieldResumeID)
	}
	if m.file_id != nil {
		fields = append(fields, resumedocumentparse.FieldFileID)
	}
	if m.content != nil {
		fields = append(fields, resumedocumentparse.FieldContent)
	}
	if m.file_type != nil {
		fields = append(fields, resumedocumentparse.FieldFileType)
	}
	if m.filename != nil {
		fields = append(fields, resumedocumentparse.FieldFilename)
	}
	if m.title != nil {
		fields = append(fields, resumedocumentparse.FieldTitle)
	}
	if m.upload_at != nil {
		fields = append(fields, resumedocumentparse.FieldUploadAt)
	}
	if m.status != nil {
		fields = append(fields, resumedocumentparse.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, resumedocumentparse.FieldErrorMessage)
	}
	if m.created_at != nil {
		fields = append(fields, resumedocumentparse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumedocumentparse.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeDocumentParseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		return m.DeletedAt()
	case resumedocumentparse.FieldResumeID:
		return m.ResumeID()
	case resumedocumentparse.FieldFileID:
		return m.FileID()
	case resumedocumentparse.FieldContent:
		return m.Content()
	case resumedocumentparse.FieldFileType:
		return m.FileType()
	case resumedocumentparse.FieldFilename:
		return m.Filename()
	case resumedocumentparse.FieldTitle:
		return m.Title()
	case resumedocumentparse.FieldUploadAt:
		return m.UploadAt()
	case resumedocumentparse.FieldStatus:
		return m.Status()
	case resumedocumentparse.FieldErrorMessage:
		return m.ErrorMessage()
	case resumedocumentparse.FieldCreatedAt:
		return m.CreatedAt()
	case resumedocumentparse.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeDocumentParseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumedocumentparse.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumedocumentparse.FieldFileID:
		return m.OldFileID(ctx)
	case resumedocumentparse.FieldContent:
		return m.OldContent(ctx)
	case resumedocumentparse.FieldFileType:
		return m.OldFileType(ctx)
	case resumedocumentparse.FieldFilename:
		return m.OldFilename(ctx)
	case resumedocumentparse.FieldTitle:
		return m.OldTitle(ctx)
	case resumedocumentparse.FieldUploadAt:
		return m.OldUploadAt(ctx)
	case resumedocumentparse.FieldStatus:
		return m.OldStatus(ctx)
	case resumedocumentparse.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case resumedocumentparse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumedocumentparse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeDocumentParse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeDocumentParseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumedocumentparse.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumedocumentparse.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case resumedocumentparse.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case resumedocumentparse.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case resumedocumentparse.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case resumedocumentparse.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case resumedocumentparse.FieldUploadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadAt(v)
		return nil
	case resumedocumentparse.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resumedocumentparse.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case resumedocumentparse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumedocumentparse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeDocumentParseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeDocumentParseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeDocumentParseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeDocumentParse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeDocumentParseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumedocumentparse.FieldDeletedAt) {
		fields = append(fields, resumedocumentparse.FieldDeletedAt)
	}
	if m.FieldCleared(resumedocumentparse.FieldFileID) {
		fields = append(fields, resumedocumentparse.FieldFileID)
	}
	if m.FieldCleared(resumedocumentparse.FieldContent) {
		fields = append(fields, resumedocumentparse.FieldContent)
	}
	if m.FieldCleared(resumedocumentparse.FieldFileType) {
		fields = append(fields, resumedocumentparse.FieldFileType)
	}
	if m.FieldCleared(resumedocumentparse.FieldFilename) {
		fields = append(fields, resumedocumentparse.FieldFilename)
	}
	if m.FieldCleared(resumedocumentparse.FieldTitle) {
		fields = append(fields, resumedocumentparse.FieldTitle)
	}
	if m.FieldCleared(resumedocumentparse.FieldUploadAt) {
		fields = append(fields, resumedocumentparse.FieldUploadAt)
	}
	if m.FieldCleared(resumedocumentparse.FieldErrorMessage) {
		fields = append(fields, resumedocumentparse.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeDocumentParseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeDocumentParseMutation) ClearField(name string) error {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumedocumentparse.FieldFileID:
		m.ClearFileID()
		return nil
	case resumedocumentparse.FieldContent:
		m.ClearContent()
		return nil
	case resumedocumentparse.FieldFileType:
		m.ClearFileType()
		return nil
	case resumedocumentparse.FieldFilename:
		m.ClearFilename()
		return nil
	case resumedocumentparse.FieldTitle:
		m.ClearTitle()
		return nil
	case resumedocumentparse.FieldUploadAt:
		m.ClearUploadAt()
		return nil
	case resumedocumentparse.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeDocumentParseMutation) ResetField(name string) error {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumedocumentparse.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumedocumentparse.FieldFileID:
		m.ResetFileID()
		return nil
	case resumedocumentparse.FieldContent:
		m.ResetContent()
		return nil
	case resumedocumentparse.FieldFileType:
		m.ResetFileType()
		return nil
	case resumedocumentparse.FieldFilename:
		m.ResetFilename()
		return nil
	case resumedocumentparse.FieldTitle:
		m.ResetTitle()
		return nil
	case resumedocumentparse.FieldUploadAt:
		m.ResetUploadAt()
		return nil
	case resumedocumentparse.FieldStatus:
		m.ResetStatus()
		return nil
	case resumedocumentparse.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case resumedocumentparse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumedocumentparse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeDocumentParseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumedocumentparse.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeDocumentParseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumedocumentparse.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeDocumentParseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeDocumentParseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeDocumentParseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumedocumentparse.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeDocumentParseMutation) EdgeCleared(name string) bool {
	switch name {
	case resumedocumentparse.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeDocumentParseMutation) ClearEdge(name string) error {
	switch name {
	case resumedocumentparse.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeDocumentParseMutation) ResetEdge(name string) error {
	switch name {
	case resumedocumentparse.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse edge %s", name)
}

// ResumeEducationMutation represents an operation that mutates the ResumeEducation nodes in the graph.
type ResumeEducationMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	school        *string
	degree        *string
	major         *string
	start_date    *time.Time
	end_date      *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeEducation, error)
	predicates    []predicate.ResumeEducation
}

var _ ent.Mutation = (*ResumeEducationMutation)(nil)

// resumeeducationOption allows management of the mutation configuration using functional options.
type resumeeducationOption func(*ResumeEducationMutation)

// newResumeEducationMutation creates new mutation for the ResumeEducation entity.
func newResumeEducationMutation(c config, op Op, opts ...resumeeducationOption) *ResumeEducationMutation {
	m := &ResumeEducationMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeEducation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeEducationID sets the ID field of the mutation.
func withResumeEducationID(id uuid.UUID) resumeeducationOption {
	return func(m *ResumeEducationMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeEducation
		)
		m.oldValue = func(ctx context.Context) (*ResumeEducation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeEducation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeEducation sets the old ResumeEducation of the mutation.
func withResumeEducation(node *ResumeEducation) resumeeducationOption {
	return func(m *ResumeEducationMutation) {
		m.oldValue = func(context.Context) (*ResumeEducation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeEducationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeEducationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeEducation entities.
func (m *ResumeEducationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeEducationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeEducationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeEducation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeEducationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeEducationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeEducationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumeeducation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeEducationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeEducationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumeeducation.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeEducationMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeEducationMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeEducationMutation) ResetResumeID() {
	m.resume = nil
}

// SetSchool sets the "school" field.
func (m *ResumeEducationMutation) SetSchool(s string) {
	m.school = &s
}

// School returns the value of the "school" field in the mutation.
func (m *ResumeEducationMutation) School() (r string, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// OldSchool returns the old "school" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldSchool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchool: %w", err)
	}
	return oldValue.School, nil
}

// ClearSchool clears the value of the "school" field.
func (m *ResumeEducationMutation) ClearSchool() {
	m.school = nil
	m.clearedFields[resumeeducation.FieldSchool] = struct{}{}
}

// SchoolCleared returns if the "school" field was cleared in this mutation.
func (m *ResumeEducationMutation) SchoolCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldSchool]
	return ok
}

// ResetSchool resets all changes to the "school" field.
func (m *ResumeEducationMutation) ResetSchool() {
	m.school = nil
	delete(m.clearedFields, resumeeducation.FieldSchool)
}

// SetDegree sets the "degree" field.
func (m *ResumeEducationMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the value of the "degree" field in the mutation.
func (m *ResumeEducationMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old "degree" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ClearDegree clears the value of the "degree" field.
func (m *ResumeEducationMutation) ClearDegree() {
	m.degree = nil
	m.clearedFields[resumeeducation.FieldDegree] = struct{}{}
}

// DegreeCleared returns if the "degree" field was cleared in this mutation.
func (m *ResumeEducationMutation) DegreeCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldDegree]
	return ok
}

// ResetDegree resets all changes to the "degree" field.
func (m *ResumeEducationMutation) ResetDegree() {
	m.degree = nil
	delete(m.clearedFields, resumeeducation.FieldDegree)
}

// SetMajor sets the "major" field.
func (m *ResumeEducationMutation) SetMajor(s string) {
	m.major = &s
}

// Major returns the value of the "major" field in the mutation.
func (m *ResumeEducationMutation) Major() (r string, exists bool) {
	v := m.major
	if v == nil {
		return
	}
	return *v, true
}

// OldMajor returns the old "major" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldMajor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMajor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMajor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMajor: %w", err)
	}
	return oldValue.Major, nil
}

// ClearMajor clears the value of the "major" field.
func (m *ResumeEducationMutation) ClearMajor() {
	m.major = nil
	m.clearedFields[resumeeducation.FieldMajor] = struct{}{}
}

// MajorCleared returns if the "major" field was cleared in this mutation.
func (m *ResumeEducationMutation) MajorCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldMajor]
	return ok
}

// ResetMajor resets all changes to the "major" field.
func (m *ResumeEducationMutation) ResetMajor() {
	m.major = nil
	delete(m.clearedFields, resumeeducation.FieldMajor)
}

// SetStartDate sets the "start_date" field.
func (m *ResumeEducationMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ResumeEducationMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ResumeEducationMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[resumeeducation.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ResumeEducationMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ResumeEducationMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, resumeeducation.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ResumeEducationMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ResumeEducationMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ResumeEducationMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[resumeeducation.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ResumeEducationMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ResumeEducationMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, resumeeducation.FieldEndDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeEducationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeEducationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeEducationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeEducationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeEducationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeEducationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeEducationMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumeeducation.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeEducationMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeEducationMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeEducationMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeEducationMutation builder.
func (m *ResumeEducationMutation) Where(ps ...predicate.ResumeEducation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeEducationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeEducationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeEducation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeEducationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeEducationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeEducation).
func (m *ResumeEducationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeEducationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, resumeeducation.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumeeducation.FieldResumeID)
	}
	if m.school != nil {
		fields = append(fields, resumeeducation.FieldSchool)
	}
	if m.degree != nil {
		fields = append(fields, resumeeducation.FieldDegree)
	}
	if m.major != nil {
		fields = append(fields, resumeeducation.FieldMajor)
	}
	if m.start_date != nil {
		fields = append(fields, resumeeducation.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, resumeeducation.FieldEndDate)
	}
	if m.created_at != nil {
		fields = append(fields, resumeeducation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumeeducation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeEducationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumeeducation.FieldDeletedAt:
		return m.DeletedAt()
	case resumeeducation.FieldResumeID:
		return m.ResumeID()
	case resumeeducation.FieldSchool:
		return m.School()
	case resumeeducation.FieldDegree:
		return m.Degree()
	case resumeeducation.FieldMajor:
		return m.Major()
	case resumeeducation.FieldStartDate:
		return m.StartDate()
	case resumeeducation.FieldEndDate:
		return m.EndDate()
	case resumeeducation.FieldCreatedAt:
		return m.CreatedAt()
	case resumeeducation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeEducationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumeeducation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumeeducation.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumeeducation.FieldSchool:
		return m.OldSchool(ctx)
	case resumeeducation.FieldDegree:
		return m.OldDegree(ctx)
	case resumeeducation.FieldMajor:
		return m.OldMajor(ctx)
	case resumeeducation.FieldStartDate:
		return m.OldStartDate(ctx)
	case resumeeducation.FieldEndDate:
		return m.OldEndDate(ctx)
	case resumeeducation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumeeducation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeEducation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeEducationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumeeducation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumeeducation.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumeeducation.FieldSchool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchool(v)
		return nil
	case resumeeducation.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	case resumeeducation.FieldMajor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMajor(v)
		return nil
	case resumeeducation.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case resumeeducation.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case resumeeducation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumeeducation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeEducationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeEducationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeEducationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeEducation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeEducationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumeeducation.FieldDeletedAt) {
		fields = append(fields, resumeeducation.FieldDeletedAt)
	}
	if m.FieldCleared(resumeeducation.FieldSchool) {
		fields = append(fields, resumeeducation.FieldSchool)
	}
	if m.FieldCleared(resumeeducation.FieldDegree) {
		fields = append(fields, resumeeducation.FieldDegree)
	}
	if m.FieldCleared(resumeeducation.FieldMajor) {
		fields = append(fields, resumeeducation.FieldMajor)
	}
	if m.FieldCleared(resumeeducation.FieldStartDate) {
		fields = append(fields, resumeeducation.FieldStartDate)
	}
	if m.FieldCleared(resumeeducation.FieldEndDate) {
		fields = append(fields, resumeeducation.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeEducationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeEducationMutation) ClearField(name string) error {
	switch name {
	case resumeeducation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumeeducation.FieldSchool:
		m.ClearSchool()
		return nil
	case resumeeducation.FieldDegree:
		m.ClearDegree()
		return nil
	case resumeeducation.FieldMajor:
		m.ClearMajor()
		return nil
	case resumeeducation.FieldStartDate:
		m.ClearStartDate()
		return nil
	case resumeeducation.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeEducationMutation) ResetField(name string) error {
	switch name {
	case resumeeducation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumeeducation.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumeeducation.FieldSchool:
		m.ResetSchool()
		return nil
	case resumeeducation.FieldDegree:
		m.ResetDegree()
		return nil
	case resumeeducation.FieldMajor:
		m.ResetMajor()
		return nil
	case resumeeducation.FieldStartDate:
		m.ResetStartDate()
		return nil
	case resumeeducation.FieldEndDate:
		m.ResetEndDate()
		return nil
	case resumeeducation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumeeducation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeEducationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumeeducation.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeEducationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumeeducation.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeEducationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeEducationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeEducationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumeeducation.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeEducationMutation) EdgeCleared(name string) bool {
	switch name {
	case resumeeducation.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeEducationMutation) ClearEdge(name string) error {
	switch name {
	case resumeeducation.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeEducationMutation) ResetEdge(name string) error {
	switch name {
	case resumeeducation.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation edge %s", name)
}

// ResumeExperienceMutation represents an operation that mutates the ResumeExperience nodes in the graph.
type ResumeExperienceMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	company       *string
	position      *string
	title         *string
	start_date    *time.Time
	end_date      *time.Time
	description   *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeExperience, error)
	predicates    []predicate.ResumeExperience
}

var _ ent.Mutation = (*ResumeExperienceMutation)(nil)

// resumeexperienceOption allows management of the mutation configuration using functional options.
type resumeexperienceOption func(*ResumeExperienceMutation)

// newResumeExperienceMutation creates new mutation for the ResumeExperience entity.
func newResumeExperienceMutation(c config, op Op, opts ...resumeexperienceOption) *ResumeExperienceMutation {
	m := &ResumeExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeExperienceID sets the ID field of the mutation.
func withResumeExperienceID(id uuid.UUID) resumeexperienceOption {
	return func(m *ResumeExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeExperience
		)
		m.oldValue = func(ctx context.Context) (*ResumeExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeExperience sets the old ResumeExperience of the mutation.
func withResumeExperience(node *ResumeExperience) resumeexperienceOption {
	return func(m *ResumeExperienceMutation) {
		m.oldValue = func(context.Context) (*ResumeExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeExperience entities.
func (m *ResumeExperienceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeExperienceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeExperienceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeExperienceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeExperienceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeExperienceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumeexperience.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeExperienceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeExperienceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumeexperience.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeExperienceMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeExperienceMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeExperienceMutation) ResetResumeID() {
	m.resume = nil
}

// SetCompany sets the "company" field.
func (m *ResumeExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *ResumeExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *ResumeExperienceMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[resumeexperience.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *ResumeExperienceMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *ResumeExperienceMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, resumeexperience.FieldCompany)
}

// SetPosition sets the "position" field.
func (m *ResumeExperienceMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *ResumeExperienceMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *ResumeExperienceMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[resumeexperience.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *ResumeExperienceMutation) PositionCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *ResumeExperienceMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, resumeexperience.FieldPosition)
}

// SetTitle sets the "title" field.
func (m *ResumeExperienceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ResumeExperienceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ResumeExperienceMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[resumeexperience.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ResumeExperienceMutation) TitleCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ResumeExperienceMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, resumeexperience.FieldTitle)
}

// SetStartDate sets the "start_date" field.
func (m *ResumeExperienceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ResumeExperienceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ResumeExperienceMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[resumeexperience.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ResumeExperienceMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ResumeExperienceMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, resumeexperience.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ResumeExperienceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ResumeExperienceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ResumeExperienceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[resumeexperience.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ResumeExperienceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ResumeExperienceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, resumeexperience.FieldEndDate)
}

// SetDescription sets the "description" field.
func (m *ResumeExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResumeExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResumeExperienceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resumeexperience.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResumeExperienceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResumeExperienceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resumeexperience.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeExperienceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeExperienceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeExperienceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeExperienceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeExperienceMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumeexperience.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeExperienceMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeExperienceMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeExperienceMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeExperienceMutation builder.
func (m *ResumeExperienceMutation) Where(ps ...predicate.ResumeExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeExperience).
func (m *ResumeExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeExperienceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, resumeexperience.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumeexperience.FieldResumeID)
	}
	if m.company != nil {
		fields = append(fields, resumeexperience.FieldCompany)
	}
	if m.position != nil {
		fields = append(fields, resumeexperience.FieldPosition)
	}
	if m.title != nil {
		fields = append(fields, resumeexperience.FieldTitle)
	}
	if m.start_date != nil {
		fields = append(fields, resumeexperience.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, resumeexperience.FieldEndDate)
	}
	if m.description != nil {
		fields = append(fields, resumeexperience.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, resumeexperience.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumeexperience.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumeexperience.FieldDeletedAt:
		return m.DeletedAt()
	case resumeexperience.FieldResumeID:
		return m.ResumeID()
	case resumeexperience.FieldCompany:
		return m.Company()
	case resumeexperience.FieldPosition:
		return m.Position()
	case resumeexperience.FieldTitle:
		return m.Title()
	case resumeexperience.FieldStartDate:
		return m.StartDate()
	case resumeexperience.FieldEndDate:
		return m.EndDate()
	case resumeexperience.FieldDescription:
		return m.Description()
	case resumeexperience.FieldCreatedAt:
		return m.CreatedAt()
	case resumeexperience.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumeexperience.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumeexperience.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumeexperience.FieldCompany:
		return m.OldCompany(ctx)
	case resumeexperience.FieldPosition:
		return m.OldPosition(ctx)
	case resumeexperience.FieldTitle:
		return m.OldTitle(ctx)
	case resumeexperience.FieldStartDate:
		return m.OldStartDate(ctx)
	case resumeexperience.FieldEndDate:
		return m.OldEndDate(ctx)
	case resumeexperience.FieldDescription:
		return m.OldDescription(ctx)
	case resumeexperience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumeexperience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumeexperience.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumeexperience.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumeexperience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case resumeexperience.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case resumeexperience.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case resumeexperience.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case resumeexperience.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case resumeexperience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resumeexperience.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumeexperience.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeExperienceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeExperienceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumeexperience.FieldDeletedAt) {
		fields = append(fields, resumeexperience.FieldDeletedAt)
	}
	if m.FieldCleared(resumeexperience.FieldCompany) {
		fields = append(fields, resumeexperience.FieldCompany)
	}
	if m.FieldCleared(resumeexperience.FieldPosition) {
		fields = append(fields, resumeexperience.FieldPosition)
	}
	if m.FieldCleared(resumeexperience.FieldTitle) {
		fields = append(fields, resumeexperience.FieldTitle)
	}
	if m.FieldCleared(resumeexperience.FieldStartDate) {
		fields = append(fields, resumeexperience.FieldStartDate)
	}
	if m.FieldCleared(resumeexperience.FieldEndDate) {
		fields = append(fields, resumeexperience.FieldEndDate)
	}
	if m.FieldCleared(resumeexperience.FieldDescription) {
		fields = append(fields, resumeexperience.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeExperienceMutation) ClearField(name string) error {
	switch name {
	case resumeexperience.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumeexperience.FieldCompany:
		m.ClearCompany()
		return nil
	case resumeexperience.FieldPosition:
		m.ClearPosition()
		return nil
	case resumeexperience.FieldTitle:
		m.ClearTitle()
		return nil
	case resumeexperience.FieldStartDate:
		m.ClearStartDate()
		return nil
	case resumeexperience.FieldEndDate:
		m.ClearEndDate()
		return nil
	case resumeexperience.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeExperienceMutation) ResetField(name string) error {
	switch name {
	case resumeexperience.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumeexperience.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumeexperience.FieldCompany:
		m.ResetCompany()
		return nil
	case resumeexperience.FieldPosition:
		m.ResetPosition()
		return nil
	case resumeexperience.FieldTitle:
		m.ResetTitle()
		return nil
	case resumeexperience.FieldStartDate:
		m.ResetStartDate()
		return nil
	case resumeexperience.FieldEndDate:
		m.ResetEndDate()
		return nil
	case resumeexperience.FieldDescription:
		m.ResetDescription()
		return nil
	case resumeexperience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumeexperience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumeexperience.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumeexperience.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumeexperience.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case resumeexperience.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeExperienceMutation) ClearEdge(name string) error {
	switch name {
	case resumeexperience.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeExperienceMutation) ResetEdge(name string) error {
	switch name {
	case resumeexperience.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience edge %s", name)
}

// ResumeLogMutation represents an operation that mutates the ResumeLog nodes in the graph.
type ResumeLogMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	action        *string
	message       *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeLog, error)
	predicates    []predicate.ResumeLog
}

var _ ent.Mutation = (*ResumeLogMutation)(nil)

// resumelogOption allows management of the mutation configuration using functional options.
type resumelogOption func(*ResumeLogMutation)

// newResumeLogMutation creates new mutation for the ResumeLog entity.
func newResumeLogMutation(c config, op Op, opts ...resumelogOption) *ResumeLogMutation {
	m := &ResumeLogMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeLogID sets the ID field of the mutation.
func withResumeLogID(id uuid.UUID) resumelogOption {
	return func(m *ResumeLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeLog
		)
		m.oldValue = func(ctx context.Context) (*ResumeLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeLog sets the old ResumeLog of the mutation.
func withResumeLog(node *ResumeLog) resumelogOption {
	return func(m *ResumeLogMutation) {
		m.oldValue = func(context.Context) (*ResumeLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeLog entities.
func (m *ResumeLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumelog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumelog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumelog.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeLogMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeLogMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeLogMutation) ResetResumeID() {
	m.resume = nil
}

// SetAction sets the "action" field.
func (m *ResumeLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *ResumeLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *ResumeLogMutation) ResetAction() {
	m.action = nil
}

// SetMessage sets the "message" field.
func (m *ResumeLogMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ResumeLogMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *ResumeLogMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[resumelog.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *ResumeLogMutation) MessageCleared() bool {
	_, ok := m.clearedFields[resumelog.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *ResumeLogMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, resumelog.FieldMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeLogMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumelog.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeLogMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeLogMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeLogMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeLogMutation builder.
func (m *ResumeLogMutation) Where(ps ...predicate.ResumeLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeLog).
func (m *ResumeLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, resumelog.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumelog.FieldResumeID)
	}
	if m.action != nil {
		fields = append(fields, resumelog.FieldAction)
	}
	if m.message != nil {
		fields = append(fields, resumelog.FieldMessage)
	}
	if m.created_at != nil {
		fields = append(fields, resumelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumelog.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumelog.FieldDeletedAt:
		return m.DeletedAt()
	case resumelog.FieldResumeID:
		return m.ResumeID()
	case resumelog.FieldAction:
		return m.Action()
	case resumelog.FieldMessage:
		return m.Message()
	case resumelog.FieldCreatedAt:
		return m.CreatedAt()
	case resumelog.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumelog.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumelog.FieldAction:
		return m.OldAction(ctx)
	case resumelog.FieldMessage:
		return m.OldMessage(ctx)
	case resumelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumelog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumelog.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumelog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case resumelog.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case resumelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumelog.FieldDeletedAt) {
		fields = append(fields, resumelog.FieldDeletedAt)
	}
	if m.FieldCleared(resumelog.FieldMessage) {
		fields = append(fields, resumelog.FieldMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeLogMutation) ClearField(name string) error {
	switch name {
	case resumelog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumelog.FieldMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown ResumeLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeLogMutation) ResetField(name string) error {
	switch name {
	case resumelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumelog.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumelog.FieldAction:
		m.ResetAction()
		return nil
	case resumelog.FieldMessage:
		m.ResetMessage()
		return nil
	case resumelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumelog.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumelog.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumelog.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeLogMutation) EdgeCleared(name string) bool {
	switch name {
	case resumelog.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeLogMutation) ClearEdge(name string) error {
	switch name {
	case resumelog.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeLogMutation) ResetEdge(name string) error {
	switch name {
	case resumelog.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeLog edge %s", name)
}

// ResumeSkillMutation represents an operation that mutates the ResumeSkill nodes in the graph.
type ResumeSkillMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	skill_name    *string
	level         *string
	description   *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeSkill, error)
	predicates    []predicate.ResumeSkill
}

var _ ent.Mutation = (*ResumeSkillMutation)(nil)

// resumeskillOption allows management of the mutation configuration using functional options.
type resumeskillOption func(*ResumeSkillMutation)

// newResumeSkillMutation creates new mutation for the ResumeSkill entity.
func newResumeSkillMutation(c config, op Op, opts ...resumeskillOption) *ResumeSkillMutation {
	m := &ResumeSkillMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeSkillID sets the ID field of the mutation.
func withResumeSkillID(id uuid.UUID) resumeskillOption {
	return func(m *ResumeSkillMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeSkill
		)
		m.oldValue = func(ctx context.Context) (*ResumeSkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeSkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeSkill sets the old ResumeSkill of the mutation.
func withResumeSkill(node *ResumeSkill) resumeskillOption {
	return func(m *ResumeSkillMutation) {
		m.oldValue = func(context.Context) (*ResumeSkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeSkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeSkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeSkill entities.
func (m *ResumeSkillMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeSkillMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeSkillMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeSkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeSkillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeSkillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeSkillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumeskill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeSkillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumeskill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeSkillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumeskill.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeSkillMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeSkillMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeSkillMutation) ResetResumeID() {
	m.resume = nil
}

// SetSkillName sets the "skill_name" field.
func (m *ResumeSkillMutation) SetSkillName(s string) {
	m.skill_name = &s
}

// SkillName returns the value of the "skill_name" field in the mutation.
func (m *ResumeSkillMutation) SkillName() (r string, exists bool) {
	v := m.skill_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillName returns the old "skill_name" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldSkillName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillName: %w", err)
	}
	return oldValue.SkillName, nil
}

// ClearSkillName clears the value of the "skill_name" field.
func (m *ResumeSkillMutation) ClearSkillName() {
	m.skill_name = nil
	m.clearedFields[resumeskill.FieldSkillName] = struct{}{}
}

// SkillNameCleared returns if the "skill_name" field was cleared in this mutation.
func (m *ResumeSkillMutation) SkillNameCleared() bool {
	_, ok := m.clearedFields[resumeskill.FieldSkillName]
	return ok
}

// ResetSkillName resets all changes to the "skill_name" field.
func (m *ResumeSkillMutation) ResetSkillName() {
	m.skill_name = nil
	delete(m.clearedFields, resumeskill.FieldSkillName)
}

// SetLevel sets the "level" field.
func (m *ResumeSkillMutation) SetLevel(s string) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *ResumeSkillMutation) Level() (r string, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ClearLevel clears the value of the "level" field.
func (m *ResumeSkillMutation) ClearLevel() {
	m.level = nil
	m.clearedFields[resumeskill.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *ResumeSkillMutation) LevelCleared() bool {
	_, ok := m.clearedFields[resumeskill.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *ResumeSkillMutation) ResetLevel() {
	m.level = nil
	delete(m.clearedFields, resumeskill.FieldLevel)
}

// SetDescription sets the "description" field.
func (m *ResumeSkillMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResumeSkillMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResumeSkillMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resumeskill.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResumeSkillMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resumeskill.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResumeSkillMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resumeskill.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeSkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeSkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeSkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeSkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeSkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeSkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeSkillMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumeskill.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeSkillMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeSkillMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeSkillMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeSkillMutation builder.
func (m *ResumeSkillMutation) Where(ps ...predicate.ResumeSkill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeSkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeSkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeSkill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeSkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeSkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeSkill).
func (m *ResumeSkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeSkillMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, resumeskill.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumeskill.FieldResumeID)
	}
	if m.skill_name != nil {
		fields = append(fields, resumeskill.FieldSkillName)
	}
	if m.level != nil {
		fields = append(fields, resumeskill.FieldLevel)
	}
	if m.description != nil {
		fields = append(fields, resumeskill.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, resumeskill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumeskill.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeSkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumeskill.FieldDeletedAt:
		return m.DeletedAt()
	case resumeskill.FieldResumeID:
		return m.ResumeID()
	case resumeskill.FieldSkillName:
		return m.SkillName()
	case resumeskill.FieldLevel:
		return m.Level()
	case resumeskill.FieldDescription:
		return m.Description()
	case resumeskill.FieldCreatedAt:
		return m.CreatedAt()
	case resumeskill.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeSkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumeskill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumeskill.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumeskill.FieldSkillName:
		return m.OldSkillName(ctx)
	case resumeskill.FieldLevel:
		return m.OldLevel(ctx)
	case resumeskill.FieldDescription:
		return m.OldDescription(ctx)
	case resumeskill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumeskill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeSkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeSkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumeskill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumeskill.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumeskill.FieldSkillName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillName(v)
		return nil
	case resumeskill.FieldLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case resumeskill.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resumeskill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumeskill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeSkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeSkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeSkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeSkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeSkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumeskill.FieldDeletedAt) {
		fields = append(fields, resumeskill.FieldDeletedAt)
	}
	if m.FieldCleared(resumeskill.FieldSkillName) {
		fields = append(fields, resumeskill.FieldSkillName)
	}
	if m.FieldCleared(resumeskill.FieldLevel) {
		fields = append(fields, resumeskill.FieldLevel)
	}
	if m.FieldCleared(resumeskill.FieldDescription) {
		fields = append(fields, resumeskill.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeSkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeSkillMutation) ClearField(name string) error {
	switch name {
	case resumeskill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumeskill.FieldSkillName:
		m.ClearSkillName()
		return nil
	case resumeskill.FieldLevel:
		m.ClearLevel()
		return nil
	case resumeskill.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeSkillMutation) ResetField(name string) error {
	switch name {
	case resumeskill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumeskill.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumeskill.FieldSkillName:
		m.ResetSkillName()
		return nil
	case resumeskill.FieldLevel:
		m.ResetLevel()
		return nil
	case resumeskill.FieldDescription:
		m.ResetDescription()
		return nil
	case resumeskill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumeskill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeSkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumeskill.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeSkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumeskill.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeSkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeSkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeSkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumeskill.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeSkillMutation) EdgeCleared(name string) bool {
	switch name {
	case resumeskill.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeSkillMutation) ClearEdge(name string) error {
	switch name {
	case resumeskill.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeSkillMutation) ResetEdge(name string) error {
	switch name {
	case resumeskill.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	name               *string
	description        *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	admins             map[uuid.UUID]struct{}
	removedadmins      map[uuid.UUID]struct{}
	clearedadmins      bool
	admin_roles        map[uuid.UUID]struct{}
	removedadmin_roles map[uuid.UUID]struct{}
	clearedadmin_roles bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddAdminIDs adds the "admins" edge to the Admin entity by ids.
func (m *RoleMutation) AddAdminIDs(ids ...uuid.UUID) {
	if m.admins == nil {
		m.admins = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.admins[ids[i]] = struct{}{}
	}
}

// ClearAdmins clears the "admins" edge to the Admin entity.
func (m *RoleMutation) ClearAdmins() {
	m.clearedadmins = true
}

// AdminsCleared reports if the "admins" edge to the Admin entity was cleared.
func (m *RoleMutation) AdminsCleared() bool {
	return m.clearedadmins
}

// RemoveAdminIDs removes the "admins" edge to the Admin entity by IDs.
func (m *RoleMutation) RemoveAdminIDs(ids ...uuid.UUID) {
	if m.removedadmins == nil {
		m.removedadmins = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.admins, ids[i])
		m.removedadmins[ids[i]] = struct{}{}
	}
}

// RemovedAdmins returns the removed IDs of the "admins" edge to the Admin entity.
func (m *RoleMutation) RemovedAdminsIDs() (ids []uuid.UUID) {
	for id := range m.removedadmins {
		ids = append(ids, id)
	}
	return
}

// AdminsIDs returns the "admins" edge IDs in the mutation.
func (m *RoleMutation) AdminsIDs() (ids []uuid.UUID) {
	for id := range m.admins {
		ids = append(ids, id)
	}
	return
}

// ResetAdmins resets all changes to the "admins" edge.
func (m *RoleMutation) ResetAdmins() {
	m.admins = nil
	m.clearedadmins = false
	m.removedadmins = nil
}

// AddAdminRoleIDs adds the "admin_roles" edge to the AdminRole entity by ids.
func (m *RoleMutation) AddAdminRoleIDs(ids ...uuid.UUID) {
	if m.admin_roles == nil {
		m.admin_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.admin_roles[ids[i]] = struct{}{}
	}
}

// ClearAdminRoles clears the "admin_roles" edge to the AdminRole entity.
func (m *RoleMutation) ClearAdminRoles() {
	m.clearedadmin_roles = true
}

// AdminRolesCleared reports if the "admin_roles" edge to the AdminRole entity was cleared.
func (m *RoleMutation) AdminRolesCleared() bool {
	return m.clearedadmin_roles
}

// RemoveAdminRoleIDs removes the "admin_roles" edge to the AdminRole entity by IDs.
func (m *RoleMutation) RemoveAdminRoleIDs(ids ...uuid.UUID) {
	if m.removedadmin_roles == nil {
		m.removedadmin_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.admin_roles, ids[i])
		m.removedadmin_roles[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoles returns the removed IDs of the "admin_roles" edge to the AdminRole entity.
func (m *RoleMutation) RemovedAdminRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedadmin_roles {
		ids = append(ids, id)
	}
	return
}

// AdminRolesIDs returns the "admin_roles" edge IDs in the mutation.
func (m *RoleMutation) AdminRolesIDs() (ids []uuid.UUID) {
	for id := range m.admin_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoles resets all changes to the "admin_roles" edge.
func (m *RoleMutation) ResetAdminRoles() {
	m.admin_roles = nil
	m.clearedadmin_roles = false
	m.removedadmin_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.admins != nil {
		edges = append(edges, role.EdgeAdmins)
	}
	if m.admin_roles != nil {
		edges = append(edges, role.EdgeAdminRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.admins))
		for id := range m.admins {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.admin_roles))
		for id := range m.admin_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedadmins != nil {
		edges = append(edges, role.EdgeAdmins)
	}
	if m.removedadmin_roles != nil {
		edges = append(edges, role.EdgeAdminRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.removedadmins))
		for id := range m.removedadmins {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.removedadmin_roles))
		for id := range m.removedadmin_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedadmins {
		edges = append(edges, role.EdgeAdmins)
	}
	if m.clearedadmin_roles {
		edges = append(edges, role.EdgeAdminRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeAdmins:
		return m.clearedadmins
	case role.EdgeAdminRoles:
		return m.clearedadmin_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeAdmins:
		m.ResetAdmins()
		return nil
	case role.EdgeAdminRoles:
		m.ResetAdminRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	enable_sso             *bool
	force_two_factor_auth  *bool
	disable_password_login *bool
	enable_auto_login      *bool
	dingtalk_oauth         **types.DingtalkOAuth
	custom_oauth           **types.CustomOAuth
	base_url               *string
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*Setting, error)
	predicates             []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uuid.UUID) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnableSSO sets the "enable_sso" field.
func (m *SettingMutation) SetEnableSSO(b bool) {
	m.enable_sso = &b
}

// EnableSSO returns the value of the "enable_sso" field in the mutation.
func (m *SettingMutation) EnableSSO() (r bool, exists bool) {
	v := m.enable_sso
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableSSO returns the old "enable_sso" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldEnableSSO(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableSSO is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableSSO requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableSSO: %w", err)
	}
	return oldValue.EnableSSO, nil
}

// ResetEnableSSO resets all changes to the "enable_sso" field.
func (m *SettingMutation) ResetEnableSSO() {
	m.enable_sso = nil
}

// SetForceTwoFactorAuth sets the "force_two_factor_auth" field.
func (m *SettingMutation) SetForceTwoFactorAuth(b bool) {
	m.force_two_factor_auth = &b
}

// ForceTwoFactorAuth returns the value of the "force_two_factor_auth" field in the mutation.
func (m *SettingMutation) ForceTwoFactorAuth() (r bool, exists bool) {
	v := m.force_two_factor_auth
	if v == nil {
		return
	}
	return *v, true
}

// OldForceTwoFactorAuth returns the old "force_two_factor_auth" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldForceTwoFactorAuth(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForceTwoFactorAuth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForceTwoFactorAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForceTwoFactorAuth: %w", err)
	}
	return oldValue.ForceTwoFactorAuth, nil
}

// ResetForceTwoFactorAuth resets all changes to the "force_two_factor_auth" field.
func (m *SettingMutation) ResetForceTwoFactorAuth() {
	m.force_two_factor_auth = nil
}

// SetDisablePasswordLogin sets the "disable_password_login" field.
func (m *SettingMutation) SetDisablePasswordLogin(b bool) {
	m.disable_password_login = &b
}

// DisablePasswordLogin returns the value of the "disable_password_login" field in the mutation.
func (m *SettingMutation) DisablePasswordLogin() (r bool, exists bool) {
	v := m.disable_password_login
	if v == nil {
		return
	}
	return *v, true
}

// OldDisablePasswordLogin returns the old "disable_password_login" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDisablePasswordLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisablePasswordLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisablePasswordLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisablePasswordLogin: %w", err)
	}
	return oldValue.DisablePasswordLogin, nil
}

// ResetDisablePasswordLogin resets all changes to the "disable_password_login" field.
func (m *SettingMutation) ResetDisablePasswordLogin() {
	m.disable_password_login = nil
}

// SetEnableAutoLogin sets the "enable_auto_login" field.
func (m *SettingMutation) SetEnableAutoLogin(b bool) {
	m.enable_auto_login = &b
}

// EnableAutoLogin returns the value of the "enable_auto_login" field in the mutation.
func (m *SettingMutation) EnableAutoLogin() (r bool, exists bool) {
	v := m.enable_auto_login
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableAutoLogin returns the old "enable_auto_login" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldEnableAutoLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableAutoLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableAutoLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableAutoLogin: %w", err)
	}
	return oldValue.EnableAutoLogin, nil
}

// ResetEnableAutoLogin resets all changes to the "enable_auto_login" field.
func (m *SettingMutation) ResetEnableAutoLogin() {
	m.enable_auto_login = nil
}

// SetDingtalkOauth sets the "dingtalk_oauth" field.
func (m *SettingMutation) SetDingtalkOauth(to *types.DingtalkOAuth) {
	m.dingtalk_oauth = &to
}

// DingtalkOauth returns the value of the "dingtalk_oauth" field in the mutation.
func (m *SettingMutation) DingtalkOauth() (r *types.DingtalkOAuth, exists bool) {
	v := m.dingtalk_oauth
	if v == nil {
		return
	}
	return *v, true
}

// OldDingtalkOauth returns the old "dingtalk_oauth" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDingtalkOauth(ctx context.Context) (v *types.DingtalkOAuth, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDingtalkOauth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDingtalkOauth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDingtalkOauth: %w", err)
	}
	return oldValue.DingtalkOauth, nil
}

// ClearDingtalkOauth clears the value of the "dingtalk_oauth" field.
func (m *SettingMutation) ClearDingtalkOauth() {
	m.dingtalk_oauth = nil
	m.clearedFields[setting.FieldDingtalkOauth] = struct{}{}
}

// DingtalkOauthCleared returns if the "dingtalk_oauth" field was cleared in this mutation.
func (m *SettingMutation) DingtalkOauthCleared() bool {
	_, ok := m.clearedFields[setting.FieldDingtalkOauth]
	return ok
}

// ResetDingtalkOauth resets all changes to the "dingtalk_oauth" field.
func (m *SettingMutation) ResetDingtalkOauth() {
	m.dingtalk_oauth = nil
	delete(m.clearedFields, setting.FieldDingtalkOauth)
}

// SetCustomOauth sets the "custom_oauth" field.
func (m *SettingMutation) SetCustomOauth(to *types.CustomOAuth) {
	m.custom_oauth = &to
}

// CustomOauth returns the value of the "custom_oauth" field in the mutation.
func (m *SettingMutation) CustomOauth() (r *types.CustomOAuth, exists bool) {
	v := m.custom_oauth
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomOauth returns the old "custom_oauth" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCustomOauth(ctx context.Context) (v *types.CustomOAuth, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomOauth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomOauth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomOauth: %w", err)
	}
	return oldValue.CustomOauth, nil
}

// ClearCustomOauth clears the value of the "custom_oauth" field.
func (m *SettingMutation) ClearCustomOauth() {
	m.custom_oauth = nil
	m.clearedFields[setting.FieldCustomOauth] = struct{}{}
}

// CustomOauthCleared returns if the "custom_oauth" field was cleared in this mutation.
func (m *SettingMutation) CustomOauthCleared() bool {
	_, ok := m.clearedFields[setting.FieldCustomOauth]
	return ok
}

// ResetCustomOauth resets all changes to the "custom_oauth" field.
func (m *SettingMutation) ResetCustomOauth() {
	m.custom_oauth = nil
	delete(m.clearedFields, setting.FieldCustomOauth)
}

// SetBaseURL sets the "base_url" field.
func (m *SettingMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *SettingMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldBaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ClearBaseURL clears the value of the "base_url" field.
func (m *SettingMutation) ClearBaseURL() {
	m.base_url = nil
	m.clearedFields[setting.FieldBaseURL] = struct{}{}
}

// BaseURLCleared returns if the "base_url" field was cleared in this mutation.
func (m *SettingMutation) BaseURLCleared() bool {
	_, ok := m.clearedFields[setting.FieldBaseURL]
	return ok
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *SettingMutation) ResetBaseURL() {
	m.base_url = nil
	delete(m.clearedFields, setting.FieldBaseURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.enable_sso != nil {
		fields = append(fields, setting.FieldEnableSSO)
	}
	if m.force_two_factor_auth != nil {
		fields = append(fields, setting.FieldForceTwoFactorAuth)
	}
	if m.disable_password_login != nil {
		fields = append(fields, setting.FieldDisablePasswordLogin)
	}
	if m.enable_auto_login != nil {
		fields = append(fields, setting.FieldEnableAutoLogin)
	}
	if m.dingtalk_oauth != nil {
		fields = append(fields, setting.FieldDingtalkOauth)
	}
	if m.custom_oauth != nil {
		fields = append(fields, setting.FieldCustomOauth)
	}
	if m.base_url != nil {
		fields = append(fields, setting.FieldBaseURL)
	}
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldEnableSSO:
		return m.EnableSSO()
	case setting.FieldForceTwoFactorAuth:
		return m.ForceTwoFactorAuth()
	case setting.FieldDisablePasswordLogin:
		return m.DisablePasswordLogin()
	case setting.FieldEnableAutoLogin:
		return m.EnableAutoLogin()
	case setting.FieldDingtalkOauth:
		return m.DingtalkOauth()
	case setting.FieldCustomOauth:
		return m.CustomOauth()
	case setting.FieldBaseURL:
		return m.BaseURL()
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldEnableSSO:
		return m.OldEnableSSO(ctx)
	case setting.FieldForceTwoFactorAuth:
		return m.OldForceTwoFactorAuth(ctx)
	case setting.FieldDisablePasswordLogin:
		return m.OldDisablePasswordLogin(ctx)
	case setting.FieldEnableAutoLogin:
		return m.OldEnableAutoLogin(ctx)
	case setting.FieldDingtalkOauth:
		return m.OldDingtalkOauth(ctx)
	case setting.FieldCustomOauth:
		return m.OldCustomOauth(ctx)
	case setting.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldEnableSSO:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableSSO(v)
		return nil
	case setting.FieldForceTwoFactorAuth:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForceTwoFactorAuth(v)
		return nil
	case setting.FieldDisablePasswordLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisablePasswordLogin(v)
		return nil
	case setting.FieldEnableAutoLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableAutoLogin(v)
		return nil
	case setting.FieldDingtalkOauth:
		v, ok := value.(*types.DingtalkOAuth)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDingtalkOauth(v)
		return nil
	case setting.FieldCustomOauth:
		v, ok := value.(*types.CustomOAuth)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomOauth(v)
		return nil
	case setting.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldDingtalkOauth) {
		fields = append(fields, setting.FieldDingtalkOauth)
	}
	if m.FieldCleared(setting.FieldCustomOauth) {
		fields = append(fields, setting.FieldCustomOauth)
	}
	if m.FieldCleared(setting.FieldBaseURL) {
		fields = append(fields, setting.FieldBaseURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldDingtalkOauth:
		m.ClearDingtalkOauth()
		return nil
	case setting.FieldCustomOauth:
		m.ClearCustomOauth()
		return nil
	case setting.FieldBaseURL:
		m.ClearBaseURL()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldEnableSSO:
		m.ResetEnableSSO()
		return nil
	case setting.FieldForceTwoFactorAuth:
		m.ResetForceTwoFactorAuth()
		return nil
	case setting.FieldDisablePasswordLogin:
		m.ResetDisablePasswordLogin()
		return nil
	case setting.FieldEnableAutoLogin:
		m.ResetEnableAutoLogin()
		return nil
	case setting.FieldDingtalkOauth:
		m.ResetDingtalkOauth()
		return nil
	case setting.FieldCustomOauth:
		m.ResetCustomOauth()
		return nil
	case setting.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	deleted_at             *time.Time
	username               *string
	password               *string
	email                  *string
	avatar_url             *string
	platform               *consts.UserPlatform
	status                 *consts.UserStatus
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	login_histories        map[uuid.UUID]struct{}
	removedlogin_histories map[uuid.UUID]struct{}
	clearedlogin_histories bool
	identities             map[uuid.UUID]struct{}
	removedidentities      map[uuid.UUID]struct{}
	clearedidentities      bool
	conversations          map[uuid.UUID]struct{}
	removedconversations   map[uuid.UUID]struct{}
	clearedconversations   bool
	resumes                map[uuid.UUID]struct{}
	removedresumes         map[uuid.UUID]struct{}
	clearedresumes         bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetPlatform sets the "platform" field.
func (m *UserMutation) SetPlatform(cp consts.UserPlatform) {
	m.platform = &cp
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserMutation) Platform() (r consts.UserPlatform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatform(ctx context.Context) (v consts.UserPlatform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserMutation) ResetPlatform() {
	m.platform = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(cs consts.UserStatus) {
	m.status = &cs
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r consts.UserStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v consts.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddLoginHistoryIDs adds the "login_histories" edge to the UserLoginHistory entity by ids.
func (m *UserMutation) AddLoginHistoryIDs(ids ...uuid.UUID) {
	if m.login_histories == nil {
		m.login_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.login_histories[ids[i]] = struct{}{}
	}
}

// ClearLoginHistories clears the "login_histories" edge to the UserLoginHistory entity.
func (m *UserMutation) ClearLoginHistories() {
	m.clearedlogin_histories = true
}

// LoginHistoriesCleared reports if the "login_histories" edge to the UserLoginHistory entity was cleared.
func (m *UserMutation) LoginHistoriesCleared() bool {
	return m.clearedlogin_histories
}

// RemoveLoginHistoryIDs removes the "login_histories" edge to the UserLoginHistory entity by IDs.
func (m *UserMutation) RemoveLoginHistoryIDs(ids ...uuid.UUID) {
	if m.removedlogin_histories == nil {
		m.removedlogin_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.login_histories, ids[i])
		m.removedlogin_histories[ids[i]] = struct{}{}
	}
}

// RemovedLoginHistories returns the removed IDs of the "login_histories" edge to the UserLoginHistory entity.
func (m *UserMutation) RemovedLoginHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedlogin_histories {
		ids = append(ids, id)
	}
	return
}

// LoginHistoriesIDs returns the "login_histories" edge IDs in the mutation.
func (m *UserMutation) LoginHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.login_histories {
		ids = append(ids, id)
	}
	return
}

// ResetLoginHistories resets all changes to the "login_histories" edge.
func (m *UserMutation) ResetLoginHistories() {
	m.login_histories = nil
	m.clearedlogin_histories = false
	m.removedlogin_histories = nil
}

// AddIdentityIDs adds the "identities" edge to the UserIdentity entity by ids.
func (m *UserMutation) AddIdentityIDs(ids ...uuid.UUID) {
	if m.identities == nil {
		m.identities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the UserIdentity entity.
func (m *UserMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the UserIdentity entity was cleared.
func (m *UserMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the UserIdentity entity by IDs.
func (m *UserMutation) RemoveIdentityIDs(ids ...uuid.UUID) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the UserIdentity entity.
func (m *UserMutation) RemovedIdentitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *UserMutation) IdentitiesIDs() (ids []uuid.UUID) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *UserMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// AddConversationIDs adds the "conversations" edge to the Conversation entity by ids.
func (m *UserMutation) AddConversationIDs(ids ...uuid.UUID) {
	if m.conversations == nil {
		m.conversations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.conversations[ids[i]] = struct{}{}
	}
}

// ClearConversations clears the "conversations" edge to the Conversation entity.
func (m *UserMutation) ClearConversations() {
	m.clearedconversations = true
}

// ConversationsCleared reports if the "conversations" edge to the Conversation entity was cleared.
func (m *UserMutation) ConversationsCleared() bool {
	return m.clearedconversations
}

// RemoveConversationIDs removes the "conversations" edge to the Conversation entity by IDs.
func (m *UserMutation) RemoveConversationIDs(ids ...uuid.UUID) {
	if m.removedconversations == nil {
		m.removedconversations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.conversations, ids[i])
		m.removedconversations[ids[i]] = struct{}{}
	}
}

// RemovedConversations returns the removed IDs of the "conversations" edge to the Conversation entity.
func (m *UserMutation) RemovedConversationsIDs() (ids []uuid.UUID) {
	for id := range m.removedconversations {
		ids = append(ids, id)
	}
	return
}

// ConversationsIDs returns the "conversations" edge IDs in the mutation.
func (m *UserMutation) ConversationsIDs() (ids []uuid.UUID) {
	for id := range m.conversations {
		ids = append(ids, id)
	}
	return
}

// ResetConversations resets all changes to the "conversations" edge.
func (m *UserMutation) ResetConversations() {
	m.conversations = nil
	m.clearedconversations = false
	m.removedconversations = nil
}

// AddResumeIDs adds the "resumes" edge to the Resume entity by ids.
func (m *UserMutation) AddResumeIDs(ids ...uuid.UUID) {
	if m.resumes == nil {
		m.resumes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.resumes[ids[i]] = struct{}{}
	}
}

// ClearResumes clears the "resumes" edge to the Resume entity.
func (m *UserMutation) ClearResumes() {
	m.clearedresumes = true
}

// ResumesCleared reports if the "resumes" edge to the Resume entity was cleared.
func (m *UserMutation) ResumesCleared() bool {
	return m.clearedresumes
}

// RemoveResumeIDs removes the "resumes" edge to the Resume entity by IDs.
func (m *UserMutation) RemoveResumeIDs(ids ...uuid.UUID) {
	if m.removedresumes == nil {
		m.removedresumes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.resumes, ids[i])
		m.removedresumes[ids[i]] = struct{}{}
	}
}

// RemovedResumes returns the removed IDs of the "resumes" edge to the Resume entity.
func (m *UserMutation) RemovedResumesIDs() (ids []uuid.UUID) {
	for id := range m.removedresumes {
		ids = append(ids, id)
	}
	return
}

// ResumesIDs returns the "resumes" edge IDs in the mutation.
func (m *UserMutation) ResumesIDs() (ids []uuid.UUID) {
	for id := range m.resumes {
		ids = append(ids, id)
	}
	return
}

// ResetResumes resets all changes to the "resumes" edge.
func (m *UserMutation) ResetResumes() {
	m.resumes = nil
	m.clearedresumes = false
	m.removedresumes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.platform != nil {
		fields = append(fields, user.FieldPlatform)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldPlatform:
		return m.Platform()
	case user.FieldStatus:
		return m.Status()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldPlatform:
		return m.OldPlatform(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldPlatform:
		v, ok := value.(consts.UserPlatform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(consts.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldPlatform:
		m.ResetPlatform()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.login_histories != nil {
		edges = append(edges, user.EdgeLoginHistories)
	}
	if m.identities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.conversations != nil {
		edges = append(edges, user.EdgeConversations)
	}
	if m.resumes != nil {
		edges = append(edges, user.EdgeResumes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeLoginHistories:
		ids := make([]ent.Value, 0, len(m.login_histories))
		for id := range m.login_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConversations:
		ids := make([]ent.Value, 0, len(m.conversations))
		for id := range m.conversations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.resumes))
		for id := range m.resumes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedlogin_histories != nil {
		edges = append(edges, user.EdgeLoginHistories)
	}
	if m.removedidentities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.removedconversations != nil {
		edges = append(edges, user.EdgeConversations)
	}
	if m.removedresumes != nil {
		edges = append(edges, user.EdgeResumes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeLoginHistories:
		ids := make([]ent.Value, 0, len(m.removedlogin_histories))
		for id := range m.removedlogin_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConversations:
		ids := make([]ent.Value, 0, len(m.removedconversations))
		for id := range m.removedconversations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.removedresumes))
		for id := range m.removedresumes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedlogin_histories {
		edges = append(edges, user.EdgeLoginHistories)
	}
	if m.clearedidentities {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.clearedconversations {
		edges = append(edges, user.EdgeConversations)
	}
	if m.clearedresumes {
		edges = append(edges, user.EdgeResumes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeLoginHistories:
		return m.clearedlogin_histories
	case user.EdgeIdentities:
		return m.clearedidentities
	case user.EdgeConversations:
		return m.clearedconversations
	case user.EdgeResumes:
		return m.clearedresumes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeLoginHistories:
		m.ResetLoginHistories()
		return nil
	case user.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case user.EdgeConversations:
		m.ResetConversations()
		return nil
	case user.EdgeResumes:
		m.ResetResumes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserIdentityMutation represents an operation that mutates the UserIdentity nodes in the graph.
type UserIdentityMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	platform      *consts.UserPlatform
	identity_id   *string
	union_id      *string
	nickname      *string
	email         *string
	avatar_url    *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserIdentity, error)
	predicates    []predicate.UserIdentity
}

var _ ent.Mutation = (*UserIdentityMutation)(nil)

// useridentityOption allows management of the mutation configuration using functional options.
type useridentityOption func(*UserIdentityMutation)

// newUserIdentityMutation creates new mutation for the UserIdentity entity.
func newUserIdentityMutation(c config, op Op, opts ...useridentityOption) *UserIdentityMutation {
	m := &UserIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserIdentityID sets the ID field of the mutation.
func withUserIdentityID(id uuid.UUID) useridentityOption {
	return func(m *UserIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserIdentity
		)
		m.oldValue = func(ctx context.Context) (*UserIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserIdentity sets the old UserIdentity of the mutation.
func withUserIdentity(node *UserIdentity) useridentityOption {
	return func(m *UserIdentityMutation) {
		m.oldValue = func(context.Context) (*UserIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserIdentity entities.
func (m *UserIdentityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserIdentityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserIdentityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserIdentityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserIdentityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserIdentityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[useridentity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserIdentityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserIdentityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, useridentity.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserIdentityMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserIdentityMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserIdentityMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserIdentityMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserIdentityMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, useridentity.FieldUserID)
}

// SetPlatform sets the "platform" field.
func (m *UserIdentityMutation) SetPlatform(cp consts.UserPlatform) {
	m.platform = &cp
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserIdentityMutation) Platform() (r consts.UserPlatform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldPlatform(ctx context.Context) (v consts.UserPlatform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserIdentityMutation) ResetPlatform() {
	m.platform = nil
}

// SetIdentityID sets the "identity_id" field.
func (m *UserIdentityMutation) SetIdentityID(s string) {
	m.identity_id = &s
}

// IdentityID returns the value of the "identity_id" field in the mutation.
func (m *UserIdentityMutation) IdentityID() (r string, exists bool) {
	v := m.identity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityID returns the old "identity_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldIdentityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityID: %w", err)
	}
	return oldValue.IdentityID, nil
}

// ResetIdentityID resets all changes to the "identity_id" field.
func (m *UserIdentityMutation) ResetIdentityID() {
	m.identity_id = nil
}

// SetUnionID sets the "union_id" field.
func (m *UserIdentityMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *UserIdentityMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ClearUnionID clears the value of the "union_id" field.
func (m *UserIdentityMutation) ClearUnionID() {
	m.union_id = nil
	m.clearedFields[useridentity.FieldUnionID] = struct{}{}
}

// UnionIDCleared returns if the "union_id" field was cleared in this mutation.
func (m *UserIdentityMutation) UnionIDCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUnionID]
	return ok
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *UserIdentityMutation) ResetUnionID() {
	m.union_id = nil
	delete(m.clearedFields, useridentity.FieldUnionID)
}

// SetNickname sets the "nickname" field.
func (m *UserIdentityMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserIdentityMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserIdentityMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[useridentity.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserIdentityMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserIdentityMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, useridentity.FieldNickname)
}

// SetEmail sets the "email" field.
func (m *UserIdentityMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserIdentityMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserIdentityMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[useridentity.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserIdentityMutation) EmailCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserIdentityMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, useridentity.FieldEmail)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserIdentityMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserIdentityMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserIdentityMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[useridentity.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserIdentityMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserIdentityMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, useridentity.FieldAvatarURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserIdentityMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserIdentityMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserIdentityMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserIdentityMutation builder.
func (m *UserIdentityMutation) Where(ps ...predicate.UserIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserIdentity).
func (m *UserIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserIdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, useridentity.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.platform != nil {
		fields = append(fields, useridentity.FieldPlatform)
	}
	if m.identity_id != nil {
		fields = append(fields, useridentity.FieldIdentityID)
	}
	if m.union_id != nil {
		fields = append(fields, useridentity.FieldUnionID)
	}
	if m.nickname != nil {
		fields = append(fields, useridentity.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, useridentity.FieldEmail)
	}
	if m.avatar_url != nil {
		fields = append(fields, useridentity.FieldAvatarURL)
	}
	if m.created_at != nil {
		fields = append(fields, useridentity.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldDeletedAt:
		return m.DeletedAt()
	case useridentity.FieldUserID:
		return m.UserID()
	case useridentity.FieldPlatform:
		return m.Platform()
	case useridentity.FieldIdentityID:
		return m.IdentityID()
	case useridentity.FieldUnionID:
		return m.UnionID()
	case useridentity.FieldNickname:
		return m.Nickname()
	case useridentity.FieldEmail:
		return m.Email()
	case useridentity.FieldAvatarURL:
		return m.AvatarURL()
	case useridentity.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useridentity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case useridentity.FieldUserID:
		return m.OldUserID(ctx)
	case useridentity.FieldPlatform:
		return m.OldPlatform(ctx)
	case useridentity.FieldIdentityID:
		return m.OldIdentityID(ctx)
	case useridentity.FieldUnionID:
		return m.OldUnionID(ctx)
	case useridentity.FieldNickname:
		return m.OldNickname(ctx)
	case useridentity.FieldEmail:
		return m.OldEmail(ctx)
	case useridentity.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case useridentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case useridentity.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useridentity.FieldPlatform:
		v, ok := value.(consts.UserPlatform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case useridentity.FieldIdentityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityID(v)
		return nil
	case useridentity.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case useridentity.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case useridentity.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case useridentity.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case useridentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserIdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserIdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useridentity.FieldDeletedAt) {
		fields = append(fields, useridentity.FieldDeletedAt)
	}
	if m.FieldCleared(useridentity.FieldUserID) {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.FieldCleared(useridentity.FieldUnionID) {
		fields = append(fields, useridentity.FieldUnionID)
	}
	if m.FieldCleared(useridentity.FieldNickname) {
		fields = append(fields, useridentity.FieldNickname)
	}
	if m.FieldCleared(useridentity.FieldEmail) {
		fields = append(fields, useridentity.FieldEmail)
	}
	if m.FieldCleared(useridentity.FieldAvatarURL) {
		fields = append(fields, useridentity.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserIdentityMutation) ClearField(name string) error {
	switch name {
	case useridentity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case useridentity.FieldUserID:
		m.ClearUserID()
		return nil
	case useridentity.FieldUnionID:
		m.ClearUnionID()
		return nil
	case useridentity.FieldNickname:
		m.ClearNickname()
		return nil
	case useridentity.FieldEmail:
		m.ClearEmail()
		return nil
	case useridentity.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserIdentityMutation) ResetField(name string) error {
	switch name {
	case useridentity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case useridentity.FieldUserID:
		m.ResetUserID()
		return nil
	case useridentity.FieldPlatform:
		m.ResetPlatform()
		return nil
	case useridentity.FieldIdentityID:
		m.ResetIdentityID()
		return nil
	case useridentity.FieldUnionID:
		m.ResetUnionID()
		return nil
	case useridentity.FieldNickname:
		m.ResetNickname()
		return nil
	case useridentity.FieldEmail:
		m.ResetEmail()
		return nil
	case useridentity.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case useridentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useridentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserIdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case useridentity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserIdentityMutation) ClearEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserIdentityMutation) ResetEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity edge %s", name)
}

// UserLoginHistoryMutation represents an operation that mutates the UserLoginHistory nodes in the graph.
type UserLoginHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	ip             *string
	country        *string
	province       *string
	city           *string
	isp            *string
	asn            *string
	client_version *string
	os_type        *consts.OSType
	os_release     *consts.OSRelease
	hostname       *string
	client_id      *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	owner          *uuid.UUID
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*UserLoginHistory, error)
	predicates     []predicate.UserLoginHistory
}

var _ ent.Mutation = (*UserLoginHistoryMutation)(nil)

// userloginhistoryOption allows management of the mutation configuration using functional options.
type userloginhistoryOption func(*UserLoginHistoryMutation)

// newUserLoginHistoryMutation creates new mutation for the UserLoginHistory entity.
func newUserLoginHistoryMutation(c config, op Op, opts ...userloginhistoryOption) *UserLoginHistoryMutation {
	m := &UserLoginHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginHistoryID sets the ID field of the mutation.
func withUserLoginHistoryID(id uuid.UUID) userloginhistoryOption {
	return func(m *UserLoginHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginHistory
		)
		m.oldValue = func(ctx context.Context) (*UserLoginHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginHistory sets the old UserLoginHistory of the mutation.
func withUserLoginHistory(node *UserLoginHistory) userloginhistoryOption {
	return func(m *UserLoginHistoryMutation) {
		m.oldValue = func(context.Context) (*UserLoginHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLoginHistory entities.
func (m *UserLoginHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLoginHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLoginHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLoginHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserLoginHistoryMutation) SetUserID(u uuid.UUID) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLoginHistoryMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserLoginHistoryMutation) ClearUserID() {
	m.owner = nil
	m.clearedFields[userloginhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLoginHistoryMutation) ResetUserID() {
	m.owner = nil
	delete(m.clearedFields, userloginhistory.FieldUserID)
}

// SetIP sets the "ip" field.
func (m *UserLoginHistoryMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *UserLoginHistoryMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *UserLoginHistoryMutation) ResetIP() {
	m.ip = nil
}

// SetCountry sets the "country" field.
func (m *UserLoginHistoryMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserLoginHistoryMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *UserLoginHistoryMutation) ResetCountry() {
	m.country = nil
}

// SetProvince sets the "province" field.
func (m *UserLoginHistoryMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *UserLoginHistoryMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *UserLoginHistoryMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *UserLoginHistoryMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserLoginHistoryMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UserLoginHistoryMutation) ResetCity() {
	m.city = nil
}

// SetIsp sets the "isp" field.
func (m *UserLoginHistoryMutation) SetIsp(s string) {
	m.isp = &s
}

// Isp returns the value of the "isp" field in the mutation.
func (m *UserLoginHistoryMutation) Isp() (r string, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIsp returns the old "isp" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldIsp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsp: %w", err)
	}
	return oldValue.Isp, nil
}

// ClearIsp clears the value of the "isp" field.
func (m *UserLoginHistoryMutation) ClearIsp() {
	m.isp = nil
	m.clearedFields[userloginhistory.FieldIsp] = struct{}{}
}

// IspCleared returns if the "isp" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) IspCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldIsp]
	return ok
}

// ResetIsp resets all changes to the "isp" field.
func (m *UserLoginHistoryMutation) ResetIsp() {
	m.isp = nil
	delete(m.clearedFields, userloginhistory.FieldIsp)
}

// SetAsn sets the "asn" field.
func (m *UserLoginHistoryMutation) SetAsn(s string) {
	m.asn = &s
}

// Asn returns the value of the "asn" field in the mutation.
func (m *UserLoginHistoryMutation) Asn() (r string, exists bool) {
	v := m.asn
	if v == nil {
		return
	}
	return *v, true
}

// OldAsn returns the old "asn" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldAsn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAsn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAsn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAsn: %w", err)
	}
	return oldValue.Asn, nil
}

// ClearAsn clears the value of the "asn" field.
func (m *UserLoginHistoryMutation) ClearAsn() {
	m.asn = nil
	m.clearedFields[userloginhistory.FieldAsn] = struct{}{}
}

// AsnCleared returns if the "asn" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) AsnCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldAsn]
	return ok
}

// ResetAsn resets all changes to the "asn" field.
func (m *UserLoginHistoryMutation) ResetAsn() {
	m.asn = nil
	delete(m.clearedFields, userloginhistory.FieldAsn)
}

// SetClientVersion sets the "client_version" field.
func (m *UserLoginHistoryMutation) SetClientVersion(s string) {
	m.client_version = &s
}

// ClientVersion returns the value of the "client_version" field in the mutation.
func (m *UserLoginHistoryMutation) ClientVersion() (r string, exists bool) {
	v := m.client_version
	if v == nil {
		return
	}
	return *v, true
}

// OldClientVersion returns the old "client_version" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldClientVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientVersion: %w", err)
	}
	return oldValue.ClientVersion, nil
}

// ClearClientVersion clears the value of the "client_version" field.
func (m *UserLoginHistoryMutation) ClearClientVersion() {
	m.client_version = nil
	m.clearedFields[userloginhistory.FieldClientVersion] = struct{}{}
}

// ClientVersionCleared returns if the "client_version" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) ClientVersionCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldClientVersion]
	return ok
}

// ResetClientVersion resets all changes to the "client_version" field.
func (m *UserLoginHistoryMutation) ResetClientVersion() {
	m.client_version = nil
	delete(m.clearedFields, userloginhistory.FieldClientVersion)
}

// SetOsType sets the "os_type" field.
func (m *UserLoginHistoryMutation) SetOsType(ct consts.OSType) {
	m.os_type = &ct
}

// OsType returns the value of the "os_type" field in the mutation.
func (m *UserLoginHistoryMutation) OsType() (r consts.OSType, exists bool) {
	v := m.os_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOsType returns the old "os_type" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldOsType(ctx context.Context) (v consts.OSType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsType: %w", err)
	}
	return oldValue.OsType, nil
}

// ClearOsType clears the value of the "os_type" field.
func (m *UserLoginHistoryMutation) ClearOsType() {
	m.os_type = nil
	m.clearedFields[userloginhistory.FieldOsType] = struct{}{}
}

// OsTypeCleared returns if the "os_type" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) OsTypeCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldOsType]
	return ok
}

// ResetOsType resets all changes to the "os_type" field.
func (m *UserLoginHistoryMutation) ResetOsType() {
	m.os_type = nil
	delete(m.clearedFields, userloginhistory.FieldOsType)
}

// SetOsRelease sets the "os_release" field.
func (m *UserLoginHistoryMutation) SetOsRelease(cr consts.OSRelease) {
	m.os_release = &cr
}

// OsRelease returns the value of the "os_release" field in the mutation.
func (m *UserLoginHistoryMutation) OsRelease() (r consts.OSRelease, exists bool) {
	v := m.os_release
	if v == nil {
		return
	}
	return *v, true
}

// OldOsRelease returns the old "os_release" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldOsRelease(ctx context.Context) (v consts.OSRelease, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsRelease is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsRelease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsRelease: %w", err)
	}
	return oldValue.OsRelease, nil
}

// ClearOsRelease clears the value of the "os_release" field.
func (m *UserLoginHistoryMutation) ClearOsRelease() {
	m.os_release = nil
	m.clearedFields[userloginhistory.FieldOsRelease] = struct{}{}
}

// OsReleaseCleared returns if the "os_release" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) OsReleaseCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldOsRelease]
	return ok
}

// ResetOsRelease resets all changes to the "os_release" field.
func (m *UserLoginHistoryMutation) ResetOsRelease() {
	m.os_release = nil
	delete(m.clearedFields, userloginhistory.FieldOsRelease)
}

// SetHostname sets the "hostname" field.
func (m *UserLoginHistoryMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *UserLoginHistoryMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *UserLoginHistoryMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[userloginhistory.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *UserLoginHistoryMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, userloginhistory.FieldHostname)
}

// SetClientID sets the "client_id" field.
func (m *UserLoginHistoryMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *UserLoginHistoryMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *UserLoginHistoryMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[userloginhistory.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *UserLoginHistoryMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, userloginhistory.FieldClientID)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *UserLoginHistoryMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *UserLoginHistoryMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[userloginhistory.FieldUserID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *UserLoginHistoryMutation) OwnerCleared() bool {
	return m.UserIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *UserLoginHistoryMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *UserLoginHistoryMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UserLoginHistoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the UserLoginHistoryMutation builder.
func (m *UserLoginHistoryMutation) Where(ps ...predicate.UserLoginHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLoginHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLoginHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLoginHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLoginHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLoginHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLoginHistory).
func (m *UserLoginHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.owner != nil {
		fields = append(fields, userloginhistory.FieldUserID)
	}
	if m.ip != nil {
		fields = append(fields, userloginhistory.FieldIP)
	}
	if m.country != nil {
		fields = append(fields, userloginhistory.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, userloginhistory.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, userloginhistory.FieldCity)
	}
	if m.isp != nil {
		fields = append(fields, userloginhistory.FieldIsp)
	}
	if m.asn != nil {
		fields = append(fields, userloginhistory.FieldAsn)
	}
	if m.client_version != nil {
		fields = append(fields, userloginhistory.FieldClientVersion)
	}
	if m.os_type != nil {
		fields = append(fields, userloginhistory.FieldOsType)
	}
	if m.os_release != nil {
		fields = append(fields, userloginhistory.FieldOsRelease)
	}
	if m.hostname != nil {
		fields = append(fields, userloginhistory.FieldHostname)
	}
	if m.client_id != nil {
		fields = append(fields, userloginhistory.FieldClientID)
	}
	if m.created_at != nil {
		fields = append(fields, userloginhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginhistory.FieldUserID:
		return m.UserID()
	case userloginhistory.FieldIP:
		return m.IP()
	case userloginhistory.FieldCountry:
		return m.Country()
	case userloginhistory.FieldProvince:
		return m.Province()
	case userloginhistory.FieldCity:
		return m.City()
	case userloginhistory.FieldIsp:
		return m.Isp()
	case userloginhistory.FieldAsn:
		return m.Asn()
	case userloginhistory.FieldClientVersion:
		return m.ClientVersion()
	case userloginhistory.FieldOsType:
		return m.OsType()
	case userloginhistory.FieldOsRelease:
		return m.OsRelease()
	case userloginhistory.FieldHostname:
		return m.Hostname()
	case userloginhistory.FieldClientID:
		return m.ClientID()
	case userloginhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginhistory.FieldUserID:
		return m.OldUserID(ctx)
	case userloginhistory.FieldIP:
		return m.OldIP(ctx)
	case userloginhistory.FieldCountry:
		return m.OldCountry(ctx)
	case userloginhistory.FieldProvince:
		return m.OldProvince(ctx)
	case userloginhistory.FieldCity:
		return m.OldCity(ctx)
	case userloginhistory.FieldIsp:
		return m.OldIsp(ctx)
	case userloginhistory.FieldAsn:
		return m.OldAsn(ctx)
	case userloginhistory.FieldClientVersion:
		return m.OldClientVersion(ctx)
	case userloginhistory.FieldOsType:
		return m.OldOsType(ctx)
	case userloginhistory.FieldOsRelease:
		return m.OldOsRelease(ctx)
	case userloginhistory.FieldHostname:
		return m.OldHostname(ctx)
	case userloginhistory.FieldClientID:
		return m.OldClientID(ctx)
	case userloginhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginhistory.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userloginhistory.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case userloginhistory.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case userloginhistory.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case userloginhistory.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case userloginhistory.FieldIsp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsp(v)
		return nil
	case userloginhistory.FieldAsn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAsn(v)
		return nil
	case userloginhistory.FieldClientVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientVersion(v)
		return nil
	case userloginhistory.FieldOsType:
		v, ok := value.(consts.OSType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsType(v)
		return nil
	case userloginhistory.FieldOsRelease:
		v, ok := value.(consts.OSRelease)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsRelease(v)
		return nil
	case userloginhistory.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case userloginhistory.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case userloginhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLoginHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginhistory.FieldUserID) {
		fields = append(fields, userloginhistory.FieldUserID)
	}
	if m.FieldCleared(userloginhistory.FieldIsp) {
		fields = append(fields, userloginhistory.FieldIsp)
	}
	if m.FieldCleared(userloginhistory.FieldAsn) {
		fields = append(fields, userloginhistory.FieldAsn)
	}
	if m.FieldCleared(userloginhistory.FieldClientVersion) {
		fields = append(fields, userloginhistory.FieldClientVersion)
	}
	if m.FieldCleared(userloginhistory.FieldOsType) {
		fields = append(fields, userloginhistory.FieldOsType)
	}
	if m.FieldCleared(userloginhistory.FieldOsRelease) {
		fields = append(fields, userloginhistory.FieldOsRelease)
	}
	if m.FieldCleared(userloginhistory.FieldHostname) {
		fields = append(fields, userloginhistory.FieldHostname)
	}
	if m.FieldCleared(userloginhistory.FieldClientID) {
		fields = append(fields, userloginhistory.FieldClientID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginHistoryMutation) ClearField(name string) error {
	switch name {
	case userloginhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case userloginhistory.FieldIsp:
		m.ClearIsp()
		return nil
	case userloginhistory.FieldAsn:
		m.ClearAsn()
		return nil
	case userloginhistory.FieldClientVersion:
		m.ClearClientVersion()
		return nil
	case userloginhistory.FieldOsType:
		m.ClearOsType()
		return nil
	case userloginhistory.FieldOsRelease:
		m.ClearOsRelease()
		return nil
	case userloginhistory.FieldHostname:
		m.ClearHostname()
		return nil
	case userloginhistory.FieldClientID:
		m.ClearClientID()
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginHistoryMutation) ResetField(name string) error {
	switch name {
	case userloginhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case userloginhistory.FieldIP:
		m.ResetIP()
		return nil
	case userloginhistory.FieldCountry:
		m.ResetCountry()
		return nil
	case userloginhistory.FieldProvince:
		m.ResetProvince()
		return nil
	case userloginhistory.FieldCity:
		m.ResetCity()
		return nil
	case userloginhistory.FieldIsp:
		m.ResetIsp()
		return nil
	case userloginhistory.FieldAsn:
		m.ResetAsn()
		return nil
	case userloginhistory.FieldClientVersion:
		m.ResetClientVersion()
		return nil
	case userloginhistory.FieldOsType:
		m.ResetOsType()
		return nil
	case userloginhistory.FieldOsRelease:
		m.ResetOsRelease()
		return nil
	case userloginhistory.FieldHostname:
		m.ResetHostname()
		return nil
	case userloginhistory.FieldClientID:
		m.ResetClientID()
		return nil
	case userloginhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, userloginhistory.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userloginhistory.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, userloginhistory.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case userloginhistory.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginHistoryMutation) ClearEdge(name string) error {
	switch name {
	case userloginhistory.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginHistoryMutation) ResetEdge(name string) error {
	switch name {
	case userloginhistory.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory edge %s", name)
}
