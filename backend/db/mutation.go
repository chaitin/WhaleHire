// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/chaitin/WhaleHire/backend/consts"
	"github.com/chaitin/WhaleHire/backend/db/admin"
	"github.com/chaitin/WhaleHire/backend/db/adminloginhistory"
	"github.com/chaitin/WhaleHire/backend/db/adminrole"
	"github.com/chaitin/WhaleHire/backend/db/attachment"
	"github.com/chaitin/WhaleHire/backend/db/auditlog"
	"github.com/chaitin/WhaleHire/backend/db/conversation"
	"github.com/chaitin/WhaleHire/backend/db/department"
	"github.com/chaitin/WhaleHire/backend/db/jobeducationrequirement"
	"github.com/chaitin/WhaleHire/backend/db/jobexperiencerequirement"
	"github.com/chaitin/WhaleHire/backend/db/jobindustryrequirement"
	"github.com/chaitin/WhaleHire/backend/db/jobposition"
	"github.com/chaitin/WhaleHire/backend/db/jobresponsibility"
	"github.com/chaitin/WhaleHire/backend/db/jobskill"
	"github.com/chaitin/WhaleHire/backend/db/jobskillmeta"
	"github.com/chaitin/WhaleHire/backend/db/message"
	"github.com/chaitin/WhaleHire/backend/db/notificationevent"
	"github.com/chaitin/WhaleHire/backend/db/notificationsetting"
	"github.com/chaitin/WhaleHire/backend/db/predicate"
	"github.com/chaitin/WhaleHire/backend/db/resume"
	"github.com/chaitin/WhaleHire/backend/db/resumedocumentparse"
	"github.com/chaitin/WhaleHire/backend/db/resumeeducation"
	"github.com/chaitin/WhaleHire/backend/db/resumeexperience"
	"github.com/chaitin/WhaleHire/backend/db/resumejobapplication"
	"github.com/chaitin/WhaleHire/backend/db/resumelog"
	"github.com/chaitin/WhaleHire/backend/db/resumeproject"
	"github.com/chaitin/WhaleHire/backend/db/resumeskill"
	"github.com/chaitin/WhaleHire/backend/db/role"
	"github.com/chaitin/WhaleHire/backend/db/screeningnoderun"
	"github.com/chaitin/WhaleHire/backend/db/screeningresult"
	"github.com/chaitin/WhaleHire/backend/db/screeningrunmetric"
	"github.com/chaitin/WhaleHire/backend/db/screeningtask"
	"github.com/chaitin/WhaleHire/backend/db/screeningtaskresume"
	"github.com/chaitin/WhaleHire/backend/db/setting"
	"github.com/chaitin/WhaleHire/backend/db/user"
	"github.com/chaitin/WhaleHire/backend/db/useridentity"
	"github.com/chaitin/WhaleHire/backend/db/userloginhistory"
	"github.com/chaitin/WhaleHire/backend/ent/types"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin                    = "Admin"
	TypeAdminLoginHistory        = "AdminLoginHistory"
	TypeAdminRole                = "AdminRole"
	TypeAttachment               = "Attachment"
	TypeAuditLog                 = "AuditLog"
	TypeConversation             = "Conversation"
	TypeDepartment               = "Department"
	TypeJobEducationRequirement  = "JobEducationRequirement"
	TypeJobExperienceRequirement = "JobExperienceRequirement"
	TypeJobIndustryRequirement   = "JobIndustryRequirement"
	TypeJobPosition              = "JobPosition"
	TypeJobResponsibility        = "JobResponsibility"
	TypeJobSkill                 = "JobSkill"
	TypeJobSkillMeta             = "JobSkillMeta"
	TypeMessage                  = "Message"
	TypeNotificationEvent        = "NotificationEvent"
	TypeNotificationSetting      = "NotificationSetting"
	TypeResume                   = "Resume"
	TypeResumeDocumentParse      = "ResumeDocumentParse"
	TypeResumeEducation          = "ResumeEducation"
	TypeResumeExperience         = "ResumeExperience"
	TypeResumeJobApplication     = "ResumeJobApplication"
	TypeResumeLog                = "ResumeLog"
	TypeResumeProject            = "ResumeProject"
	TypeResumeSkill              = "ResumeSkill"
	TypeRole                     = "Role"
	TypeScreeningNodeRun         = "ScreeningNodeRun"
	TypeScreeningResult          = "ScreeningResult"
	TypeScreeningRunMetric       = "ScreeningRunMetric"
	TypeScreeningTask            = "ScreeningTask"
	TypeScreeningTaskResume      = "ScreeningTaskResume"
	TypeSetting                  = "Setting"
	TypeUser                     = "User"
	TypeUserIdentity             = "UserIdentity"
	TypeUserLoginHistory         = "UserLoginHistory"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	username               *string
	password               *string
	status                 *consts.AdminStatus
	last_active_at         *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	login_histories        map[uuid.UUID]struct{}
	removedlogin_histories map[uuid.UUID]struct{}
	clearedlogin_histories bool
	roles                  map[int64]struct{}
	removedroles           map[int64]struct{}
	clearedroles           bool
	admin_roles            map[uuid.UUID]struct{}
	removedadmin_roles     map[uuid.UUID]struct{}
	clearedadmin_roles     bool
	done                   bool
	oldValue               func(context.Context) (*Admin, error)
	predicates             []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id uuid.UUID) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Admin entities.
func (m *AdminMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// SetStatus sets the "status" field.
func (m *AdminMutation) SetStatus(cs consts.AdminStatus) {
	m.status = &cs
}

// Status returns the value of the "status" field in the mutation.
func (m *AdminMutation) Status() (r consts.AdminStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldStatus(ctx context.Context) (v consts.AdminStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AdminMutation) ResetStatus() {
	m.status = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *AdminMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *AdminMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldLastActiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *AdminMutation) ResetLastActiveAt() {
	m.last_active_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddLoginHistoryIDs adds the "login_histories" edge to the AdminLoginHistory entity by ids.
func (m *AdminMutation) AddLoginHistoryIDs(ids ...uuid.UUID) {
	if m.login_histories == nil {
		m.login_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.login_histories[ids[i]] = struct{}{}
	}
}

// ClearLoginHistories clears the "login_histories" edge to the AdminLoginHistory entity.
func (m *AdminMutation) ClearLoginHistories() {
	m.clearedlogin_histories = true
}

// LoginHistoriesCleared reports if the "login_histories" edge to the AdminLoginHistory entity was cleared.
func (m *AdminMutation) LoginHistoriesCleared() bool {
	return m.clearedlogin_histories
}

// RemoveLoginHistoryIDs removes the "login_histories" edge to the AdminLoginHistory entity by IDs.
func (m *AdminMutation) RemoveLoginHistoryIDs(ids ...uuid.UUID) {
	if m.removedlogin_histories == nil {
		m.removedlogin_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.login_histories, ids[i])
		m.removedlogin_histories[ids[i]] = struct{}{}
	}
}

// RemovedLoginHistories returns the removed IDs of the "login_histories" edge to the AdminLoginHistory entity.
func (m *AdminMutation) RemovedLoginHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedlogin_histories {
		ids = append(ids, id)
	}
	return
}

// LoginHistoriesIDs returns the "login_histories" edge IDs in the mutation.
func (m *AdminMutation) LoginHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.login_histories {
		ids = append(ids, id)
	}
	return
}

// ResetLoginHistories resets all changes to the "login_histories" edge.
func (m *AdminMutation) ResetLoginHistories() {
	m.login_histories = nil
	m.clearedlogin_histories = false
	m.removedlogin_histories = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *AdminMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *AdminMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *AdminMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *AdminMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *AdminMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AdminMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AdminMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddAdminRoleIDs adds the "admin_roles" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleIDs(ids ...uuid.UUID) {
	if m.admin_roles == nil {
		m.admin_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.admin_roles[ids[i]] = struct{}{}
	}
}

// ClearAdminRoles clears the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoles() {
	m.clearedadmin_roles = true
}

// AdminRolesCleared reports if the "admin_roles" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRolesCleared() bool {
	return m.clearedadmin_roles
}

// RemoveAdminRoleIDs removes the "admin_roles" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleIDs(ids ...uuid.UUID) {
	if m.removedadmin_roles == nil {
		m.removedadmin_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.admin_roles, ids[i])
		m.removedadmin_roles[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoles returns the removed IDs of the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedadmin_roles {
		ids = append(ids, id)
	}
	return
}

// AdminRolesIDs returns the "admin_roles" edge IDs in the mutation.
func (m *AdminMutation) AdminRolesIDs() (ids []uuid.UUID) {
	for id := range m.admin_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoles resets all changes to the "admin_roles" edge.
func (m *AdminMutation) ResetAdminRoles() {
	m.admin_roles = nil
	m.clearedadmin_roles = false
	m.removedadmin_roles = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Admin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, admin.FieldStatus)
	}
	if m.last_active_at != nil {
		fields = append(fields, admin.FieldLastActiveAt)
	}
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	case admin.FieldStatus:
		return m.Status()
	case admin.FieldLastActiveAt:
		return m.LastActiveAt()
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	case admin.FieldStatus:
		return m.OldStatus(ctx)
	case admin.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case admin.FieldStatus:
		v, ok := value.(consts.AdminStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case admin.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	case admin.FieldStatus:
		m.ResetStatus()
		return nil
	case admin.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.login_histories != nil {
		edges = append(edges, admin.EdgeLoginHistories)
	}
	if m.roles != nil {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.admin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeLoginHistories:
		ids := make([]ent.Value, 0, len(m.login_histories))
		for id := range m.login_histories {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.admin_roles))
		for id := range m.admin_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlogin_histories != nil {
		edges = append(edges, admin.EdgeLoginHistories)
	}
	if m.removedroles != nil {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.removedadmin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeLoginHistories:
		ids := make([]ent.Value, 0, len(m.removedlogin_histories))
		for id := range m.removedlogin_histories {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.removedadmin_roles))
		for id := range m.removedadmin_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlogin_histories {
		edges = append(edges, admin.EdgeLoginHistories)
	}
	if m.clearedroles {
		edges = append(edges, admin.EdgeRoles)
	}
	if m.clearedadmin_roles {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeLoginHistories:
		return m.clearedlogin_histories
	case admin.EdgeRoles:
		return m.clearedroles
	case admin.EdgeAdminRoles:
		return m.clearedadmin_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeLoginHistories:
		m.ResetLoginHistories()
		return nil
	case admin.EdgeRoles:
		m.ResetRoles()
		return nil
	case admin.EdgeAdminRoles:
		m.ResetAdminRoles()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AdminLoginHistoryMutation represents an operation that mutates the AdminLoginHistory nodes in the graph.
type AdminLoginHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	ip             *string
	country        *string
	province       *string
	city           *string
	isp            *string
	asn            *string
	client_version *string
	device         *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	owner          *uuid.UUID
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*AdminLoginHistory, error)
	predicates     []predicate.AdminLoginHistory
}

var _ ent.Mutation = (*AdminLoginHistoryMutation)(nil)

// adminloginhistoryOption allows management of the mutation configuration using functional options.
type adminloginhistoryOption func(*AdminLoginHistoryMutation)

// newAdminLoginHistoryMutation creates new mutation for the AdminLoginHistory entity.
func newAdminLoginHistoryMutation(c config, op Op, opts ...adminloginhistoryOption) *AdminLoginHistoryMutation {
	m := &AdminLoginHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminLoginHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminLoginHistoryID sets the ID field of the mutation.
func withAdminLoginHistoryID(id uuid.UUID) adminloginhistoryOption {
	return func(m *AdminLoginHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminLoginHistory
		)
		m.oldValue = func(ctx context.Context) (*AdminLoginHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminLoginHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminLoginHistory sets the old AdminLoginHistory of the mutation.
func withAdminLoginHistory(node *AdminLoginHistory) adminloginhistoryOption {
	return func(m *AdminLoginHistoryMutation) {
		m.oldValue = func(context.Context) (*AdminLoginHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminLoginHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminLoginHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminLoginHistory entities.
func (m *AdminLoginHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminLoginHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminLoginHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminLoginHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAdminID sets the "admin_id" field.
func (m *AdminLoginHistoryMutation) SetAdminID(u uuid.UUID) {
	m.owner = &u
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *AdminLoginHistoryMutation) AdminID() (r uuid.UUID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldAdminID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ClearAdminID clears the value of the "admin_id" field.
func (m *AdminLoginHistoryMutation) ClearAdminID() {
	m.owner = nil
	m.clearedFields[adminloginhistory.FieldAdminID] = struct{}{}
}

// AdminIDCleared returns if the "admin_id" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) AdminIDCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldAdminID]
	return ok
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *AdminLoginHistoryMutation) ResetAdminID() {
	m.owner = nil
	delete(m.clearedFields, adminloginhistory.FieldAdminID)
}

// SetIP sets the "ip" field.
func (m *AdminLoginHistoryMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AdminLoginHistoryMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AdminLoginHistoryMutation) ResetIP() {
	m.ip = nil
}

// SetCountry sets the "country" field.
func (m *AdminLoginHistoryMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AdminLoginHistoryMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *AdminLoginHistoryMutation) ResetCountry() {
	m.country = nil
}

// SetProvince sets the "province" field.
func (m *AdminLoginHistoryMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *AdminLoginHistoryMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *AdminLoginHistoryMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *AdminLoginHistoryMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AdminLoginHistoryMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AdminLoginHistoryMutation) ResetCity() {
	m.city = nil
}

// SetIsp sets the "isp" field.
func (m *AdminLoginHistoryMutation) SetIsp(s string) {
	m.isp = &s
}

// Isp returns the value of the "isp" field in the mutation.
func (m *AdminLoginHistoryMutation) Isp() (r string, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIsp returns the old "isp" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldIsp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsp: %w", err)
	}
	return oldValue.Isp, nil
}

// ClearIsp clears the value of the "isp" field.
func (m *AdminLoginHistoryMutation) ClearIsp() {
	m.isp = nil
	m.clearedFields[adminloginhistory.FieldIsp] = struct{}{}
}

// IspCleared returns if the "isp" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) IspCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldIsp]
	return ok
}

// ResetIsp resets all changes to the "isp" field.
func (m *AdminLoginHistoryMutation) ResetIsp() {
	m.isp = nil
	delete(m.clearedFields, adminloginhistory.FieldIsp)
}

// SetAsn sets the "asn" field.
func (m *AdminLoginHistoryMutation) SetAsn(s string) {
	m.asn = &s
}

// Asn returns the value of the "asn" field in the mutation.
func (m *AdminLoginHistoryMutation) Asn() (r string, exists bool) {
	v := m.asn
	if v == nil {
		return
	}
	return *v, true
}

// OldAsn returns the old "asn" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldAsn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAsn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAsn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAsn: %w", err)
	}
	return oldValue.Asn, nil
}

// ClearAsn clears the value of the "asn" field.
func (m *AdminLoginHistoryMutation) ClearAsn() {
	m.asn = nil
	m.clearedFields[adminloginhistory.FieldAsn] = struct{}{}
}

// AsnCleared returns if the "asn" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) AsnCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldAsn]
	return ok
}

// ResetAsn resets all changes to the "asn" field.
func (m *AdminLoginHistoryMutation) ResetAsn() {
	m.asn = nil
	delete(m.clearedFields, adminloginhistory.FieldAsn)
}

// SetClientVersion sets the "client_version" field.
func (m *AdminLoginHistoryMutation) SetClientVersion(s string) {
	m.client_version = &s
}

// ClientVersion returns the value of the "client_version" field in the mutation.
func (m *AdminLoginHistoryMutation) ClientVersion() (r string, exists bool) {
	v := m.client_version
	if v == nil {
		return
	}
	return *v, true
}

// OldClientVersion returns the old "client_version" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldClientVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientVersion: %w", err)
	}
	return oldValue.ClientVersion, nil
}

// ClearClientVersion clears the value of the "client_version" field.
func (m *AdminLoginHistoryMutation) ClearClientVersion() {
	m.client_version = nil
	m.clearedFields[adminloginhistory.FieldClientVersion] = struct{}{}
}

// ClientVersionCleared returns if the "client_version" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) ClientVersionCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldClientVersion]
	return ok
}

// ResetClientVersion resets all changes to the "client_version" field.
func (m *AdminLoginHistoryMutation) ResetClientVersion() {
	m.client_version = nil
	delete(m.clearedFields, adminloginhistory.FieldClientVersion)
}

// SetDevice sets the "device" field.
func (m *AdminLoginHistoryMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *AdminLoginHistoryMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *AdminLoginHistoryMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[adminloginhistory.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *AdminLoginHistoryMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[adminloginhistory.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *AdminLoginHistoryMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, adminloginhistory.FieldDevice)
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminLoginHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminLoginHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminLoginHistory entity.
// If the AdminLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminLoginHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminLoginHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the Admin entity by id.
func (m *AdminLoginHistoryMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Admin entity.
func (m *AdminLoginHistoryMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[adminloginhistory.FieldAdminID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Admin entity was cleared.
func (m *AdminLoginHistoryMutation) OwnerCleared() bool {
	return m.AdminIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AdminLoginHistoryMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AdminLoginHistoryMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AdminLoginHistoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AdminLoginHistoryMutation builder.
func (m *AdminLoginHistoryMutation) Where(ps ...predicate.AdminLoginHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminLoginHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminLoginHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminLoginHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminLoginHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminLoginHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminLoginHistory).
func (m *AdminLoginHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminLoginHistoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.owner != nil {
		fields = append(fields, adminloginhistory.FieldAdminID)
	}
	if m.ip != nil {
		fields = append(fields, adminloginhistory.FieldIP)
	}
	if m.country != nil {
		fields = append(fields, adminloginhistory.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, adminloginhistory.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, adminloginhistory.FieldCity)
	}
	if m.isp != nil {
		fields = append(fields, adminloginhistory.FieldIsp)
	}
	if m.asn != nil {
		fields = append(fields, adminloginhistory.FieldAsn)
	}
	if m.client_version != nil {
		fields = append(fields, adminloginhistory.FieldClientVersion)
	}
	if m.device != nil {
		fields = append(fields, adminloginhistory.FieldDevice)
	}
	if m.created_at != nil {
		fields = append(fields, adminloginhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminLoginHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminloginhistory.FieldAdminID:
		return m.AdminID()
	case adminloginhistory.FieldIP:
		return m.IP()
	case adminloginhistory.FieldCountry:
		return m.Country()
	case adminloginhistory.FieldProvince:
		return m.Province()
	case adminloginhistory.FieldCity:
		return m.City()
	case adminloginhistory.FieldIsp:
		return m.Isp()
	case adminloginhistory.FieldAsn:
		return m.Asn()
	case adminloginhistory.FieldClientVersion:
		return m.ClientVersion()
	case adminloginhistory.FieldDevice:
		return m.Device()
	case adminloginhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminLoginHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminloginhistory.FieldAdminID:
		return m.OldAdminID(ctx)
	case adminloginhistory.FieldIP:
		return m.OldIP(ctx)
	case adminloginhistory.FieldCountry:
		return m.OldCountry(ctx)
	case adminloginhistory.FieldProvince:
		return m.OldProvince(ctx)
	case adminloginhistory.FieldCity:
		return m.OldCity(ctx)
	case adminloginhistory.FieldIsp:
		return m.OldIsp(ctx)
	case adminloginhistory.FieldAsn:
		return m.OldAsn(ctx)
	case adminloginhistory.FieldClientVersion:
		return m.OldClientVersion(ctx)
	case adminloginhistory.FieldDevice:
		return m.OldDevice(ctx)
	case adminloginhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminLoginHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminLoginHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminloginhistory.FieldAdminID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case adminloginhistory.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case adminloginhistory.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case adminloginhistory.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case adminloginhistory.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case adminloginhistory.FieldIsp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsp(v)
		return nil
	case adminloginhistory.FieldAsn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAsn(v)
		return nil
	case adminloginhistory.FieldClientVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientVersion(v)
		return nil
	case adminloginhistory.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case adminloginhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminLoginHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminLoginHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminLoginHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminLoginHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminLoginHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminloginhistory.FieldAdminID) {
		fields = append(fields, adminloginhistory.FieldAdminID)
	}
	if m.FieldCleared(adminloginhistory.FieldIsp) {
		fields = append(fields, adminloginhistory.FieldIsp)
	}
	if m.FieldCleared(adminloginhistory.FieldAsn) {
		fields = append(fields, adminloginhistory.FieldAsn)
	}
	if m.FieldCleared(adminloginhistory.FieldClientVersion) {
		fields = append(fields, adminloginhistory.FieldClientVersion)
	}
	if m.FieldCleared(adminloginhistory.FieldDevice) {
		fields = append(fields, adminloginhistory.FieldDevice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminLoginHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminLoginHistoryMutation) ClearField(name string) error {
	switch name {
	case adminloginhistory.FieldAdminID:
		m.ClearAdminID()
		return nil
	case adminloginhistory.FieldIsp:
		m.ClearIsp()
		return nil
	case adminloginhistory.FieldAsn:
		m.ClearAsn()
		return nil
	case adminloginhistory.FieldClientVersion:
		m.ClearClientVersion()
		return nil
	case adminloginhistory.FieldDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminLoginHistoryMutation) ResetField(name string) error {
	switch name {
	case adminloginhistory.FieldAdminID:
		m.ResetAdminID()
		return nil
	case adminloginhistory.FieldIP:
		m.ResetIP()
		return nil
	case adminloginhistory.FieldCountry:
		m.ResetCountry()
		return nil
	case adminloginhistory.FieldProvince:
		m.ResetProvince()
		return nil
	case adminloginhistory.FieldCity:
		m.ResetCity()
		return nil
	case adminloginhistory.FieldIsp:
		m.ResetIsp()
		return nil
	case adminloginhistory.FieldAsn:
		m.ResetAsn()
		return nil
	case adminloginhistory.FieldClientVersion:
		m.ResetClientVersion()
		return nil
	case adminloginhistory.FieldDevice:
		m.ResetDevice()
		return nil
	case adminloginhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminLoginHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, adminloginhistory.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminLoginHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminloginhistory.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminLoginHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminLoginHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminLoginHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, adminloginhistory.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminLoginHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case adminloginhistory.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminLoginHistoryMutation) ClearEdge(name string) error {
	switch name {
	case adminloginhistory.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminLoginHistoryMutation) ResetEdge(name string) error {
	switch name {
	case adminloginhistory.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown AdminLoginHistory edge %s", name)
}

// AdminRoleMutation represents an operation that mutates the AdminRole nodes in the graph.
type AdminRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	admin         *uuid.UUID
	clearedadmin  bool
	role          *int64
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*AdminRole, error)
	predicates    []predicate.AdminRole
}

var _ ent.Mutation = (*AdminRoleMutation)(nil)

// adminroleOption allows management of the mutation configuration using functional options.
type adminroleOption func(*AdminRoleMutation)

// newAdminRoleMutation creates new mutation for the AdminRole entity.
func newAdminRoleMutation(c config, op Op, opts ...adminroleOption) *AdminRoleMutation {
	m := &AdminRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminRoleID sets the ID field of the mutation.
func withAdminRoleID(id uuid.UUID) adminroleOption {
	return func(m *AdminRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminRole
		)
		m.oldValue = func(ctx context.Context) (*AdminRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminRole sets the old AdminRole of the mutation.
func withAdminRole(node *AdminRole) adminroleOption {
	return func(m *AdminRoleMutation) {
		m.oldValue = func(context.Context) (*AdminRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminRole entities.
func (m *AdminRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAdminID sets the "admin_id" field.
func (m *AdminRoleMutation) SetAdminID(u uuid.UUID) {
	m.admin = &u
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *AdminRoleMutation) AdminID() (r uuid.UUID, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldAdminID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *AdminRoleMutation) ResetAdminID() {
	m.admin = nil
}

// SetRoleID sets the "role_id" field.
func (m *AdminRoleMutation) SetRoleID(i int64) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AdminRoleMutation) RoleID() (r int64, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AdminRoleMutation) ResetRoleID() {
	m.role = nil
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *AdminRoleMutation) ClearAdmin() {
	m.clearedadmin = true
	m.clearedFields[adminrole.FieldAdminID] = struct{}{}
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) AdminIDs() (ids []uuid.UUID) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *AdminRoleMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// ClearRole clears the "role" edge to the Role entity.
func (m *AdminRoleMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[adminrole.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *AdminRoleMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) RoleIDs() (ids []int64) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *AdminRoleMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the AdminRoleMutation builder.
func (m *AdminRoleMutation) Where(ps ...predicate.AdminRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminRole).
func (m *AdminRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminRoleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.admin != nil {
		fields = append(fields, adminrole.FieldAdminID)
	}
	if m.role != nil {
		fields = append(fields, adminrole.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminrole.FieldAdminID:
		return m.AdminID()
	case adminrole.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminrole.FieldAdminID:
		return m.OldAdminID(ctx)
	case adminrole.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown AdminRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminrole.FieldAdminID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case adminrole.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdminRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminRoleMutation) ResetField(name string) error {
	switch name {
	case adminrole.FieldAdminID:
		m.ResetAdminID()
		return nil
	case adminrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.admin != nil {
		edges = append(edges, adminrole.EdgeAdmin)
	}
	if m.role != nil {
		edges = append(edges, adminrole.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminrole.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case adminrole.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedadmin {
		edges = append(edges, adminrole.EdgeAdmin)
	}
	if m.clearedrole {
		edges = append(edges, adminrole.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case adminrole.EdgeAdmin:
		return m.clearedadmin
	case adminrole.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminRoleMutation) ClearEdge(name string) error {
	switch name {
	case adminrole.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case adminrole.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown AdminRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminRoleMutation) ResetEdge(name string) error {
	switch name {
	case adminrole.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case adminrole.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown AdminRole edge %s", name)
}

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	deleted_at     *time.Time
	_type          *string
	url            *string
	metadata       *map[string]interface{}
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	message        *uuid.UUID
	clearedmessage bool
	done           bool
	oldValue       func(context.Context) (*Attachment, error)
	predicates     []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttachmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttachmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttachmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attachment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttachmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttachmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attachment.FieldDeletedAt)
}

// SetMessageID sets the "message_id" field.
func (m *AttachmentMutation) SetMessageID(u uuid.UUID) {
	m.message = &u
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *AttachmentMutation) MessageID() (r uuid.UUID, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMessageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *AttachmentMutation) ResetMessageID() {
	m.message = nil
}

// SetType sets the "type" field.
func (m *AttachmentMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AttachmentMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AttachmentMutation) ResetType() {
	m._type = nil
}

// SetURL sets the "url" field.
func (m *AttachmentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AttachmentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AttachmentMutation) ResetURL() {
	m.url = nil
}

// SetMetadata sets the "metadata" field.
func (m *AttachmentMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AttachmentMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AttachmentMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[attachment.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AttachmentMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[attachment.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AttachmentMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, attachment.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *AttachmentMutation) ClearMessage() {
	m.clearedmessage = true
	m.clearedFields[attachment.FieldMessageID] = struct{}{}
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *AttachmentMutation) MessageCleared() bool {
	return m.clearedmessage
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) MessageIDs() (ids []uuid.UUID) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *AttachmentMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.message != nil {
		fields = append(fields, attachment.FieldMessageID)
	}
	if m._type != nil {
		fields = append(fields, attachment.FieldType)
	}
	if m.url != nil {
		fields = append(fields, attachment.FieldURL)
	}
	if m.metadata != nil {
		fields = append(fields, attachment.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldDeletedAt:
		return m.DeletedAt()
	case attachment.FieldMessageID:
		return m.MessageID()
	case attachment.FieldType:
		return m.GetType()
	case attachment.FieldURL:
		return m.URL()
	case attachment.FieldMetadata:
		return m.Metadata()
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attachment.FieldMessageID:
		return m.OldMessageID(ctx)
	case attachment.FieldType:
		return m.OldType(ctx)
	case attachment.FieldURL:
		return m.OldURL(ctx)
	case attachment.FieldMetadata:
		return m.OldMetadata(ctx)
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attachment.FieldMessageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case attachment.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case attachment.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case attachment.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldDeletedAt) {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.FieldCleared(attachment.FieldMetadata) {
		fields = append(fields, attachment.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attachment.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attachment.FieldMessageID:
		m.ResetMessageID()
		return nil
	case attachment.FieldType:
		m.ResetType()
		return nil
	case attachment.FieldURL:
		m.ResetURL()
		return nil
	case attachment.FieldMetadata:
		m.ResetMetadata()
		return nil
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.message != nil {
		edges = append(edges, attachment.EdgeMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmessage {
		edges = append(edges, attachment.EdgeMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeMessage:
		return m.clearedmessage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	deleted_at     *time.Time
	operator_type  *consts.OperatorType
	operator_id    *uuid.UUID
	operator_name  *string
	operation_type *consts.OperationType
	resource_type  *consts.ResourceType
	resource_id    *string
	resource_name  *string
	method         *string
	_path          *string
	query_params   *string
	request_body   *string
	user_agent     *string
	status_code    *int
	addstatus_code *int
	status         *consts.AuditLogStatus
	response_body  *string
	error_message  *string
	ip             *string
	country        *string
	province       *string
	city           *string
	isp            *string
	session_id     *string
	trace_id       *string
	business_data  *string
	changes        *string
	description    *string
	created_at     *time.Time
	updated_at     *time.Time
	duration_ms    *int64
	addduration_ms *int64
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AuditLog, error)
	predicates     []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uuid.UUID) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuditLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuditLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuditLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[auditlog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuditLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuditLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, auditlog.FieldDeletedAt)
}

// SetOperatorType sets the "operator_type" field.
func (m *AuditLogMutation) SetOperatorType(ct consts.OperatorType) {
	m.operator_type = &ct
}

// OperatorType returns the value of the "operator_type" field in the mutation.
func (m *AuditLogMutation) OperatorType() (r consts.OperatorType, exists bool) {
	v := m.operator_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorType returns the old "operator_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperatorType(ctx context.Context) (v consts.OperatorType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorType: %w", err)
	}
	return oldValue.OperatorType, nil
}

// ResetOperatorType resets all changes to the "operator_type" field.
func (m *AuditLogMutation) ResetOperatorType() {
	m.operator_type = nil
}

// SetOperatorID sets the "operator_id" field.
func (m *AuditLogMutation) SetOperatorID(u uuid.UUID) {
	m.operator_id = &u
}

// OperatorID returns the value of the "operator_id" field in the mutation.
func (m *AuditLogMutation) OperatorID() (r uuid.UUID, exists bool) {
	v := m.operator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorID returns the old "operator_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperatorID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorID: %w", err)
	}
	return oldValue.OperatorID, nil
}

// ClearOperatorID clears the value of the "operator_id" field.
func (m *AuditLogMutation) ClearOperatorID() {
	m.operator_id = nil
	m.clearedFields[auditlog.FieldOperatorID] = struct{}{}
}

// OperatorIDCleared returns if the "operator_id" field was cleared in this mutation.
func (m *AuditLogMutation) OperatorIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldOperatorID]
	return ok
}

// ResetOperatorID resets all changes to the "operator_id" field.
func (m *AuditLogMutation) ResetOperatorID() {
	m.operator_id = nil
	delete(m.clearedFields, auditlog.FieldOperatorID)
}

// SetOperatorName sets the "operator_name" field.
func (m *AuditLogMutation) SetOperatorName(s string) {
	m.operator_name = &s
}

// OperatorName returns the value of the "operator_name" field in the mutation.
func (m *AuditLogMutation) OperatorName() (r string, exists bool) {
	v := m.operator_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorName returns the old "operator_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperatorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorName: %w", err)
	}
	return oldValue.OperatorName, nil
}

// ClearOperatorName clears the value of the "operator_name" field.
func (m *AuditLogMutation) ClearOperatorName() {
	m.operator_name = nil
	m.clearedFields[auditlog.FieldOperatorName] = struct{}{}
}

// OperatorNameCleared returns if the "operator_name" field was cleared in this mutation.
func (m *AuditLogMutation) OperatorNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldOperatorName]
	return ok
}

// ResetOperatorName resets all changes to the "operator_name" field.
func (m *AuditLogMutation) ResetOperatorName() {
	m.operator_name = nil
	delete(m.clearedFields, auditlog.FieldOperatorName)
}

// SetOperationType sets the "operation_type" field.
func (m *AuditLogMutation) SetOperationType(ct consts.OperationType) {
	m.operation_type = &ct
}

// OperationType returns the value of the "operation_type" field in the mutation.
func (m *AuditLogMutation) OperationType() (r consts.OperationType, exists bool) {
	v := m.operation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationType returns the old "operation_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperationType(ctx context.Context) (v consts.OperationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationType: %w", err)
	}
	return oldValue.OperationType, nil
}

// ResetOperationType resets all changes to the "operation_type" field.
func (m *AuditLogMutation) ResetOperationType() {
	m.operation_type = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AuditLogMutation) SetResourceType(ct consts.ResourceType) {
	m.resource_type = &ct
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AuditLogMutation) ResourceType() (r consts.ResourceType, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceType(ctx context.Context) (v consts.ResourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AuditLogMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *AuditLogMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AuditLogMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AuditLogMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[auditlog.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AuditLogMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, auditlog.FieldResourceID)
}

// SetResourceName sets the "resource_name" field.
func (m *AuditLogMutation) SetResourceName(s string) {
	m.resource_name = &s
}

// ResourceName returns the value of the "resource_name" field in the mutation.
func (m *AuditLogMutation) ResourceName() (r string, exists bool) {
	v := m.resource_name
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceName returns the old "resource_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceName: %w", err)
	}
	return oldValue.ResourceName, nil
}

// ClearResourceName clears the value of the "resource_name" field.
func (m *AuditLogMutation) ClearResourceName() {
	m.resource_name = nil
	m.clearedFields[auditlog.FieldResourceName] = struct{}{}
}

// ResourceNameCleared returns if the "resource_name" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceName]
	return ok
}

// ResetResourceName resets all changes to the "resource_name" field.
func (m *AuditLogMutation) ResetResourceName() {
	m.resource_name = nil
	delete(m.clearedFields, auditlog.FieldResourceName)
}

// SetMethod sets the "method" field.
func (m *AuditLogMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AuditLogMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AuditLogMutation) ResetMethod() {
	m.method = nil
}

// SetPath sets the "path" field.
func (m *AuditLogMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *AuditLogMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *AuditLogMutation) ResetPath() {
	m._path = nil
}

// SetQueryParams sets the "query_params" field.
func (m *AuditLogMutation) SetQueryParams(s string) {
	m.query_params = &s
}

// QueryParams returns the value of the "query_params" field in the mutation.
func (m *AuditLogMutation) QueryParams() (r string, exists bool) {
	v := m.query_params
	if v == nil {
		return
	}
	return *v, true
}

// OldQueryParams returns the old "query_params" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldQueryParams(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueryParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueryParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueryParams: %w", err)
	}
	return oldValue.QueryParams, nil
}

// ClearQueryParams clears the value of the "query_params" field.
func (m *AuditLogMutation) ClearQueryParams() {
	m.query_params = nil
	m.clearedFields[auditlog.FieldQueryParams] = struct{}{}
}

// QueryParamsCleared returns if the "query_params" field was cleared in this mutation.
func (m *AuditLogMutation) QueryParamsCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldQueryParams]
	return ok
}

// ResetQueryParams resets all changes to the "query_params" field.
func (m *AuditLogMutation) ResetQueryParams() {
	m.query_params = nil
	delete(m.clearedFields, auditlog.FieldQueryParams)
}

// SetRequestBody sets the "request_body" field.
func (m *AuditLogMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *AuditLogMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *AuditLogMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[auditlog.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *AuditLogMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *AuditLogMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, auditlog.FieldRequestBody)
}

// SetUserAgent sets the "user_agent" field.
func (m *AuditLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuditLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuditLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[auditlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuditLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuditLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, auditlog.FieldUserAgent)
}

// SetStatusCode sets the "status_code" field.
func (m *AuditLogMutation) SetStatusCode(i int) {
	m.status_code = &i
	m.addstatus_code = nil
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *AuditLogMutation) StatusCode() (r int, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// AddStatusCode adds i to the "status_code" field.
func (m *AuditLogMutation) AddStatusCode(i int) {
	if m.addstatus_code != nil {
		*m.addstatus_code += i
	} else {
		m.addstatus_code = &i
	}
}

// AddedStatusCode returns the value that was added to the "status_code" field in this mutation.
func (m *AuditLogMutation) AddedStatusCode() (r int, exists bool) {
	v := m.addstatus_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *AuditLogMutation) ResetStatusCode() {
	m.status_code = nil
	m.addstatus_code = nil
}

// SetStatus sets the "status" field.
func (m *AuditLogMutation) SetStatus(cls consts.AuditLogStatus) {
	m.status = &cls
}

// Status returns the value of the "status" field in the mutation.
func (m *AuditLogMutation) Status() (r consts.AuditLogStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldStatus(ctx context.Context) (v consts.AuditLogStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AuditLogMutation) ResetStatus() {
	m.status = nil
}

// SetResponseBody sets the "response_body" field.
func (m *AuditLogMutation) SetResponseBody(s string) {
	m.response_body = &s
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *AuditLogMutation) ResponseBody() (r string, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResponseBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *AuditLogMutation) ClearResponseBody() {
	m.response_body = nil
	m.clearedFields[auditlog.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *AuditLogMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *AuditLogMutation) ResetResponseBody() {
	m.response_body = nil
	delete(m.clearedFields, auditlog.FieldResponseBody)
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetIP sets the "ip" field.
func (m *AuditLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AuditLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AuditLogMutation) ResetIP() {
	m.ip = nil
}

// SetCountry sets the "country" field.
func (m *AuditLogMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AuditLogMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *AuditLogMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[auditlog.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *AuditLogMutation) CountryCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *AuditLogMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, auditlog.FieldCountry)
}

// SetProvince sets the "province" field.
func (m *AuditLogMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *AuditLogMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *AuditLogMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[auditlog.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *AuditLogMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *AuditLogMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, auditlog.FieldProvince)
}

// SetCity sets the "city" field.
func (m *AuditLogMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AuditLogMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *AuditLogMutation) ClearCity() {
	m.city = nil
	m.clearedFields[auditlog.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *AuditLogMutation) CityCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *AuditLogMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, auditlog.FieldCity)
}

// SetIsp sets the "isp" field.
func (m *AuditLogMutation) SetIsp(s string) {
	m.isp = &s
}

// Isp returns the value of the "isp" field in the mutation.
func (m *AuditLogMutation) Isp() (r string, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIsp returns the old "isp" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIsp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsp: %w", err)
	}
	return oldValue.Isp, nil
}

// ClearIsp clears the value of the "isp" field.
func (m *AuditLogMutation) ClearIsp() {
	m.isp = nil
	m.clearedFields[auditlog.FieldIsp] = struct{}{}
}

// IspCleared returns if the "isp" field was cleared in this mutation.
func (m *AuditLogMutation) IspCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldIsp]
	return ok
}

// ResetIsp resets all changes to the "isp" field.
func (m *AuditLogMutation) ResetIsp() {
	m.isp = nil
	delete(m.clearedFields, auditlog.FieldIsp)
}

// SetSessionID sets the "session_id" field.
func (m *AuditLogMutation) SetSessionID(s string) {
	m.session_id = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *AuditLogMutation) SessionID() (r string, exists bool) {
	v := m.session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ClearSessionID clears the value of the "session_id" field.
func (m *AuditLogMutation) ClearSessionID() {
	m.session_id = nil
	m.clearedFields[auditlog.FieldSessionID] = struct{}{}
}

// SessionIDCleared returns if the "session_id" field was cleared in this mutation.
func (m *AuditLogMutation) SessionIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldSessionID]
	return ok
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *AuditLogMutation) ResetSessionID() {
	m.session_id = nil
	delete(m.clearedFields, auditlog.FieldSessionID)
}

// SetTraceID sets the "trace_id" field.
func (m *AuditLogMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *AuditLogMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *AuditLogMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[auditlog.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *AuditLogMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *AuditLogMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, auditlog.FieldTraceID)
}

// SetBusinessData sets the "business_data" field.
func (m *AuditLogMutation) SetBusinessData(s string) {
	m.business_data = &s
}

// BusinessData returns the value of the "business_data" field in the mutation.
func (m *AuditLogMutation) BusinessData() (r string, exists bool) {
	v := m.business_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessData returns the old "business_data" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldBusinessData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessData: %w", err)
	}
	return oldValue.BusinessData, nil
}

// ClearBusinessData clears the value of the "business_data" field.
func (m *AuditLogMutation) ClearBusinessData() {
	m.business_data = nil
	m.clearedFields[auditlog.FieldBusinessData] = struct{}{}
}

// BusinessDataCleared returns if the "business_data" field was cleared in this mutation.
func (m *AuditLogMutation) BusinessDataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldBusinessData]
	return ok
}

// ResetBusinessData resets all changes to the "business_data" field.
func (m *AuditLogMutation) ResetBusinessData() {
	m.business_data = nil
	delete(m.clearedFields, auditlog.FieldBusinessData)
}

// SetChanges sets the "changes" field.
func (m *AuditLogMutation) SetChanges(s string) {
	m.changes = &s
}

// Changes returns the value of the "changes" field in the mutation.
func (m *AuditLogMutation) Changes() (r string, exists bool) {
	v := m.changes
	if v == nil {
		return
	}
	return *v, true
}

// OldChanges returns the old "changes" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldChanges(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChanges: %w", err)
	}
	return oldValue.Changes, nil
}

// ClearChanges clears the value of the "changes" field.
func (m *AuditLogMutation) ClearChanges() {
	m.changes = nil
	m.clearedFields[auditlog.FieldChanges] = struct{}{}
}

// ChangesCleared returns if the "changes" field was cleared in this mutation.
func (m *AuditLogMutation) ChangesCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldChanges]
	return ok
}

// ResetChanges resets all changes to the "changes" field.
func (m *AuditLogMutation) ResetChanges() {
	m.changes = nil
	delete(m.clearedFields, auditlog.FieldChanges)
}

// SetDescription sets the "description" field.
func (m *AuditLogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuditLogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuditLogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[auditlog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuditLogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuditLogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, auditlog.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuditLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuditLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuditLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *AuditLogMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *AuditLogMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *AuditLogMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *AuditLogMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *AuditLogMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[auditlog.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *AuditLogMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *AuditLogMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, auditlog.FieldDurationMs)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.deleted_at != nil {
		fields = append(fields, auditlog.FieldDeletedAt)
	}
	if m.operator_type != nil {
		fields = append(fields, auditlog.FieldOperatorType)
	}
	if m.operator_id != nil {
		fields = append(fields, auditlog.FieldOperatorID)
	}
	if m.operator_name != nil {
		fields = append(fields, auditlog.FieldOperatorName)
	}
	if m.operation_type != nil {
		fields = append(fields, auditlog.FieldOperationType)
	}
	if m.resource_type != nil {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.resource_name != nil {
		fields = append(fields, auditlog.FieldResourceName)
	}
	if m.method != nil {
		fields = append(fields, auditlog.FieldMethod)
	}
	if m._path != nil {
		fields = append(fields, auditlog.FieldPath)
	}
	if m.query_params != nil {
		fields = append(fields, auditlog.FieldQueryParams)
	}
	if m.request_body != nil {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	if m.user_agent != nil {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.status_code != nil {
		fields = append(fields, auditlog.FieldStatusCode)
	}
	if m.status != nil {
		fields = append(fields, auditlog.FieldStatus)
	}
	if m.response_body != nil {
		fields = append(fields, auditlog.FieldResponseBody)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.ip != nil {
		fields = append(fields, auditlog.FieldIP)
	}
	if m.country != nil {
		fields = append(fields, auditlog.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, auditlog.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, auditlog.FieldCity)
	}
	if m.isp != nil {
		fields = append(fields, auditlog.FieldIsp)
	}
	if m.session_id != nil {
		fields = append(fields, auditlog.FieldSessionID)
	}
	if m.trace_id != nil {
		fields = append(fields, auditlog.FieldTraceID)
	}
	if m.business_data != nil {
		fields = append(fields, auditlog.FieldBusinessData)
	}
	if m.changes != nil {
		fields = append(fields, auditlog.FieldChanges)
	}
	if m.description != nil {
		fields = append(fields, auditlog.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, auditlog.FieldUpdatedAt)
	}
	if m.duration_ms != nil {
		fields = append(fields, auditlog.FieldDurationMs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldDeletedAt:
		return m.DeletedAt()
	case auditlog.FieldOperatorType:
		return m.OperatorType()
	case auditlog.FieldOperatorID:
		return m.OperatorID()
	case auditlog.FieldOperatorName:
		return m.OperatorName()
	case auditlog.FieldOperationType:
		return m.OperationType()
	case auditlog.FieldResourceType:
		return m.ResourceType()
	case auditlog.FieldResourceID:
		return m.ResourceID()
	case auditlog.FieldResourceName:
		return m.ResourceName()
	case auditlog.FieldMethod:
		return m.Method()
	case auditlog.FieldPath:
		return m.Path()
	case auditlog.FieldQueryParams:
		return m.QueryParams()
	case auditlog.FieldRequestBody:
		return m.RequestBody()
	case auditlog.FieldUserAgent:
		return m.UserAgent()
	case auditlog.FieldStatusCode:
		return m.StatusCode()
	case auditlog.FieldStatus:
		return m.Status()
	case auditlog.FieldResponseBody:
		return m.ResponseBody()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldIP:
		return m.IP()
	case auditlog.FieldCountry:
		return m.Country()
	case auditlog.FieldProvince:
		return m.Province()
	case auditlog.FieldCity:
		return m.City()
	case auditlog.FieldIsp:
		return m.Isp()
	case auditlog.FieldSessionID:
		return m.SessionID()
	case auditlog.FieldTraceID:
		return m.TraceID()
	case auditlog.FieldBusinessData:
		return m.BusinessData()
	case auditlog.FieldChanges:
		return m.Changes()
	case auditlog.FieldDescription:
		return m.Description()
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case auditlog.FieldDurationMs:
		return m.DurationMs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case auditlog.FieldOperatorType:
		return m.OldOperatorType(ctx)
	case auditlog.FieldOperatorID:
		return m.OldOperatorID(ctx)
	case auditlog.FieldOperatorName:
		return m.OldOperatorName(ctx)
	case auditlog.FieldOperationType:
		return m.OldOperationType(ctx)
	case auditlog.FieldResourceType:
		return m.OldResourceType(ctx)
	case auditlog.FieldResourceID:
		return m.OldResourceID(ctx)
	case auditlog.FieldResourceName:
		return m.OldResourceName(ctx)
	case auditlog.FieldMethod:
		return m.OldMethod(ctx)
	case auditlog.FieldPath:
		return m.OldPath(ctx)
	case auditlog.FieldQueryParams:
		return m.OldQueryParams(ctx)
	case auditlog.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case auditlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case auditlog.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case auditlog.FieldStatus:
		return m.OldStatus(ctx)
	case auditlog.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldIP:
		return m.OldIP(ctx)
	case auditlog.FieldCountry:
		return m.OldCountry(ctx)
	case auditlog.FieldProvince:
		return m.OldProvince(ctx)
	case auditlog.FieldCity:
		return m.OldCity(ctx)
	case auditlog.FieldIsp:
		return m.OldIsp(ctx)
	case auditlog.FieldSessionID:
		return m.OldSessionID(ctx)
	case auditlog.FieldTraceID:
		return m.OldTraceID(ctx)
	case auditlog.FieldBusinessData:
		return m.OldBusinessData(ctx)
	case auditlog.FieldChanges:
		return m.OldChanges(ctx)
	case auditlog.FieldDescription:
		return m.OldDescription(ctx)
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case auditlog.FieldDurationMs:
		return m.OldDurationMs(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case auditlog.FieldOperatorType:
		v, ok := value.(consts.OperatorType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorType(v)
		return nil
	case auditlog.FieldOperatorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorID(v)
		return nil
	case auditlog.FieldOperatorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorName(v)
		return nil
	case auditlog.FieldOperationType:
		v, ok := value.(consts.OperationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationType(v)
		return nil
	case auditlog.FieldResourceType:
		v, ok := value.(consts.ResourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case auditlog.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case auditlog.FieldResourceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceName(v)
		return nil
	case auditlog.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case auditlog.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case auditlog.FieldQueryParams:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueryParams(v)
		return nil
	case auditlog.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case auditlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case auditlog.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case auditlog.FieldStatus:
		v, ok := value.(consts.AuditLogStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case auditlog.FieldResponseBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case auditlog.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case auditlog.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case auditlog.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case auditlog.FieldIsp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsp(v)
		return nil
	case auditlog.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case auditlog.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case auditlog.FieldBusinessData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessData(v)
		return nil
	case auditlog.FieldChanges:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChanges(v)
		return nil
	case auditlog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case auditlog.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_code != nil {
		fields = append(fields, auditlog.FieldStatusCode)
	}
	if m.addduration_ms != nil {
		fields = append(fields, auditlog.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldStatusCode:
		return m.AddedStatusCode()
	case auditlog.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusCode(v)
		return nil
	case auditlog.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldDeletedAt) {
		fields = append(fields, auditlog.FieldDeletedAt)
	}
	if m.FieldCleared(auditlog.FieldOperatorID) {
		fields = append(fields, auditlog.FieldOperatorID)
	}
	if m.FieldCleared(auditlog.FieldOperatorName) {
		fields = append(fields, auditlog.FieldOperatorName)
	}
	if m.FieldCleared(auditlog.FieldResourceID) {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.FieldCleared(auditlog.FieldResourceName) {
		fields = append(fields, auditlog.FieldResourceName)
	}
	if m.FieldCleared(auditlog.FieldQueryParams) {
		fields = append(fields, auditlog.FieldQueryParams)
	}
	if m.FieldCleared(auditlog.FieldRequestBody) {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	if m.FieldCleared(auditlog.FieldUserAgent) {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.FieldCleared(auditlog.FieldResponseBody) {
		fields = append(fields, auditlog.FieldResponseBody)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.FieldCleared(auditlog.FieldCountry) {
		fields = append(fields, auditlog.FieldCountry)
	}
	if m.FieldCleared(auditlog.FieldProvince) {
		fields = append(fields, auditlog.FieldProvince)
	}
	if m.FieldCleared(auditlog.FieldCity) {
		fields = append(fields, auditlog.FieldCity)
	}
	if m.FieldCleared(auditlog.FieldIsp) {
		fields = append(fields, auditlog.FieldIsp)
	}
	if m.FieldCleared(auditlog.FieldSessionID) {
		fields = append(fields, auditlog.FieldSessionID)
	}
	if m.FieldCleared(auditlog.FieldTraceID) {
		fields = append(fields, auditlog.FieldTraceID)
	}
	if m.FieldCleared(auditlog.FieldBusinessData) {
		fields = append(fields, auditlog.FieldBusinessData)
	}
	if m.FieldCleared(auditlog.FieldChanges) {
		fields = append(fields, auditlog.FieldChanges)
	}
	if m.FieldCleared(auditlog.FieldDescription) {
		fields = append(fields, auditlog.FieldDescription)
	}
	if m.FieldCleared(auditlog.FieldDurationMs) {
		fields = append(fields, auditlog.FieldDurationMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case auditlog.FieldOperatorID:
		m.ClearOperatorID()
		return nil
	case auditlog.FieldOperatorName:
		m.ClearOperatorName()
		return nil
	case auditlog.FieldResourceID:
		m.ClearResourceID()
		return nil
	case auditlog.FieldResourceName:
		m.ClearResourceName()
		return nil
	case auditlog.FieldQueryParams:
		m.ClearQueryParams()
		return nil
	case auditlog.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	case auditlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case auditlog.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditlog.FieldCountry:
		m.ClearCountry()
		return nil
	case auditlog.FieldProvince:
		m.ClearProvince()
		return nil
	case auditlog.FieldCity:
		m.ClearCity()
		return nil
	case auditlog.FieldIsp:
		m.ClearIsp()
		return nil
	case auditlog.FieldSessionID:
		m.ClearSessionID()
		return nil
	case auditlog.FieldTraceID:
		m.ClearTraceID()
		return nil
	case auditlog.FieldBusinessData:
		m.ClearBusinessData()
		return nil
	case auditlog.FieldChanges:
		m.ClearChanges()
		return nil
	case auditlog.FieldDescription:
		m.ClearDescription()
		return nil
	case auditlog.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case auditlog.FieldOperatorType:
		m.ResetOperatorType()
		return nil
	case auditlog.FieldOperatorID:
		m.ResetOperatorID()
		return nil
	case auditlog.FieldOperatorName:
		m.ResetOperatorName()
		return nil
	case auditlog.FieldOperationType:
		m.ResetOperationType()
		return nil
	case auditlog.FieldResourceType:
		m.ResetResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ResetResourceID()
		return nil
	case auditlog.FieldResourceName:
		m.ResetResourceName()
		return nil
	case auditlog.FieldMethod:
		m.ResetMethod()
		return nil
	case auditlog.FieldPath:
		m.ResetPath()
		return nil
	case auditlog.FieldQueryParams:
		m.ResetQueryParams()
		return nil
	case auditlog.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case auditlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case auditlog.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case auditlog.FieldStatus:
		m.ResetStatus()
		return nil
	case auditlog.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldIP:
		m.ResetIP()
		return nil
	case auditlog.FieldCountry:
		m.ResetCountry()
		return nil
	case auditlog.FieldProvince:
		m.ResetProvince()
		return nil
	case auditlog.FieldCity:
		m.ResetCity()
		return nil
	case auditlog.FieldIsp:
		m.ResetIsp()
		return nil
	case auditlog.FieldSessionID:
		m.ResetSessionID()
		return nil
	case auditlog.FieldTraceID:
		m.ResetTraceID()
		return nil
	case auditlog.FieldBusinessData:
		m.ResetBusinessData()
		return nil
	case auditlog.FieldChanges:
		m.ResetChanges()
		return nil
	case auditlog.FieldDescription:
		m.ResetDescription()
		return nil
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case auditlog.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	deleted_at      *time.Time
	title           *string
	agent_name      *string
	metadata        *map[string]interface{}
	status          *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	user            *uuid.UUID
	cleareduser     bool
	messages        map[uuid.UUID]struct{}
	removedmessages map[uuid.UUID]struct{}
	clearedmessages bool
	done            bool
	oldValue        func(context.Context) (*Conversation, error)
	predicates      []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id uuid.UUID) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Conversation entities.
func (m *ConversationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ConversationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ConversationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ConversationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[conversation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ConversationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[conversation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ConversationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, conversation.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *ConversationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConversationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConversationMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *ConversationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConversationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ConversationMutation) ResetTitle() {
	m.title = nil
}

// SetAgentName sets the "agent_name" field.
func (m *ConversationMutation) SetAgentName(s string) {
	m.agent_name = &s
}

// AgentName returns the value of the "agent_name" field in the mutation.
func (m *ConversationMutation) AgentName() (r string, exists bool) {
	v := m.agent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentName returns the old "agent_name" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldAgentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentName: %w", err)
	}
	return oldValue.AgentName, nil
}

// ClearAgentName clears the value of the "agent_name" field.
func (m *ConversationMutation) ClearAgentName() {
	m.agent_name = nil
	m.clearedFields[conversation.FieldAgentName] = struct{}{}
}

// AgentNameCleared returns if the "agent_name" field was cleared in this mutation.
func (m *ConversationMutation) AgentNameCleared() bool {
	_, ok := m.clearedFields[conversation.FieldAgentName]
	return ok
}

// ResetAgentName resets all changes to the "agent_name" field.
func (m *ConversationMutation) ResetAgentName() {
	m.agent_name = nil
	delete(m.clearedFields, conversation.FieldAgentName)
}

// SetMetadata sets the "metadata" field.
func (m *ConversationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ConversationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ConversationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[conversation.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ConversationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[conversation.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ConversationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, conversation.FieldMetadata)
}

// SetStatus sets the "status" field.
func (m *ConversationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConversationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConversationMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConversationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConversationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConversationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ConversationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[conversation.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ConversationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ConversationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ConversationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ConversationMutation) AddMessageIDs(ids ...uuid.UUID) {
	if m.messages == nil {
		m.messages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ConversationMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ConversationMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ConversationMutation) RemoveMessageIDs(ids ...uuid.UUID) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ConversationMutation) RemovedMessagesIDs() (ids []uuid.UUID) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ConversationMutation) MessagesIDs() (ids []uuid.UUID) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ConversationMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.deleted_at != nil {
		fields = append(fields, conversation.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, conversation.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, conversation.FieldTitle)
	}
	if m.agent_name != nil {
		fields = append(fields, conversation.FieldAgentName)
	}
	if m.metadata != nil {
		fields = append(fields, conversation.FieldMetadata)
	}
	if m.status != nil {
		fields = append(fields, conversation.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, conversation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldDeletedAt:
		return m.DeletedAt()
	case conversation.FieldUserID:
		return m.UserID()
	case conversation.FieldTitle:
		return m.Title()
	case conversation.FieldAgentName:
		return m.AgentName()
	case conversation.FieldMetadata:
		return m.Metadata()
	case conversation.FieldStatus:
		return m.Status()
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case conversation.FieldUserID:
		return m.OldUserID(ctx)
	case conversation.FieldTitle:
		return m.OldTitle(ctx)
	case conversation.FieldAgentName:
		return m.OldAgentName(ctx)
	case conversation.FieldMetadata:
		return m.OldMetadata(ctx)
	case conversation.FieldStatus:
		return m.OldStatus(ctx)
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case conversation.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case conversation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case conversation.FieldAgentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentName(v)
		return nil
	case conversation.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case conversation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversation.FieldDeletedAt) {
		fields = append(fields, conversation.FieldDeletedAt)
	}
	if m.FieldCleared(conversation.FieldAgentName) {
		fields = append(fields, conversation.FieldAgentName)
	}
	if m.FieldCleared(conversation.FieldMetadata) {
		fields = append(fields, conversation.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	switch name {
	case conversation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case conversation.FieldAgentName:
		m.ClearAgentName()
		return nil
	case conversation.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case conversation.FieldUserID:
		m.ResetUserID()
		return nil
	case conversation.FieldTitle:
		m.ResetTitle()
		return nil
	case conversation.FieldAgentName:
		m.ResetAgentName()
		return nil
	case conversation.FieldMetadata:
		m.ResetMetadata()
		return nil
	case conversation.FieldStatus:
		m.ResetStatus()
		return nil
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, conversation.EdgeUser)
	}
	if m.messages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, conversation.EdgeUser)
	}
	if m.clearedmessages {
		edges = append(edges, conversation.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	switch name {
	case conversation.EdgeUser:
		return m.cleareduser
	case conversation.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	switch name {
	case conversation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	switch name {
	case conversation.EdgeUser:
		m.ResetUser()
		return nil
	case conversation.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	deleted_at       *time.Time
	name             *string
	description      *string
	parent_id        *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	positions        map[uuid.UUID]struct{}
	removedpositions map[uuid.UUID]struct{}
	clearedpositions bool
	done             bool
	oldValue         func(context.Context) (*Department, error)
	predicates       []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id uuid.UUID) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Department entities.
func (m *DepartmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DepartmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DepartmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DepartmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[department.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DepartmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DepartmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, department.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DepartmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DepartmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DepartmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[department.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DepartmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[department.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DepartmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, department.FieldDescription)
}

// SetParentID sets the "parent_id" field.
func (m *DepartmentMutation) SetParentID(u uuid.UUID) {
	m.parent_id = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DepartmentMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DepartmentMutation) ClearParentID() {
	m.parent_id = nil
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DepartmentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[department.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DepartmentMutation) ResetParentID() {
	m.parent_id = nil
	delete(m.clearedFields, department.FieldParentID)
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPositionIDs adds the "positions" edge to the JobPosition entity by ids.
func (m *DepartmentMutation) AddPositionIDs(ids ...uuid.UUID) {
	if m.positions == nil {
		m.positions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the "positions" edge to the JobPosition entity.
func (m *DepartmentMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared reports if the "positions" edge to the JobPosition entity was cleared.
func (m *DepartmentMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the "positions" edge to the JobPosition entity by IDs.
func (m *DepartmentMutation) RemovePositionIDs(ids ...uuid.UUID) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.positions, ids[i])
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed IDs of the "positions" edge to the JobPosition entity.
func (m *DepartmentMutation) RemovedPositionsIDs() (ids []uuid.UUID) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the "positions" edge IDs in the mutation.
func (m *DepartmentMutation) PositionsIDs() (ids []uuid.UUID) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions resets all changes to the "positions" edge.
func (m *DepartmentMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.description != nil {
		fields = append(fields, department.FieldDescription)
	}
	if m.parent_id != nil {
		fields = append(fields, department.FieldParentID)
	}
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDeletedAt:
		return m.DeletedAt()
	case department.FieldName:
		return m.Name()
	case department.FieldDescription:
		return m.Description()
	case department.FieldParentID:
		return m.ParentID()
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldDescription:
		return m.OldDescription(ctx)
	case department.FieldParentID:
		return m.OldParentID(ctx)
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case department.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDeletedAt) {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.FieldCleared(department.FieldDescription) {
		fields = append(fields, department.FieldDescription)
	}
	if m.FieldCleared(department.FieldParentID) {
		fields = append(fields, department.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case department.FieldDescription:
		m.ClearDescription()
		return nil
	case department.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldDescription:
		m.ResetDescription()
		return nil
	case department.FieldParentID:
		m.ResetParentID()
		return nil
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.positions != nil {
		edges = append(edges, department.EdgePositions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpositions != nil {
		edges = append(edges, department.EdgePositions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpositions {
		edges = append(edges, department.EdgePositions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgePositions:
		return m.clearedpositions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgePositions:
		m.ResetPositions()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// JobEducationRequirementMutation represents an operation that mutates the JobEducationRequirement nodes in the graph.
type JobEducationRequirementMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	deleted_at     *time.Time
	education_type *consts.JobEducationType
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	job            *uuid.UUID
	clearedjob     bool
	done           bool
	oldValue       func(context.Context) (*JobEducationRequirement, error)
	predicates     []predicate.JobEducationRequirement
}

var _ ent.Mutation = (*JobEducationRequirementMutation)(nil)

// jobeducationrequirementOption allows management of the mutation configuration using functional options.
type jobeducationrequirementOption func(*JobEducationRequirementMutation)

// newJobEducationRequirementMutation creates new mutation for the JobEducationRequirement entity.
func newJobEducationRequirementMutation(c config, op Op, opts ...jobeducationrequirementOption) *JobEducationRequirementMutation {
	m := &JobEducationRequirementMutation{
		config:        c,
		op:            op,
		typ:           TypeJobEducationRequirement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobEducationRequirementID sets the ID field of the mutation.
func withJobEducationRequirementID(id uuid.UUID) jobeducationrequirementOption {
	return func(m *JobEducationRequirementMutation) {
		var (
			err   error
			once  sync.Once
			value *JobEducationRequirement
		)
		m.oldValue = func(ctx context.Context) (*JobEducationRequirement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobEducationRequirement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobEducationRequirement sets the old JobEducationRequirement of the mutation.
func withJobEducationRequirement(node *JobEducationRequirement) jobeducationrequirementOption {
	return func(m *JobEducationRequirementMutation) {
		m.oldValue = func(context.Context) (*JobEducationRequirement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobEducationRequirementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobEducationRequirementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobEducationRequirement entities.
func (m *JobEducationRequirementMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobEducationRequirementMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobEducationRequirementMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobEducationRequirement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobEducationRequirementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobEducationRequirementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobEducationRequirement entity.
// If the JobEducationRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobEducationRequirementMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobEducationRequirementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobeducationrequirement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobEducationRequirementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobeducationrequirement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobEducationRequirementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobeducationrequirement.FieldDeletedAt)
}

// SetJobID sets the "job_id" field.
func (m *JobEducationRequirementMutation) SetJobID(u uuid.UUID) {
	m.job = &u
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *JobEducationRequirementMutation) JobID() (r uuid.UUID, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the JobEducationRequirement entity.
// If the JobEducationRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobEducationRequirementMutation) OldJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *JobEducationRequirementMutation) ResetJobID() {
	m.job = nil
}

// SetEducationType sets the "education_type" field.
func (m *JobEducationRequirementMutation) SetEducationType(cet consts.JobEducationType) {
	m.education_type = &cet
}

// EducationType returns the value of the "education_type" field in the mutation.
func (m *JobEducationRequirementMutation) EducationType() (r consts.JobEducationType, exists bool) {
	v := m.education_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationType returns the old "education_type" field's value of the JobEducationRequirement entity.
// If the JobEducationRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobEducationRequirementMutation) OldEducationType(ctx context.Context) (v consts.JobEducationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationType: %w", err)
	}
	return oldValue.EducationType, nil
}

// ClearEducationType clears the value of the "education_type" field.
func (m *JobEducationRequirementMutation) ClearEducationType() {
	m.education_type = nil
	m.clearedFields[jobeducationrequirement.FieldEducationType] = struct{}{}
}

// EducationTypeCleared returns if the "education_type" field was cleared in this mutation.
func (m *JobEducationRequirementMutation) EducationTypeCleared() bool {
	_, ok := m.clearedFields[jobeducationrequirement.FieldEducationType]
	return ok
}

// ResetEducationType resets all changes to the "education_type" field.
func (m *JobEducationRequirementMutation) ResetEducationType() {
	m.education_type = nil
	delete(m.clearedFields, jobeducationrequirement.FieldEducationType)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobEducationRequirementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobEducationRequirementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobEducationRequirement entity.
// If the JobEducationRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobEducationRequirementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobEducationRequirementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobEducationRequirementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobEducationRequirementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobEducationRequirement entity.
// If the JobEducationRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobEducationRequirementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobEducationRequirementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearJob clears the "job" edge to the JobPosition entity.
func (m *JobEducationRequirementMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[jobeducationrequirement.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the JobPosition entity was cleared.
func (m *JobEducationRequirementMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobEducationRequirementMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobEducationRequirementMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the JobEducationRequirementMutation builder.
func (m *JobEducationRequirementMutation) Where(ps ...predicate.JobEducationRequirement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobEducationRequirementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobEducationRequirementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobEducationRequirement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobEducationRequirementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobEducationRequirementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobEducationRequirement).
func (m *JobEducationRequirementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobEducationRequirementMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.deleted_at != nil {
		fields = append(fields, jobeducationrequirement.FieldDeletedAt)
	}
	if m.job != nil {
		fields = append(fields, jobeducationrequirement.FieldJobID)
	}
	if m.education_type != nil {
		fields = append(fields, jobeducationrequirement.FieldEducationType)
	}
	if m.created_at != nil {
		fields = append(fields, jobeducationrequirement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobeducationrequirement.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobEducationRequirementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobeducationrequirement.FieldDeletedAt:
		return m.DeletedAt()
	case jobeducationrequirement.FieldJobID:
		return m.JobID()
	case jobeducationrequirement.FieldEducationType:
		return m.EducationType()
	case jobeducationrequirement.FieldCreatedAt:
		return m.CreatedAt()
	case jobeducationrequirement.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobEducationRequirementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobeducationrequirement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobeducationrequirement.FieldJobID:
		return m.OldJobID(ctx)
	case jobeducationrequirement.FieldEducationType:
		return m.OldEducationType(ctx)
	case jobeducationrequirement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobeducationrequirement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobEducationRequirement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobEducationRequirementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobeducationrequirement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobeducationrequirement.FieldJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case jobeducationrequirement.FieldEducationType:
		v, ok := value.(consts.JobEducationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationType(v)
		return nil
	case jobeducationrequirement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobeducationrequirement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobEducationRequirement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobEducationRequirementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobEducationRequirementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobEducationRequirementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobEducationRequirement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobEducationRequirementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobeducationrequirement.FieldDeletedAt) {
		fields = append(fields, jobeducationrequirement.FieldDeletedAt)
	}
	if m.FieldCleared(jobeducationrequirement.FieldEducationType) {
		fields = append(fields, jobeducationrequirement.FieldEducationType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobEducationRequirementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobEducationRequirementMutation) ClearField(name string) error {
	switch name {
	case jobeducationrequirement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case jobeducationrequirement.FieldEducationType:
		m.ClearEducationType()
		return nil
	}
	return fmt.Errorf("unknown JobEducationRequirement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobEducationRequirementMutation) ResetField(name string) error {
	switch name {
	case jobeducationrequirement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobeducationrequirement.FieldJobID:
		m.ResetJobID()
		return nil
	case jobeducationrequirement.FieldEducationType:
		m.ResetEducationType()
		return nil
	case jobeducationrequirement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobeducationrequirement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobEducationRequirement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobEducationRequirementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, jobeducationrequirement.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobEducationRequirementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobeducationrequirement.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobEducationRequirementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobEducationRequirementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobEducationRequirementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, jobeducationrequirement.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobEducationRequirementMutation) EdgeCleared(name string) bool {
	switch name {
	case jobeducationrequirement.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobEducationRequirementMutation) ClearEdge(name string) error {
	switch name {
	case jobeducationrequirement.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown JobEducationRequirement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobEducationRequirementMutation) ResetEdge(name string) error {
	switch name {
	case jobeducationrequirement.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown JobEducationRequirement edge %s", name)
}

// JobExperienceRequirementMutation represents an operation that mutates the JobExperienceRequirement nodes in the graph.
type JobExperienceRequirementMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	deleted_at      *time.Time
	experience_type *string
	min_years       *int
	addmin_years    *int
	ideal_years     *int
	addideal_years  *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	job             *uuid.UUID
	clearedjob      bool
	done            bool
	oldValue        func(context.Context) (*JobExperienceRequirement, error)
	predicates      []predicate.JobExperienceRequirement
}

var _ ent.Mutation = (*JobExperienceRequirementMutation)(nil)

// jobexperiencerequirementOption allows management of the mutation configuration using functional options.
type jobexperiencerequirementOption func(*JobExperienceRequirementMutation)

// newJobExperienceRequirementMutation creates new mutation for the JobExperienceRequirement entity.
func newJobExperienceRequirementMutation(c config, op Op, opts ...jobexperiencerequirementOption) *JobExperienceRequirementMutation {
	m := &JobExperienceRequirementMutation{
		config:        c,
		op:            op,
		typ:           TypeJobExperienceRequirement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobExperienceRequirementID sets the ID field of the mutation.
func withJobExperienceRequirementID(id uuid.UUID) jobexperiencerequirementOption {
	return func(m *JobExperienceRequirementMutation) {
		var (
			err   error
			once  sync.Once
			value *JobExperienceRequirement
		)
		m.oldValue = func(ctx context.Context) (*JobExperienceRequirement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobExperienceRequirement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobExperienceRequirement sets the old JobExperienceRequirement of the mutation.
func withJobExperienceRequirement(node *JobExperienceRequirement) jobexperiencerequirementOption {
	return func(m *JobExperienceRequirementMutation) {
		m.oldValue = func(context.Context) (*JobExperienceRequirement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobExperienceRequirementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobExperienceRequirementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobExperienceRequirement entities.
func (m *JobExperienceRequirementMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobExperienceRequirementMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobExperienceRequirementMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobExperienceRequirement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobExperienceRequirementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobExperienceRequirementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobExperienceRequirement entity.
// If the JobExperienceRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExperienceRequirementMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobExperienceRequirementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobexperiencerequirement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobExperienceRequirementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobexperiencerequirement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobExperienceRequirementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobexperiencerequirement.FieldDeletedAt)
}

// SetJobID sets the "job_id" field.
func (m *JobExperienceRequirementMutation) SetJobID(u uuid.UUID) {
	m.job = &u
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *JobExperienceRequirementMutation) JobID() (r uuid.UUID, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the JobExperienceRequirement entity.
// If the JobExperienceRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExperienceRequirementMutation) OldJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *JobExperienceRequirementMutation) ResetJobID() {
	m.job = nil
}

// SetExperienceType sets the "experience_type" field.
func (m *JobExperienceRequirementMutation) SetExperienceType(s string) {
	m.experience_type = &s
}

// ExperienceType returns the value of the "experience_type" field in the mutation.
func (m *JobExperienceRequirementMutation) ExperienceType() (r string, exists bool) {
	v := m.experience_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceType returns the old "experience_type" field's value of the JobExperienceRequirement entity.
// If the JobExperienceRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExperienceRequirementMutation) OldExperienceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceType: %w", err)
	}
	return oldValue.ExperienceType, nil
}

// ClearExperienceType clears the value of the "experience_type" field.
func (m *JobExperienceRequirementMutation) ClearExperienceType() {
	m.experience_type = nil
	m.clearedFields[jobexperiencerequirement.FieldExperienceType] = struct{}{}
}

// ExperienceTypeCleared returns if the "experience_type" field was cleared in this mutation.
func (m *JobExperienceRequirementMutation) ExperienceTypeCleared() bool {
	_, ok := m.clearedFields[jobexperiencerequirement.FieldExperienceType]
	return ok
}

// ResetExperienceType resets all changes to the "experience_type" field.
func (m *JobExperienceRequirementMutation) ResetExperienceType() {
	m.experience_type = nil
	delete(m.clearedFields, jobexperiencerequirement.FieldExperienceType)
}

// SetMinYears sets the "min_years" field.
func (m *JobExperienceRequirementMutation) SetMinYears(i int) {
	m.min_years = &i
	m.addmin_years = nil
}

// MinYears returns the value of the "min_years" field in the mutation.
func (m *JobExperienceRequirementMutation) MinYears() (r int, exists bool) {
	v := m.min_years
	if v == nil {
		return
	}
	return *v, true
}

// OldMinYears returns the old "min_years" field's value of the JobExperienceRequirement entity.
// If the JobExperienceRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExperienceRequirementMutation) OldMinYears(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinYears: %w", err)
	}
	return oldValue.MinYears, nil
}

// AddMinYears adds i to the "min_years" field.
func (m *JobExperienceRequirementMutation) AddMinYears(i int) {
	if m.addmin_years != nil {
		*m.addmin_years += i
	} else {
		m.addmin_years = &i
	}
}

// AddedMinYears returns the value that was added to the "min_years" field in this mutation.
func (m *JobExperienceRequirementMutation) AddedMinYears() (r int, exists bool) {
	v := m.addmin_years
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinYears clears the value of the "min_years" field.
func (m *JobExperienceRequirementMutation) ClearMinYears() {
	m.min_years = nil
	m.addmin_years = nil
	m.clearedFields[jobexperiencerequirement.FieldMinYears] = struct{}{}
}

// MinYearsCleared returns if the "min_years" field was cleared in this mutation.
func (m *JobExperienceRequirementMutation) MinYearsCleared() bool {
	_, ok := m.clearedFields[jobexperiencerequirement.FieldMinYears]
	return ok
}

// ResetMinYears resets all changes to the "min_years" field.
func (m *JobExperienceRequirementMutation) ResetMinYears() {
	m.min_years = nil
	m.addmin_years = nil
	delete(m.clearedFields, jobexperiencerequirement.FieldMinYears)
}

// SetIdealYears sets the "ideal_years" field.
func (m *JobExperienceRequirementMutation) SetIdealYears(i int) {
	m.ideal_years = &i
	m.addideal_years = nil
}

// IdealYears returns the value of the "ideal_years" field in the mutation.
func (m *JobExperienceRequirementMutation) IdealYears() (r int, exists bool) {
	v := m.ideal_years
	if v == nil {
		return
	}
	return *v, true
}

// OldIdealYears returns the old "ideal_years" field's value of the JobExperienceRequirement entity.
// If the JobExperienceRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExperienceRequirementMutation) OldIdealYears(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdealYears is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdealYears requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdealYears: %w", err)
	}
	return oldValue.IdealYears, nil
}

// AddIdealYears adds i to the "ideal_years" field.
func (m *JobExperienceRequirementMutation) AddIdealYears(i int) {
	if m.addideal_years != nil {
		*m.addideal_years += i
	} else {
		m.addideal_years = &i
	}
}

// AddedIdealYears returns the value that was added to the "ideal_years" field in this mutation.
func (m *JobExperienceRequirementMutation) AddedIdealYears() (r int, exists bool) {
	v := m.addideal_years
	if v == nil {
		return
	}
	return *v, true
}

// ClearIdealYears clears the value of the "ideal_years" field.
func (m *JobExperienceRequirementMutation) ClearIdealYears() {
	m.ideal_years = nil
	m.addideal_years = nil
	m.clearedFields[jobexperiencerequirement.FieldIdealYears] = struct{}{}
}

// IdealYearsCleared returns if the "ideal_years" field was cleared in this mutation.
func (m *JobExperienceRequirementMutation) IdealYearsCleared() bool {
	_, ok := m.clearedFields[jobexperiencerequirement.FieldIdealYears]
	return ok
}

// ResetIdealYears resets all changes to the "ideal_years" field.
func (m *JobExperienceRequirementMutation) ResetIdealYears() {
	m.ideal_years = nil
	m.addideal_years = nil
	delete(m.clearedFields, jobexperiencerequirement.FieldIdealYears)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobExperienceRequirementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobExperienceRequirementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobExperienceRequirement entity.
// If the JobExperienceRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExperienceRequirementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobExperienceRequirementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobExperienceRequirementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobExperienceRequirementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobExperienceRequirement entity.
// If the JobExperienceRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobExperienceRequirementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobExperienceRequirementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearJob clears the "job" edge to the JobPosition entity.
func (m *JobExperienceRequirementMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[jobexperiencerequirement.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the JobPosition entity was cleared.
func (m *JobExperienceRequirementMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobExperienceRequirementMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobExperienceRequirementMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the JobExperienceRequirementMutation builder.
func (m *JobExperienceRequirementMutation) Where(ps ...predicate.JobExperienceRequirement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobExperienceRequirementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobExperienceRequirementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobExperienceRequirement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobExperienceRequirementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobExperienceRequirementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobExperienceRequirement).
func (m *JobExperienceRequirementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobExperienceRequirementMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, jobexperiencerequirement.FieldDeletedAt)
	}
	if m.job != nil {
		fields = append(fields, jobexperiencerequirement.FieldJobID)
	}
	if m.experience_type != nil {
		fields = append(fields, jobexperiencerequirement.FieldExperienceType)
	}
	if m.min_years != nil {
		fields = append(fields, jobexperiencerequirement.FieldMinYears)
	}
	if m.ideal_years != nil {
		fields = append(fields, jobexperiencerequirement.FieldIdealYears)
	}
	if m.created_at != nil {
		fields = append(fields, jobexperiencerequirement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobexperiencerequirement.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobExperienceRequirementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobexperiencerequirement.FieldDeletedAt:
		return m.DeletedAt()
	case jobexperiencerequirement.FieldJobID:
		return m.JobID()
	case jobexperiencerequirement.FieldExperienceType:
		return m.ExperienceType()
	case jobexperiencerequirement.FieldMinYears:
		return m.MinYears()
	case jobexperiencerequirement.FieldIdealYears:
		return m.IdealYears()
	case jobexperiencerequirement.FieldCreatedAt:
		return m.CreatedAt()
	case jobexperiencerequirement.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobExperienceRequirementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobexperiencerequirement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobexperiencerequirement.FieldJobID:
		return m.OldJobID(ctx)
	case jobexperiencerequirement.FieldExperienceType:
		return m.OldExperienceType(ctx)
	case jobexperiencerequirement.FieldMinYears:
		return m.OldMinYears(ctx)
	case jobexperiencerequirement.FieldIdealYears:
		return m.OldIdealYears(ctx)
	case jobexperiencerequirement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobexperiencerequirement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobExperienceRequirement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobExperienceRequirementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobexperiencerequirement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobexperiencerequirement.FieldJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case jobexperiencerequirement.FieldExperienceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceType(v)
		return nil
	case jobexperiencerequirement.FieldMinYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinYears(v)
		return nil
	case jobexperiencerequirement.FieldIdealYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdealYears(v)
		return nil
	case jobexperiencerequirement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobexperiencerequirement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobExperienceRequirement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobExperienceRequirementMutation) AddedFields() []string {
	var fields []string
	if m.addmin_years != nil {
		fields = append(fields, jobexperiencerequirement.FieldMinYears)
	}
	if m.addideal_years != nil {
		fields = append(fields, jobexperiencerequirement.FieldIdealYears)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobExperienceRequirementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobexperiencerequirement.FieldMinYears:
		return m.AddedMinYears()
	case jobexperiencerequirement.FieldIdealYears:
		return m.AddedIdealYears()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobExperienceRequirementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobexperiencerequirement.FieldMinYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinYears(v)
		return nil
	case jobexperiencerequirement.FieldIdealYears:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdealYears(v)
		return nil
	}
	return fmt.Errorf("unknown JobExperienceRequirement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobExperienceRequirementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobexperiencerequirement.FieldDeletedAt) {
		fields = append(fields, jobexperiencerequirement.FieldDeletedAt)
	}
	if m.FieldCleared(jobexperiencerequirement.FieldExperienceType) {
		fields = append(fields, jobexperiencerequirement.FieldExperienceType)
	}
	if m.FieldCleared(jobexperiencerequirement.FieldMinYears) {
		fields = append(fields, jobexperiencerequirement.FieldMinYears)
	}
	if m.FieldCleared(jobexperiencerequirement.FieldIdealYears) {
		fields = append(fields, jobexperiencerequirement.FieldIdealYears)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobExperienceRequirementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobExperienceRequirementMutation) ClearField(name string) error {
	switch name {
	case jobexperiencerequirement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case jobexperiencerequirement.FieldExperienceType:
		m.ClearExperienceType()
		return nil
	case jobexperiencerequirement.FieldMinYears:
		m.ClearMinYears()
		return nil
	case jobexperiencerequirement.FieldIdealYears:
		m.ClearIdealYears()
		return nil
	}
	return fmt.Errorf("unknown JobExperienceRequirement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobExperienceRequirementMutation) ResetField(name string) error {
	switch name {
	case jobexperiencerequirement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobexperiencerequirement.FieldJobID:
		m.ResetJobID()
		return nil
	case jobexperiencerequirement.FieldExperienceType:
		m.ResetExperienceType()
		return nil
	case jobexperiencerequirement.FieldMinYears:
		m.ResetMinYears()
		return nil
	case jobexperiencerequirement.FieldIdealYears:
		m.ResetIdealYears()
		return nil
	case jobexperiencerequirement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobexperiencerequirement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobExperienceRequirement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobExperienceRequirementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, jobexperiencerequirement.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobExperienceRequirementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobexperiencerequirement.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobExperienceRequirementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobExperienceRequirementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobExperienceRequirementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, jobexperiencerequirement.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobExperienceRequirementMutation) EdgeCleared(name string) bool {
	switch name {
	case jobexperiencerequirement.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobExperienceRequirementMutation) ClearEdge(name string) error {
	switch name {
	case jobexperiencerequirement.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown JobExperienceRequirement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobExperienceRequirementMutation) ResetEdge(name string) error {
	switch name {
	case jobexperiencerequirement.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown JobExperienceRequirement edge %s", name)
}

// JobIndustryRequirementMutation represents an operation that mutates the JobIndustryRequirement nodes in the graph.
type JobIndustryRequirementMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	industry      *string
	company_name  *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	job           *uuid.UUID
	clearedjob    bool
	done          bool
	oldValue      func(context.Context) (*JobIndustryRequirement, error)
	predicates    []predicate.JobIndustryRequirement
}

var _ ent.Mutation = (*JobIndustryRequirementMutation)(nil)

// jobindustryrequirementOption allows management of the mutation configuration using functional options.
type jobindustryrequirementOption func(*JobIndustryRequirementMutation)

// newJobIndustryRequirementMutation creates new mutation for the JobIndustryRequirement entity.
func newJobIndustryRequirementMutation(c config, op Op, opts ...jobindustryrequirementOption) *JobIndustryRequirementMutation {
	m := &JobIndustryRequirementMutation{
		config:        c,
		op:            op,
		typ:           TypeJobIndustryRequirement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobIndustryRequirementID sets the ID field of the mutation.
func withJobIndustryRequirementID(id uuid.UUID) jobindustryrequirementOption {
	return func(m *JobIndustryRequirementMutation) {
		var (
			err   error
			once  sync.Once
			value *JobIndustryRequirement
		)
		m.oldValue = func(ctx context.Context) (*JobIndustryRequirement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobIndustryRequirement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobIndustryRequirement sets the old JobIndustryRequirement of the mutation.
func withJobIndustryRequirement(node *JobIndustryRequirement) jobindustryrequirementOption {
	return func(m *JobIndustryRequirementMutation) {
		m.oldValue = func(context.Context) (*JobIndustryRequirement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobIndustryRequirementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobIndustryRequirementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobIndustryRequirement entities.
func (m *JobIndustryRequirementMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobIndustryRequirementMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobIndustryRequirementMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobIndustryRequirement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobIndustryRequirementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobIndustryRequirementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobIndustryRequirement entity.
// If the JobIndustryRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobIndustryRequirementMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobIndustryRequirementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobindustryrequirement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobIndustryRequirementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobindustryrequirement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobIndustryRequirementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobindustryrequirement.FieldDeletedAt)
}

// SetJobID sets the "job_id" field.
func (m *JobIndustryRequirementMutation) SetJobID(u uuid.UUID) {
	m.job = &u
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *JobIndustryRequirementMutation) JobID() (r uuid.UUID, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the JobIndustryRequirement entity.
// If the JobIndustryRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobIndustryRequirementMutation) OldJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *JobIndustryRequirementMutation) ResetJobID() {
	m.job = nil
}

// SetIndustry sets the "industry" field.
func (m *JobIndustryRequirementMutation) SetIndustry(s string) {
	m.industry = &s
}

// Industry returns the value of the "industry" field in the mutation.
func (m *JobIndustryRequirementMutation) Industry() (r string, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the JobIndustryRequirement entity.
// If the JobIndustryRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobIndustryRequirementMutation) OldIndustry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// ClearIndustry clears the value of the "industry" field.
func (m *JobIndustryRequirementMutation) ClearIndustry() {
	m.industry = nil
	m.clearedFields[jobindustryrequirement.FieldIndustry] = struct{}{}
}

// IndustryCleared returns if the "industry" field was cleared in this mutation.
func (m *JobIndustryRequirementMutation) IndustryCleared() bool {
	_, ok := m.clearedFields[jobindustryrequirement.FieldIndustry]
	return ok
}

// ResetIndustry resets all changes to the "industry" field.
func (m *JobIndustryRequirementMutation) ResetIndustry() {
	m.industry = nil
	delete(m.clearedFields, jobindustryrequirement.FieldIndustry)
}

// SetCompanyName sets the "company_name" field.
func (m *JobIndustryRequirementMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *JobIndustryRequirementMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the JobIndustryRequirement entity.
// If the JobIndustryRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobIndustryRequirementMutation) OldCompanyName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ClearCompanyName clears the value of the "company_name" field.
func (m *JobIndustryRequirementMutation) ClearCompanyName() {
	m.company_name = nil
	m.clearedFields[jobindustryrequirement.FieldCompanyName] = struct{}{}
}

// CompanyNameCleared returns if the "company_name" field was cleared in this mutation.
func (m *JobIndustryRequirementMutation) CompanyNameCleared() bool {
	_, ok := m.clearedFields[jobindustryrequirement.FieldCompanyName]
	return ok
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *JobIndustryRequirementMutation) ResetCompanyName() {
	m.company_name = nil
	delete(m.clearedFields, jobindustryrequirement.FieldCompanyName)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobIndustryRequirementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobIndustryRequirementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobIndustryRequirement entity.
// If the JobIndustryRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobIndustryRequirementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobIndustryRequirementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobIndustryRequirementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobIndustryRequirementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobIndustryRequirement entity.
// If the JobIndustryRequirement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobIndustryRequirementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobIndustryRequirementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearJob clears the "job" edge to the JobPosition entity.
func (m *JobIndustryRequirementMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[jobindustryrequirement.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the JobPosition entity was cleared.
func (m *JobIndustryRequirementMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobIndustryRequirementMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobIndustryRequirementMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the JobIndustryRequirementMutation builder.
func (m *JobIndustryRequirementMutation) Where(ps ...predicate.JobIndustryRequirement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobIndustryRequirementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobIndustryRequirementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobIndustryRequirement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobIndustryRequirementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobIndustryRequirementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobIndustryRequirement).
func (m *JobIndustryRequirementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobIndustryRequirementMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, jobindustryrequirement.FieldDeletedAt)
	}
	if m.job != nil {
		fields = append(fields, jobindustryrequirement.FieldJobID)
	}
	if m.industry != nil {
		fields = append(fields, jobindustryrequirement.FieldIndustry)
	}
	if m.company_name != nil {
		fields = append(fields, jobindustryrequirement.FieldCompanyName)
	}
	if m.created_at != nil {
		fields = append(fields, jobindustryrequirement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobindustryrequirement.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobIndustryRequirementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobindustryrequirement.FieldDeletedAt:
		return m.DeletedAt()
	case jobindustryrequirement.FieldJobID:
		return m.JobID()
	case jobindustryrequirement.FieldIndustry:
		return m.Industry()
	case jobindustryrequirement.FieldCompanyName:
		return m.CompanyName()
	case jobindustryrequirement.FieldCreatedAt:
		return m.CreatedAt()
	case jobindustryrequirement.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobIndustryRequirementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobindustryrequirement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobindustryrequirement.FieldJobID:
		return m.OldJobID(ctx)
	case jobindustryrequirement.FieldIndustry:
		return m.OldIndustry(ctx)
	case jobindustryrequirement.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case jobindustryrequirement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobindustryrequirement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobIndustryRequirement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobIndustryRequirementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobindustryrequirement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobindustryrequirement.FieldJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case jobindustryrequirement.FieldIndustry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case jobindustryrequirement.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case jobindustryrequirement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobindustryrequirement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobIndustryRequirement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobIndustryRequirementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobIndustryRequirementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobIndustryRequirementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobIndustryRequirement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobIndustryRequirementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobindustryrequirement.FieldDeletedAt) {
		fields = append(fields, jobindustryrequirement.FieldDeletedAt)
	}
	if m.FieldCleared(jobindustryrequirement.FieldIndustry) {
		fields = append(fields, jobindustryrequirement.FieldIndustry)
	}
	if m.FieldCleared(jobindustryrequirement.FieldCompanyName) {
		fields = append(fields, jobindustryrequirement.FieldCompanyName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobIndustryRequirementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobIndustryRequirementMutation) ClearField(name string) error {
	switch name {
	case jobindustryrequirement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case jobindustryrequirement.FieldIndustry:
		m.ClearIndustry()
		return nil
	case jobindustryrequirement.FieldCompanyName:
		m.ClearCompanyName()
		return nil
	}
	return fmt.Errorf("unknown JobIndustryRequirement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobIndustryRequirementMutation) ResetField(name string) error {
	switch name {
	case jobindustryrequirement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobindustryrequirement.FieldJobID:
		m.ResetJobID()
		return nil
	case jobindustryrequirement.FieldIndustry:
		m.ResetIndustry()
		return nil
	case jobindustryrequirement.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case jobindustryrequirement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobindustryrequirement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobIndustryRequirement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobIndustryRequirementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, jobindustryrequirement.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobIndustryRequirementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobindustryrequirement.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobIndustryRequirementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobIndustryRequirementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobIndustryRequirementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, jobindustryrequirement.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobIndustryRequirementMutation) EdgeCleared(name string) bool {
	switch name {
	case jobindustryrequirement.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobIndustryRequirementMutation) ClearEdge(name string) error {
	switch name {
	case jobindustryrequirement.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown JobIndustryRequirement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobIndustryRequirementMutation) ResetEdge(name string) error {
	switch name {
	case jobindustryrequirement.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown JobIndustryRequirement edge %s", name)
}

// JobPositionMutation represents an operation that mutates the JobPosition nodes in the graph.
type JobPositionMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	deleted_at                     *time.Time
	name                           *string
	status                         *consts.JobPositionStatus
	work_type                      *consts.JobWorkType
	location                       *string
	salary_min                     *float64
	addsalary_min                  *float64
	salary_max                     *float64
	addsalary_max                  *float64
	description                    *string
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	department                     *uuid.UUID
	cleareddepartment              bool
	creator                        *uuid.UUID
	clearedcreator                 bool
	responsibilities               map[uuid.UUID]struct{}
	removedresponsibilities        map[uuid.UUID]struct{}
	clearedresponsibilities        bool
	skills                         map[uuid.UUID]struct{}
	removedskills                  map[uuid.UUID]struct{}
	clearedskills                  bool
	education_requirements         map[uuid.UUID]struct{}
	removededucation_requirements  map[uuid.UUID]struct{}
	clearededucation_requirements  bool
	experience_requirements        map[uuid.UUID]struct{}
	removedexperience_requirements map[uuid.UUID]struct{}
	clearedexperience_requirements bool
	industry_requirements          map[uuid.UUID]struct{}
	removedindustry_requirements   map[uuid.UUID]struct{}
	clearedindustry_requirements   bool
	resume_applications            map[uuid.UUID]struct{}
	removedresume_applications     map[uuid.UUID]struct{}
	clearedresume_applications     bool
	screening_tasks                map[uuid.UUID]struct{}
	removedscreening_tasks         map[uuid.UUID]struct{}
	clearedscreening_tasks         bool
	screening_results              map[uuid.UUID]struct{}
	removedscreening_results       map[uuid.UUID]struct{}
	clearedscreening_results       bool
	done                           bool
	oldValue                       func(context.Context) (*JobPosition, error)
	predicates                     []predicate.JobPosition
}

var _ ent.Mutation = (*JobPositionMutation)(nil)

// jobpositionOption allows management of the mutation configuration using functional options.
type jobpositionOption func(*JobPositionMutation)

// newJobPositionMutation creates new mutation for the JobPosition entity.
func newJobPositionMutation(c config, op Op, opts ...jobpositionOption) *JobPositionMutation {
	m := &JobPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeJobPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobPositionID sets the ID field of the mutation.
func withJobPositionID(id uuid.UUID) jobpositionOption {
	return func(m *JobPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *JobPosition
		)
		m.oldValue = func(ctx context.Context) (*JobPosition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobPosition sets the old JobPosition of the mutation.
func withJobPosition(node *JobPosition) jobpositionOption {
	return func(m *JobPositionMutation) {
		m.oldValue = func(context.Context) (*JobPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobPosition entities.
func (m *JobPositionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobPositionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobPositionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobPosition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobPositionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobPositionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobPositionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobposition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobPositionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobPositionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobposition.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *JobPositionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JobPositionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JobPositionMutation) ResetName() {
	m.name = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *JobPositionMutation) SetDepartmentID(u uuid.UUID) {
	m.department = &u
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *JobPositionMutation) DepartmentID() (r uuid.UUID, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldDepartmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *JobPositionMutation) ResetDepartmentID() {
	m.department = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *JobPositionMutation) SetCreatedBy(u uuid.UUID) {
	m.creator = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *JobPositionMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldCreatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *JobPositionMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[jobposition.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *JobPositionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *JobPositionMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, jobposition.FieldCreatedBy)
}

// SetStatus sets the "status" field.
func (m *JobPositionMutation) SetStatus(cps consts.JobPositionStatus) {
	m.status = &cps
}

// Status returns the value of the "status" field in the mutation.
func (m *JobPositionMutation) Status() (r consts.JobPositionStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldStatus(ctx context.Context) (v consts.JobPositionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobPositionMutation) ResetStatus() {
	m.status = nil
}

// SetWorkType sets the "work_type" field.
func (m *JobPositionMutation) SetWorkType(cwt consts.JobWorkType) {
	m.work_type = &cwt
}

// WorkType returns the value of the "work_type" field in the mutation.
func (m *JobPositionMutation) WorkType() (r consts.JobWorkType, exists bool) {
	v := m.work_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkType returns the old "work_type" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldWorkType(ctx context.Context) (v consts.JobWorkType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkType: %w", err)
	}
	return oldValue.WorkType, nil
}

// ClearWorkType clears the value of the "work_type" field.
func (m *JobPositionMutation) ClearWorkType() {
	m.work_type = nil
	m.clearedFields[jobposition.FieldWorkType] = struct{}{}
}

// WorkTypeCleared returns if the "work_type" field was cleared in this mutation.
func (m *JobPositionMutation) WorkTypeCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldWorkType]
	return ok
}

// ResetWorkType resets all changes to the "work_type" field.
func (m *JobPositionMutation) ResetWorkType() {
	m.work_type = nil
	delete(m.clearedFields, jobposition.FieldWorkType)
}

// SetLocation sets the "location" field.
func (m *JobPositionMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *JobPositionMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *JobPositionMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[jobposition.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *JobPositionMutation) LocationCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *JobPositionMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, jobposition.FieldLocation)
}

// SetSalaryMin sets the "salary_min" field.
func (m *JobPositionMutation) SetSalaryMin(f float64) {
	m.salary_min = &f
	m.addsalary_min = nil
}

// SalaryMin returns the value of the "salary_min" field in the mutation.
func (m *JobPositionMutation) SalaryMin() (r float64, exists bool) {
	v := m.salary_min
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryMin returns the old "salary_min" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldSalaryMin(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryMin: %w", err)
	}
	return oldValue.SalaryMin, nil
}

// AddSalaryMin adds f to the "salary_min" field.
func (m *JobPositionMutation) AddSalaryMin(f float64) {
	if m.addsalary_min != nil {
		*m.addsalary_min += f
	} else {
		m.addsalary_min = &f
	}
}

// AddedSalaryMin returns the value that was added to the "salary_min" field in this mutation.
func (m *JobPositionMutation) AddedSalaryMin() (r float64, exists bool) {
	v := m.addsalary_min
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalaryMin clears the value of the "salary_min" field.
func (m *JobPositionMutation) ClearSalaryMin() {
	m.salary_min = nil
	m.addsalary_min = nil
	m.clearedFields[jobposition.FieldSalaryMin] = struct{}{}
}

// SalaryMinCleared returns if the "salary_min" field was cleared in this mutation.
func (m *JobPositionMutation) SalaryMinCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldSalaryMin]
	return ok
}

// ResetSalaryMin resets all changes to the "salary_min" field.
func (m *JobPositionMutation) ResetSalaryMin() {
	m.salary_min = nil
	m.addsalary_min = nil
	delete(m.clearedFields, jobposition.FieldSalaryMin)
}

// SetSalaryMax sets the "salary_max" field.
func (m *JobPositionMutation) SetSalaryMax(f float64) {
	m.salary_max = &f
	m.addsalary_max = nil
}

// SalaryMax returns the value of the "salary_max" field in the mutation.
func (m *JobPositionMutation) SalaryMax() (r float64, exists bool) {
	v := m.salary_max
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryMax returns the old "salary_max" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldSalaryMax(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryMax: %w", err)
	}
	return oldValue.SalaryMax, nil
}

// AddSalaryMax adds f to the "salary_max" field.
func (m *JobPositionMutation) AddSalaryMax(f float64) {
	if m.addsalary_max != nil {
		*m.addsalary_max += f
	} else {
		m.addsalary_max = &f
	}
}

// AddedSalaryMax returns the value that was added to the "salary_max" field in this mutation.
func (m *JobPositionMutation) AddedSalaryMax() (r float64, exists bool) {
	v := m.addsalary_max
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalaryMax clears the value of the "salary_max" field.
func (m *JobPositionMutation) ClearSalaryMax() {
	m.salary_max = nil
	m.addsalary_max = nil
	m.clearedFields[jobposition.FieldSalaryMax] = struct{}{}
}

// SalaryMaxCleared returns if the "salary_max" field was cleared in this mutation.
func (m *JobPositionMutation) SalaryMaxCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldSalaryMax]
	return ok
}

// ResetSalaryMax resets all changes to the "salary_max" field.
func (m *JobPositionMutation) ResetSalaryMax() {
	m.salary_max = nil
	m.addsalary_max = nil
	delete(m.clearedFields, jobposition.FieldSalaryMax)
}

// SetDescription sets the "description" field.
func (m *JobPositionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JobPositionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *JobPositionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[jobposition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *JobPositionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *JobPositionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, jobposition.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobPositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobPositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobPositionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobPositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobPositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobPositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *JobPositionMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[jobposition.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *JobPositionMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *JobPositionMutation) DepartmentIDs() (ids []uuid.UUID) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *JobPositionMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *JobPositionMutation) SetCreatorID(id uuid.UUID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *JobPositionMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[jobposition.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *JobPositionMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *JobPositionMutation) CreatorID() (id uuid.UUID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *JobPositionMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *JobPositionMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddResponsibilityIDs adds the "responsibilities" edge to the JobResponsibility entity by ids.
func (m *JobPositionMutation) AddResponsibilityIDs(ids ...uuid.UUID) {
	if m.responsibilities == nil {
		m.responsibilities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.responsibilities[ids[i]] = struct{}{}
	}
}

// ClearResponsibilities clears the "responsibilities" edge to the JobResponsibility entity.
func (m *JobPositionMutation) ClearResponsibilities() {
	m.clearedresponsibilities = true
}

// ResponsibilitiesCleared reports if the "responsibilities" edge to the JobResponsibility entity was cleared.
func (m *JobPositionMutation) ResponsibilitiesCleared() bool {
	return m.clearedresponsibilities
}

// RemoveResponsibilityIDs removes the "responsibilities" edge to the JobResponsibility entity by IDs.
func (m *JobPositionMutation) RemoveResponsibilityIDs(ids ...uuid.UUID) {
	if m.removedresponsibilities == nil {
		m.removedresponsibilities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.responsibilities, ids[i])
		m.removedresponsibilities[ids[i]] = struct{}{}
	}
}

// RemovedResponsibilities returns the removed IDs of the "responsibilities" edge to the JobResponsibility entity.
func (m *JobPositionMutation) RemovedResponsibilitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedresponsibilities {
		ids = append(ids, id)
	}
	return
}

// ResponsibilitiesIDs returns the "responsibilities" edge IDs in the mutation.
func (m *JobPositionMutation) ResponsibilitiesIDs() (ids []uuid.UUID) {
	for id := range m.responsibilities {
		ids = append(ids, id)
	}
	return
}

// ResetResponsibilities resets all changes to the "responsibilities" edge.
func (m *JobPositionMutation) ResetResponsibilities() {
	m.responsibilities = nil
	m.clearedresponsibilities = false
	m.removedresponsibilities = nil
}

// AddSkillIDs adds the "skills" edge to the JobSkill entity by ids.
func (m *JobPositionMutation) AddSkillIDs(ids ...uuid.UUID) {
	if m.skills == nil {
		m.skills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the JobSkill entity.
func (m *JobPositionMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the JobSkill entity was cleared.
func (m *JobPositionMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the JobSkill entity by IDs.
func (m *JobPositionMutation) RemoveSkillIDs(ids ...uuid.UUID) {
	if m.removedskills == nil {
		m.removedskills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the JobSkill entity.
func (m *JobPositionMutation) RemovedSkillsIDs() (ids []uuid.UUID) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *JobPositionMutation) SkillsIDs() (ids []uuid.UUID) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *JobPositionMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// AddEducationRequirementIDs adds the "education_requirements" edge to the JobEducationRequirement entity by ids.
func (m *JobPositionMutation) AddEducationRequirementIDs(ids ...uuid.UUID) {
	if m.education_requirements == nil {
		m.education_requirements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.education_requirements[ids[i]] = struct{}{}
	}
}

// ClearEducationRequirements clears the "education_requirements" edge to the JobEducationRequirement entity.
func (m *JobPositionMutation) ClearEducationRequirements() {
	m.clearededucation_requirements = true
}

// EducationRequirementsCleared reports if the "education_requirements" edge to the JobEducationRequirement entity was cleared.
func (m *JobPositionMutation) EducationRequirementsCleared() bool {
	return m.clearededucation_requirements
}

// RemoveEducationRequirementIDs removes the "education_requirements" edge to the JobEducationRequirement entity by IDs.
func (m *JobPositionMutation) RemoveEducationRequirementIDs(ids ...uuid.UUID) {
	if m.removededucation_requirements == nil {
		m.removededucation_requirements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.education_requirements, ids[i])
		m.removededucation_requirements[ids[i]] = struct{}{}
	}
}

// RemovedEducationRequirements returns the removed IDs of the "education_requirements" edge to the JobEducationRequirement entity.
func (m *JobPositionMutation) RemovedEducationRequirementsIDs() (ids []uuid.UUID) {
	for id := range m.removededucation_requirements {
		ids = append(ids, id)
	}
	return
}

// EducationRequirementsIDs returns the "education_requirements" edge IDs in the mutation.
func (m *JobPositionMutation) EducationRequirementsIDs() (ids []uuid.UUID) {
	for id := range m.education_requirements {
		ids = append(ids, id)
	}
	return
}

// ResetEducationRequirements resets all changes to the "education_requirements" edge.
func (m *JobPositionMutation) ResetEducationRequirements() {
	m.education_requirements = nil
	m.clearededucation_requirements = false
	m.removededucation_requirements = nil
}

// AddExperienceRequirementIDs adds the "experience_requirements" edge to the JobExperienceRequirement entity by ids.
func (m *JobPositionMutation) AddExperienceRequirementIDs(ids ...uuid.UUID) {
	if m.experience_requirements == nil {
		m.experience_requirements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.experience_requirements[ids[i]] = struct{}{}
	}
}

// ClearExperienceRequirements clears the "experience_requirements" edge to the JobExperienceRequirement entity.
func (m *JobPositionMutation) ClearExperienceRequirements() {
	m.clearedexperience_requirements = true
}

// ExperienceRequirementsCleared reports if the "experience_requirements" edge to the JobExperienceRequirement entity was cleared.
func (m *JobPositionMutation) ExperienceRequirementsCleared() bool {
	return m.clearedexperience_requirements
}

// RemoveExperienceRequirementIDs removes the "experience_requirements" edge to the JobExperienceRequirement entity by IDs.
func (m *JobPositionMutation) RemoveExperienceRequirementIDs(ids ...uuid.UUID) {
	if m.removedexperience_requirements == nil {
		m.removedexperience_requirements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.experience_requirements, ids[i])
		m.removedexperience_requirements[ids[i]] = struct{}{}
	}
}

// RemovedExperienceRequirements returns the removed IDs of the "experience_requirements" edge to the JobExperienceRequirement entity.
func (m *JobPositionMutation) RemovedExperienceRequirementsIDs() (ids []uuid.UUID) {
	for id := range m.removedexperience_requirements {
		ids = append(ids, id)
	}
	return
}

// ExperienceRequirementsIDs returns the "experience_requirements" edge IDs in the mutation.
func (m *JobPositionMutation) ExperienceRequirementsIDs() (ids []uuid.UUID) {
	for id := range m.experience_requirements {
		ids = append(ids, id)
	}
	return
}

// ResetExperienceRequirements resets all changes to the "experience_requirements" edge.
func (m *JobPositionMutation) ResetExperienceRequirements() {
	m.experience_requirements = nil
	m.clearedexperience_requirements = false
	m.removedexperience_requirements = nil
}

// AddIndustryRequirementIDs adds the "industry_requirements" edge to the JobIndustryRequirement entity by ids.
func (m *JobPositionMutation) AddIndustryRequirementIDs(ids ...uuid.UUID) {
	if m.industry_requirements == nil {
		m.industry_requirements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.industry_requirements[ids[i]] = struct{}{}
	}
}

// ClearIndustryRequirements clears the "industry_requirements" edge to the JobIndustryRequirement entity.
func (m *JobPositionMutation) ClearIndustryRequirements() {
	m.clearedindustry_requirements = true
}

// IndustryRequirementsCleared reports if the "industry_requirements" edge to the JobIndustryRequirement entity was cleared.
func (m *JobPositionMutation) IndustryRequirementsCleared() bool {
	return m.clearedindustry_requirements
}

// RemoveIndustryRequirementIDs removes the "industry_requirements" edge to the JobIndustryRequirement entity by IDs.
func (m *JobPositionMutation) RemoveIndustryRequirementIDs(ids ...uuid.UUID) {
	if m.removedindustry_requirements == nil {
		m.removedindustry_requirements = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.industry_requirements, ids[i])
		m.removedindustry_requirements[ids[i]] = struct{}{}
	}
}

// RemovedIndustryRequirements returns the removed IDs of the "industry_requirements" edge to the JobIndustryRequirement entity.
func (m *JobPositionMutation) RemovedIndustryRequirementsIDs() (ids []uuid.UUID) {
	for id := range m.removedindustry_requirements {
		ids = append(ids, id)
	}
	return
}

// IndustryRequirementsIDs returns the "industry_requirements" edge IDs in the mutation.
func (m *JobPositionMutation) IndustryRequirementsIDs() (ids []uuid.UUID) {
	for id := range m.industry_requirements {
		ids = append(ids, id)
	}
	return
}

// ResetIndustryRequirements resets all changes to the "industry_requirements" edge.
func (m *JobPositionMutation) ResetIndustryRequirements() {
	m.industry_requirements = nil
	m.clearedindustry_requirements = false
	m.removedindustry_requirements = nil
}

// AddResumeApplicationIDs adds the "resume_applications" edge to the ResumeJobApplication entity by ids.
func (m *JobPositionMutation) AddResumeApplicationIDs(ids ...uuid.UUID) {
	if m.resume_applications == nil {
		m.resume_applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.resume_applications[ids[i]] = struct{}{}
	}
}

// ClearResumeApplications clears the "resume_applications" edge to the ResumeJobApplication entity.
func (m *JobPositionMutation) ClearResumeApplications() {
	m.clearedresume_applications = true
}

// ResumeApplicationsCleared reports if the "resume_applications" edge to the ResumeJobApplication entity was cleared.
func (m *JobPositionMutation) ResumeApplicationsCleared() bool {
	return m.clearedresume_applications
}

// RemoveResumeApplicationIDs removes the "resume_applications" edge to the ResumeJobApplication entity by IDs.
func (m *JobPositionMutation) RemoveResumeApplicationIDs(ids ...uuid.UUID) {
	if m.removedresume_applications == nil {
		m.removedresume_applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.resume_applications, ids[i])
		m.removedresume_applications[ids[i]] = struct{}{}
	}
}

// RemovedResumeApplications returns the removed IDs of the "resume_applications" edge to the ResumeJobApplication entity.
func (m *JobPositionMutation) RemovedResumeApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedresume_applications {
		ids = append(ids, id)
	}
	return
}

// ResumeApplicationsIDs returns the "resume_applications" edge IDs in the mutation.
func (m *JobPositionMutation) ResumeApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.resume_applications {
		ids = append(ids, id)
	}
	return
}

// ResetResumeApplications resets all changes to the "resume_applications" edge.
func (m *JobPositionMutation) ResetResumeApplications() {
	m.resume_applications = nil
	m.clearedresume_applications = false
	m.removedresume_applications = nil
}

// AddScreeningTaskIDs adds the "screening_tasks" edge to the ScreeningTask entity by ids.
func (m *JobPositionMutation) AddScreeningTaskIDs(ids ...uuid.UUID) {
	if m.screening_tasks == nil {
		m.screening_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.screening_tasks[ids[i]] = struct{}{}
	}
}

// ClearScreeningTasks clears the "screening_tasks" edge to the ScreeningTask entity.
func (m *JobPositionMutation) ClearScreeningTasks() {
	m.clearedscreening_tasks = true
}

// ScreeningTasksCleared reports if the "screening_tasks" edge to the ScreeningTask entity was cleared.
func (m *JobPositionMutation) ScreeningTasksCleared() bool {
	return m.clearedscreening_tasks
}

// RemoveScreeningTaskIDs removes the "screening_tasks" edge to the ScreeningTask entity by IDs.
func (m *JobPositionMutation) RemoveScreeningTaskIDs(ids ...uuid.UUID) {
	if m.removedscreening_tasks == nil {
		m.removedscreening_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.screening_tasks, ids[i])
		m.removedscreening_tasks[ids[i]] = struct{}{}
	}
}

// RemovedScreeningTasks returns the removed IDs of the "screening_tasks" edge to the ScreeningTask entity.
func (m *JobPositionMutation) RemovedScreeningTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedscreening_tasks {
		ids = append(ids, id)
	}
	return
}

// ScreeningTasksIDs returns the "screening_tasks" edge IDs in the mutation.
func (m *JobPositionMutation) ScreeningTasksIDs() (ids []uuid.UUID) {
	for id := range m.screening_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetScreeningTasks resets all changes to the "screening_tasks" edge.
func (m *JobPositionMutation) ResetScreeningTasks() {
	m.screening_tasks = nil
	m.clearedscreening_tasks = false
	m.removedscreening_tasks = nil
}

// AddScreeningResultIDs adds the "screening_results" edge to the ScreeningResult entity by ids.
func (m *JobPositionMutation) AddScreeningResultIDs(ids ...uuid.UUID) {
	if m.screening_results == nil {
		m.screening_results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.screening_results[ids[i]] = struct{}{}
	}
}

// ClearScreeningResults clears the "screening_results" edge to the ScreeningResult entity.
func (m *JobPositionMutation) ClearScreeningResults() {
	m.clearedscreening_results = true
}

// ScreeningResultsCleared reports if the "screening_results" edge to the ScreeningResult entity was cleared.
func (m *JobPositionMutation) ScreeningResultsCleared() bool {
	return m.clearedscreening_results
}

// RemoveScreeningResultIDs removes the "screening_results" edge to the ScreeningResult entity by IDs.
func (m *JobPositionMutation) RemoveScreeningResultIDs(ids ...uuid.UUID) {
	if m.removedscreening_results == nil {
		m.removedscreening_results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.screening_results, ids[i])
		m.removedscreening_results[ids[i]] = struct{}{}
	}
}

// RemovedScreeningResults returns the removed IDs of the "screening_results" edge to the ScreeningResult entity.
func (m *JobPositionMutation) RemovedScreeningResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedscreening_results {
		ids = append(ids, id)
	}
	return
}

// ScreeningResultsIDs returns the "screening_results" edge IDs in the mutation.
func (m *JobPositionMutation) ScreeningResultsIDs() (ids []uuid.UUID) {
	for id := range m.screening_results {
		ids = append(ids, id)
	}
	return
}

// ResetScreeningResults resets all changes to the "screening_results" edge.
func (m *JobPositionMutation) ResetScreeningResults() {
	m.screening_results = nil
	m.clearedscreening_results = false
	m.removedscreening_results = nil
}

// Where appends a list predicates to the JobPositionMutation builder.
func (m *JobPositionMutation) Where(ps ...predicate.JobPosition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobPositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobPositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobPosition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobPositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobPositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobPosition).
func (m *JobPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobPositionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.deleted_at != nil {
		fields = append(fields, jobposition.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, jobposition.FieldName)
	}
	if m.department != nil {
		fields = append(fields, jobposition.FieldDepartmentID)
	}
	if m.creator != nil {
		fields = append(fields, jobposition.FieldCreatedBy)
	}
	if m.status != nil {
		fields = append(fields, jobposition.FieldStatus)
	}
	if m.work_type != nil {
		fields = append(fields, jobposition.FieldWorkType)
	}
	if m.location != nil {
		fields = append(fields, jobposition.FieldLocation)
	}
	if m.salary_min != nil {
		fields = append(fields, jobposition.FieldSalaryMin)
	}
	if m.salary_max != nil {
		fields = append(fields, jobposition.FieldSalaryMax)
	}
	if m.description != nil {
		fields = append(fields, jobposition.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, jobposition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobposition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobposition.FieldDeletedAt:
		return m.DeletedAt()
	case jobposition.FieldName:
		return m.Name()
	case jobposition.FieldDepartmentID:
		return m.DepartmentID()
	case jobposition.FieldCreatedBy:
		return m.CreatedBy()
	case jobposition.FieldStatus:
		return m.Status()
	case jobposition.FieldWorkType:
		return m.WorkType()
	case jobposition.FieldLocation:
		return m.Location()
	case jobposition.FieldSalaryMin:
		return m.SalaryMin()
	case jobposition.FieldSalaryMax:
		return m.SalaryMax()
	case jobposition.FieldDescription:
		return m.Description()
	case jobposition.FieldCreatedAt:
		return m.CreatedAt()
	case jobposition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobposition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobposition.FieldName:
		return m.OldName(ctx)
	case jobposition.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case jobposition.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case jobposition.FieldStatus:
		return m.OldStatus(ctx)
	case jobposition.FieldWorkType:
		return m.OldWorkType(ctx)
	case jobposition.FieldLocation:
		return m.OldLocation(ctx)
	case jobposition.FieldSalaryMin:
		return m.OldSalaryMin(ctx)
	case jobposition.FieldSalaryMax:
		return m.OldSalaryMax(ctx)
	case jobposition.FieldDescription:
		return m.OldDescription(ctx)
	case jobposition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobposition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobPosition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobposition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobposition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jobposition.FieldDepartmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case jobposition.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case jobposition.FieldStatus:
		v, ok := value.(consts.JobPositionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jobposition.FieldWorkType:
		v, ok := value.(consts.JobWorkType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkType(v)
		return nil
	case jobposition.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case jobposition.FieldSalaryMin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryMin(v)
		return nil
	case jobposition.FieldSalaryMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryMax(v)
		return nil
	case jobposition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case jobposition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobposition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobPositionMutation) AddedFields() []string {
	var fields []string
	if m.addsalary_min != nil {
		fields = append(fields, jobposition.FieldSalaryMin)
	}
	if m.addsalary_max != nil {
		fields = append(fields, jobposition.FieldSalaryMax)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobPositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobposition.FieldSalaryMin:
		return m.AddedSalaryMin()
	case jobposition.FieldSalaryMax:
		return m.AddedSalaryMax()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobposition.FieldSalaryMin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalaryMin(v)
		return nil
	case jobposition.FieldSalaryMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalaryMax(v)
		return nil
	}
	return fmt.Errorf("unknown JobPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobPositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobposition.FieldDeletedAt) {
		fields = append(fields, jobposition.FieldDeletedAt)
	}
	if m.FieldCleared(jobposition.FieldCreatedBy) {
		fields = append(fields, jobposition.FieldCreatedBy)
	}
	if m.FieldCleared(jobposition.FieldWorkType) {
		fields = append(fields, jobposition.FieldWorkType)
	}
	if m.FieldCleared(jobposition.FieldLocation) {
		fields = append(fields, jobposition.FieldLocation)
	}
	if m.FieldCleared(jobposition.FieldSalaryMin) {
		fields = append(fields, jobposition.FieldSalaryMin)
	}
	if m.FieldCleared(jobposition.FieldSalaryMax) {
		fields = append(fields, jobposition.FieldSalaryMax)
	}
	if m.FieldCleared(jobposition.FieldDescription) {
		fields = append(fields, jobposition.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobPositionMutation) ClearField(name string) error {
	switch name {
	case jobposition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case jobposition.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case jobposition.FieldWorkType:
		m.ClearWorkType()
		return nil
	case jobposition.FieldLocation:
		m.ClearLocation()
		return nil
	case jobposition.FieldSalaryMin:
		m.ClearSalaryMin()
		return nil
	case jobposition.FieldSalaryMax:
		m.ClearSalaryMax()
		return nil
	case jobposition.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown JobPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobPositionMutation) ResetField(name string) error {
	switch name {
	case jobposition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobposition.FieldName:
		m.ResetName()
		return nil
	case jobposition.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case jobposition.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case jobposition.FieldStatus:
		m.ResetStatus()
		return nil
	case jobposition.FieldWorkType:
		m.ResetWorkType()
		return nil
	case jobposition.FieldLocation:
		m.ResetLocation()
		return nil
	case jobposition.FieldSalaryMin:
		m.ResetSalaryMin()
		return nil
	case jobposition.FieldSalaryMax:
		m.ResetSalaryMax()
		return nil
	case jobposition.FieldDescription:
		m.ResetDescription()
		return nil
	case jobposition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobposition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.department != nil {
		edges = append(edges, jobposition.EdgeDepartment)
	}
	if m.creator != nil {
		edges = append(edges, jobposition.EdgeCreator)
	}
	if m.responsibilities != nil {
		edges = append(edges, jobposition.EdgeResponsibilities)
	}
	if m.skills != nil {
		edges = append(edges, jobposition.EdgeSkills)
	}
	if m.education_requirements != nil {
		edges = append(edges, jobposition.EdgeEducationRequirements)
	}
	if m.experience_requirements != nil {
		edges = append(edges, jobposition.EdgeExperienceRequirements)
	}
	if m.industry_requirements != nil {
		edges = append(edges, jobposition.EdgeIndustryRequirements)
	}
	if m.resume_applications != nil {
		edges = append(edges, jobposition.EdgeResumeApplications)
	}
	if m.screening_tasks != nil {
		edges = append(edges, jobposition.EdgeScreeningTasks)
	}
	if m.screening_results != nil {
		edges = append(edges, jobposition.EdgeScreeningResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobPositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case jobposition.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case jobposition.EdgeResponsibilities:
		ids := make([]ent.Value, 0, len(m.responsibilities))
		for id := range m.responsibilities {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeEducationRequirements:
		ids := make([]ent.Value, 0, len(m.education_requirements))
		for id := range m.education_requirements {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeExperienceRequirements:
		ids := make([]ent.Value, 0, len(m.experience_requirements))
		for id := range m.experience_requirements {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeIndustryRequirements:
		ids := make([]ent.Value, 0, len(m.industry_requirements))
		for id := range m.industry_requirements {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeResumeApplications:
		ids := make([]ent.Value, 0, len(m.resume_applications))
		for id := range m.resume_applications {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeScreeningTasks:
		ids := make([]ent.Value, 0, len(m.screening_tasks))
		for id := range m.screening_tasks {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeScreeningResults:
		ids := make([]ent.Value, 0, len(m.screening_results))
		for id := range m.screening_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedresponsibilities != nil {
		edges = append(edges, jobposition.EdgeResponsibilities)
	}
	if m.removedskills != nil {
		edges = append(edges, jobposition.EdgeSkills)
	}
	if m.removededucation_requirements != nil {
		edges = append(edges, jobposition.EdgeEducationRequirements)
	}
	if m.removedexperience_requirements != nil {
		edges = append(edges, jobposition.EdgeExperienceRequirements)
	}
	if m.removedindustry_requirements != nil {
		edges = append(edges, jobposition.EdgeIndustryRequirements)
	}
	if m.removedresume_applications != nil {
		edges = append(edges, jobposition.EdgeResumeApplications)
	}
	if m.removedscreening_tasks != nil {
		edges = append(edges, jobposition.EdgeScreeningTasks)
	}
	if m.removedscreening_results != nil {
		edges = append(edges, jobposition.EdgeScreeningResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobPositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobposition.EdgeResponsibilities:
		ids := make([]ent.Value, 0, len(m.removedresponsibilities))
		for id := range m.removedresponsibilities {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeEducationRequirements:
		ids := make([]ent.Value, 0, len(m.removededucation_requirements))
		for id := range m.removededucation_requirements {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeExperienceRequirements:
		ids := make([]ent.Value, 0, len(m.removedexperience_requirements))
		for id := range m.removedexperience_requirements {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeIndustryRequirements:
		ids := make([]ent.Value, 0, len(m.removedindustry_requirements))
		for id := range m.removedindustry_requirements {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeResumeApplications:
		ids := make([]ent.Value, 0, len(m.removedresume_applications))
		for id := range m.removedresume_applications {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeScreeningTasks:
		ids := make([]ent.Value, 0, len(m.removedscreening_tasks))
		for id := range m.removedscreening_tasks {
			ids = append(ids, id)
		}
		return ids
	case jobposition.EdgeScreeningResults:
		ids := make([]ent.Value, 0, len(m.removedscreening_results))
		for id := range m.removedscreening_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.cleareddepartment {
		edges = append(edges, jobposition.EdgeDepartment)
	}
	if m.clearedcreator {
		edges = append(edges, jobposition.EdgeCreator)
	}
	if m.clearedresponsibilities {
		edges = append(edges, jobposition.EdgeResponsibilities)
	}
	if m.clearedskills {
		edges = append(edges, jobposition.EdgeSkills)
	}
	if m.clearededucation_requirements {
		edges = append(edges, jobposition.EdgeEducationRequirements)
	}
	if m.clearedexperience_requirements {
		edges = append(edges, jobposition.EdgeExperienceRequirements)
	}
	if m.clearedindustry_requirements {
		edges = append(edges, jobposition.EdgeIndustryRequirements)
	}
	if m.clearedresume_applications {
		edges = append(edges, jobposition.EdgeResumeApplications)
	}
	if m.clearedscreening_tasks {
		edges = append(edges, jobposition.EdgeScreeningTasks)
	}
	if m.clearedscreening_results {
		edges = append(edges, jobposition.EdgeScreeningResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobPositionMutation) EdgeCleared(name string) bool {
	switch name {
	case jobposition.EdgeDepartment:
		return m.cleareddepartment
	case jobposition.EdgeCreator:
		return m.clearedcreator
	case jobposition.EdgeResponsibilities:
		return m.clearedresponsibilities
	case jobposition.EdgeSkills:
		return m.clearedskills
	case jobposition.EdgeEducationRequirements:
		return m.clearededucation_requirements
	case jobposition.EdgeExperienceRequirements:
		return m.clearedexperience_requirements
	case jobposition.EdgeIndustryRequirements:
		return m.clearedindustry_requirements
	case jobposition.EdgeResumeApplications:
		return m.clearedresume_applications
	case jobposition.EdgeScreeningTasks:
		return m.clearedscreening_tasks
	case jobposition.EdgeScreeningResults:
		return m.clearedscreening_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobPositionMutation) ClearEdge(name string) error {
	switch name {
	case jobposition.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case jobposition.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown JobPosition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobPositionMutation) ResetEdge(name string) error {
	switch name {
	case jobposition.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case jobposition.EdgeCreator:
		m.ResetCreator()
		return nil
	case jobposition.EdgeResponsibilities:
		m.ResetResponsibilities()
		return nil
	case jobposition.EdgeSkills:
		m.ResetSkills()
		return nil
	case jobposition.EdgeEducationRequirements:
		m.ResetEducationRequirements()
		return nil
	case jobposition.EdgeExperienceRequirements:
		m.ResetExperienceRequirements()
		return nil
	case jobposition.EdgeIndustryRequirements:
		m.ResetIndustryRequirements()
		return nil
	case jobposition.EdgeResumeApplications:
		m.ResetResumeApplications()
		return nil
	case jobposition.EdgeScreeningTasks:
		m.ResetScreeningTasks()
		return nil
	case jobposition.EdgeScreeningResults:
		m.ResetScreeningResults()
		return nil
	}
	return fmt.Errorf("unknown JobPosition edge %s", name)
}

// JobResponsibilityMutation represents an operation that mutates the JobResponsibility nodes in the graph.
type JobResponsibilityMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	deleted_at     *time.Time
	responsibility *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	job            *uuid.UUID
	clearedjob     bool
	done           bool
	oldValue       func(context.Context) (*JobResponsibility, error)
	predicates     []predicate.JobResponsibility
}

var _ ent.Mutation = (*JobResponsibilityMutation)(nil)

// jobresponsibilityOption allows management of the mutation configuration using functional options.
type jobresponsibilityOption func(*JobResponsibilityMutation)

// newJobResponsibilityMutation creates new mutation for the JobResponsibility entity.
func newJobResponsibilityMutation(c config, op Op, opts ...jobresponsibilityOption) *JobResponsibilityMutation {
	m := &JobResponsibilityMutation{
		config:        c,
		op:            op,
		typ:           TypeJobResponsibility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobResponsibilityID sets the ID field of the mutation.
func withJobResponsibilityID(id uuid.UUID) jobresponsibilityOption {
	return func(m *JobResponsibilityMutation) {
		var (
			err   error
			once  sync.Once
			value *JobResponsibility
		)
		m.oldValue = func(ctx context.Context) (*JobResponsibility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobResponsibility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobResponsibility sets the old JobResponsibility of the mutation.
func withJobResponsibility(node *JobResponsibility) jobresponsibilityOption {
	return func(m *JobResponsibilityMutation) {
		m.oldValue = func(context.Context) (*JobResponsibility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobResponsibilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobResponsibilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobResponsibility entities.
func (m *JobResponsibilityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobResponsibilityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobResponsibilityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobResponsibility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobResponsibilityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobResponsibilityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobResponsibility entity.
// If the JobResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobResponsibilityMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobResponsibilityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobresponsibility.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobResponsibilityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobresponsibility.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobResponsibilityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobresponsibility.FieldDeletedAt)
}

// SetJobID sets the "job_id" field.
func (m *JobResponsibilityMutation) SetJobID(u uuid.UUID) {
	m.job = &u
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *JobResponsibilityMutation) JobID() (r uuid.UUID, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the JobResponsibility entity.
// If the JobResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobResponsibilityMutation) OldJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *JobResponsibilityMutation) ResetJobID() {
	m.job = nil
}

// SetResponsibility sets the "responsibility" field.
func (m *JobResponsibilityMutation) SetResponsibility(s string) {
	m.responsibility = &s
}

// Responsibility returns the value of the "responsibility" field in the mutation.
func (m *JobResponsibilityMutation) Responsibility() (r string, exists bool) {
	v := m.responsibility
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsibility returns the old "responsibility" field's value of the JobResponsibility entity.
// If the JobResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobResponsibilityMutation) OldResponsibility(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsibility: %w", err)
	}
	return oldValue.Responsibility, nil
}

// ResetResponsibility resets all changes to the "responsibility" field.
func (m *JobResponsibilityMutation) ResetResponsibility() {
	m.responsibility = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobResponsibilityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobResponsibilityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobResponsibility entity.
// If the JobResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobResponsibilityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobResponsibilityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobResponsibilityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobResponsibilityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobResponsibility entity.
// If the JobResponsibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobResponsibilityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobResponsibilityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearJob clears the "job" edge to the JobPosition entity.
func (m *JobResponsibilityMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[jobresponsibility.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the JobPosition entity was cleared.
func (m *JobResponsibilityMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobResponsibilityMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobResponsibilityMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the JobResponsibilityMutation builder.
func (m *JobResponsibilityMutation) Where(ps ...predicate.JobResponsibility) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobResponsibilityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobResponsibilityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobResponsibility, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobResponsibilityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobResponsibilityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobResponsibility).
func (m *JobResponsibilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobResponsibilityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.deleted_at != nil {
		fields = append(fields, jobresponsibility.FieldDeletedAt)
	}
	if m.job != nil {
		fields = append(fields, jobresponsibility.FieldJobID)
	}
	if m.responsibility != nil {
		fields = append(fields, jobresponsibility.FieldResponsibility)
	}
	if m.created_at != nil {
		fields = append(fields, jobresponsibility.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobresponsibility.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobResponsibilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobresponsibility.FieldDeletedAt:
		return m.DeletedAt()
	case jobresponsibility.FieldJobID:
		return m.JobID()
	case jobresponsibility.FieldResponsibility:
		return m.Responsibility()
	case jobresponsibility.FieldCreatedAt:
		return m.CreatedAt()
	case jobresponsibility.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobResponsibilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobresponsibility.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobresponsibility.FieldJobID:
		return m.OldJobID(ctx)
	case jobresponsibility.FieldResponsibility:
		return m.OldResponsibility(ctx)
	case jobresponsibility.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobresponsibility.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobResponsibility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobResponsibilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobresponsibility.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobresponsibility.FieldJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case jobresponsibility.FieldResponsibility:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsibility(v)
		return nil
	case jobresponsibility.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobresponsibility.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobResponsibility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobResponsibilityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobResponsibilityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobResponsibilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobResponsibility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobResponsibilityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobresponsibility.FieldDeletedAt) {
		fields = append(fields, jobresponsibility.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobResponsibilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobResponsibilityMutation) ClearField(name string) error {
	switch name {
	case jobresponsibility.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown JobResponsibility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobResponsibilityMutation) ResetField(name string) error {
	switch name {
	case jobresponsibility.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobresponsibility.FieldJobID:
		m.ResetJobID()
		return nil
	case jobresponsibility.FieldResponsibility:
		m.ResetResponsibility()
		return nil
	case jobresponsibility.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobresponsibility.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobResponsibility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobResponsibilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, jobresponsibility.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobResponsibilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobresponsibility.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobResponsibilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobResponsibilityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobResponsibilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, jobresponsibility.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobResponsibilityMutation) EdgeCleared(name string) bool {
	switch name {
	case jobresponsibility.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobResponsibilityMutation) ClearEdge(name string) error {
	switch name {
	case jobresponsibility.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown JobResponsibility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobResponsibilityMutation) ResetEdge(name string) error {
	switch name {
	case jobresponsibility.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown JobResponsibility edge %s", name)
}

// JobSkillMutation represents an operation that mutates the JobSkill nodes in the graph.
type JobSkillMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	_type         *consts.JobSkillType
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	job           *uuid.UUID
	clearedjob    bool
	skill         *uuid.UUID
	clearedskill  bool
	done          bool
	oldValue      func(context.Context) (*JobSkill, error)
	predicates    []predicate.JobSkill
}

var _ ent.Mutation = (*JobSkillMutation)(nil)

// jobskillOption allows management of the mutation configuration using functional options.
type jobskillOption func(*JobSkillMutation)

// newJobSkillMutation creates new mutation for the JobSkill entity.
func newJobSkillMutation(c config, op Op, opts ...jobskillOption) *JobSkillMutation {
	m := &JobSkillMutation{
		config:        c,
		op:            op,
		typ:           TypeJobSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobSkillID sets the ID field of the mutation.
func withJobSkillID(id uuid.UUID) jobskillOption {
	return func(m *JobSkillMutation) {
		var (
			err   error
			once  sync.Once
			value *JobSkill
		)
		m.oldValue = func(ctx context.Context) (*JobSkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobSkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobSkill sets the old JobSkill of the mutation.
func withJobSkill(node *JobSkill) jobskillOption {
	return func(m *JobSkillMutation) {
		m.oldValue = func(context.Context) (*JobSkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobSkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobSkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobSkill entities.
func (m *JobSkillMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobSkillMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobSkillMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobSkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobSkillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobSkillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobSkill entity.
// If the JobSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobSkillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobskill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobSkillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobskill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobSkillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobskill.FieldDeletedAt)
}

// SetJobID sets the "job_id" field.
func (m *JobSkillMutation) SetJobID(u uuid.UUID) {
	m.job = &u
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *JobSkillMutation) JobID() (r uuid.UUID, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the JobSkill entity.
// If the JobSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMutation) OldJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *JobSkillMutation) ResetJobID() {
	m.job = nil
}

// SetSkillID sets the "skill_id" field.
func (m *JobSkillMutation) SetSkillID(u uuid.UUID) {
	m.skill = &u
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *JobSkillMutation) SkillID() (r uuid.UUID, exists bool) {
	v := m.skill
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the JobSkill entity.
// If the JobSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMutation) OldSkillID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *JobSkillMutation) ResetSkillID() {
	m.skill = nil
}

// SetType sets the "type" field.
func (m *JobSkillMutation) SetType(cst consts.JobSkillType) {
	m._type = &cst
}

// GetType returns the value of the "type" field in the mutation.
func (m *JobSkillMutation) GetType() (r consts.JobSkillType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the JobSkill entity.
// If the JobSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMutation) OldType(ctx context.Context) (v consts.JobSkillType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *JobSkillMutation) ResetType() {
	m._type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobSkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobSkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobSkill entity.
// If the JobSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobSkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobSkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobSkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobSkill entity.
// If the JobSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobSkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearJob clears the "job" edge to the JobPosition entity.
func (m *JobSkillMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[jobskill.FieldJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the JobPosition entity was cleared.
func (m *JobSkillMutation) JobCleared() bool {
	return m.clearedjob
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobSkillMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobSkillMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// ClearSkill clears the "skill" edge to the JobSkillMeta entity.
func (m *JobSkillMutation) ClearSkill() {
	m.clearedskill = true
	m.clearedFields[jobskill.FieldSkillID] = struct{}{}
}

// SkillCleared reports if the "skill" edge to the JobSkillMeta entity was cleared.
func (m *JobSkillMutation) SkillCleared() bool {
	return m.clearedskill
}

// SkillIDs returns the "skill" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillID instead. It exists only for internal usage by the builders.
func (m *JobSkillMutation) SkillIDs() (ids []uuid.UUID) {
	if id := m.skill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkill resets all changes to the "skill" edge.
func (m *JobSkillMutation) ResetSkill() {
	m.skill = nil
	m.clearedskill = false
}

// Where appends a list predicates to the JobSkillMutation builder.
func (m *JobSkillMutation) Where(ps ...predicate.JobSkill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobSkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobSkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobSkill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobSkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobSkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobSkill).
func (m *JobSkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobSkillMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, jobskill.FieldDeletedAt)
	}
	if m.job != nil {
		fields = append(fields, jobskill.FieldJobID)
	}
	if m.skill != nil {
		fields = append(fields, jobskill.FieldSkillID)
	}
	if m._type != nil {
		fields = append(fields, jobskill.FieldType)
	}
	if m.created_at != nil {
		fields = append(fields, jobskill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobskill.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobSkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobskill.FieldDeletedAt:
		return m.DeletedAt()
	case jobskill.FieldJobID:
		return m.JobID()
	case jobskill.FieldSkillID:
		return m.SkillID()
	case jobskill.FieldType:
		return m.GetType()
	case jobskill.FieldCreatedAt:
		return m.CreatedAt()
	case jobskill.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobSkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobskill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobskill.FieldJobID:
		return m.OldJobID(ctx)
	case jobskill.FieldSkillID:
		return m.OldSkillID(ctx)
	case jobskill.FieldType:
		return m.OldType(ctx)
	case jobskill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobskill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobSkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobSkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobskill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobskill.FieldJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case jobskill.FieldSkillID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	case jobskill.FieldType:
		v, ok := value.(consts.JobSkillType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case jobskill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobskill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobSkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobSkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobSkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobSkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobSkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobSkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobskill.FieldDeletedAt) {
		fields = append(fields, jobskill.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobSkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobSkillMutation) ClearField(name string) error {
	switch name {
	case jobskill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown JobSkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobSkillMutation) ResetField(name string) error {
	switch name {
	case jobskill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobskill.FieldJobID:
		m.ResetJobID()
		return nil
	case jobskill.FieldSkillID:
		m.ResetSkillID()
		return nil
	case jobskill.FieldType:
		m.ResetType()
		return nil
	case jobskill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobskill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobSkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobSkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.job != nil {
		edges = append(edges, jobskill.EdgeJob)
	}
	if m.skill != nil {
		edges = append(edges, jobskill.EdgeSkill)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobSkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobskill.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case jobskill.EdgeSkill:
		if id := m.skill; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobSkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobSkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobSkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjob {
		edges = append(edges, jobskill.EdgeJob)
	}
	if m.clearedskill {
		edges = append(edges, jobskill.EdgeSkill)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobSkillMutation) EdgeCleared(name string) bool {
	switch name {
	case jobskill.EdgeJob:
		return m.clearedjob
	case jobskill.EdgeSkill:
		return m.clearedskill
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobSkillMutation) ClearEdge(name string) error {
	switch name {
	case jobskill.EdgeJob:
		m.ClearJob()
		return nil
	case jobskill.EdgeSkill:
		m.ClearSkill()
		return nil
	}
	return fmt.Errorf("unknown JobSkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobSkillMutation) ResetEdge(name string) error {
	switch name {
	case jobskill.EdgeJob:
		m.ResetJob()
		return nil
	case jobskill.EdgeSkill:
		m.ResetSkill()
		return nil
	}
	return fmt.Errorf("unknown JobSkill edge %s", name)
}

// JobSkillMetaMutation represents an operation that mutates the JobSkillMeta nodes in the graph.
type JobSkillMetaMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	deleted_at       *time.Time
	name             *string
	updated_at       *time.Time
	created_at       *time.Time
	clearedFields    map[string]struct{}
	job_links        map[uuid.UUID]struct{}
	removedjob_links map[uuid.UUID]struct{}
	clearedjob_links bool
	done             bool
	oldValue         func(context.Context) (*JobSkillMeta, error)
	predicates       []predicate.JobSkillMeta
}

var _ ent.Mutation = (*JobSkillMetaMutation)(nil)

// jobskillmetaOption allows management of the mutation configuration using functional options.
type jobskillmetaOption func(*JobSkillMetaMutation)

// newJobSkillMetaMutation creates new mutation for the JobSkillMeta entity.
func newJobSkillMetaMutation(c config, op Op, opts ...jobskillmetaOption) *JobSkillMetaMutation {
	m := &JobSkillMetaMutation{
		config:        c,
		op:            op,
		typ:           TypeJobSkillMeta,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobSkillMetaID sets the ID field of the mutation.
func withJobSkillMetaID(id uuid.UUID) jobskillmetaOption {
	return func(m *JobSkillMetaMutation) {
		var (
			err   error
			once  sync.Once
			value *JobSkillMeta
		)
		m.oldValue = func(ctx context.Context) (*JobSkillMeta, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobSkillMeta.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobSkillMeta sets the old JobSkillMeta of the mutation.
func withJobSkillMeta(node *JobSkillMeta) jobskillmetaOption {
	return func(m *JobSkillMetaMutation) {
		m.oldValue = func(context.Context) (*JobSkillMeta, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobSkillMetaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobSkillMetaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobSkillMeta entities.
func (m *JobSkillMetaMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobSkillMetaMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobSkillMetaMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobSkillMeta.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobSkillMetaMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobSkillMetaMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobSkillMeta entity.
// If the JobSkillMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMetaMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobSkillMetaMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobskillmeta.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobSkillMetaMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobskillmeta.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobSkillMetaMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobskillmeta.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *JobSkillMetaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JobSkillMetaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the JobSkillMeta entity.
// If the JobSkillMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMetaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JobSkillMetaMutation) ResetName() {
	m.name = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobSkillMetaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobSkillMetaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobSkillMeta entity.
// If the JobSkillMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMetaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobSkillMetaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobSkillMetaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobSkillMetaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobSkillMeta entity.
// If the JobSkillMeta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSkillMetaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobSkillMetaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddJobLinkIDs adds the "job_links" edge to the JobSkill entity by ids.
func (m *JobSkillMetaMutation) AddJobLinkIDs(ids ...uuid.UUID) {
	if m.job_links == nil {
		m.job_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.job_links[ids[i]] = struct{}{}
	}
}

// ClearJobLinks clears the "job_links" edge to the JobSkill entity.
func (m *JobSkillMetaMutation) ClearJobLinks() {
	m.clearedjob_links = true
}

// JobLinksCleared reports if the "job_links" edge to the JobSkill entity was cleared.
func (m *JobSkillMetaMutation) JobLinksCleared() bool {
	return m.clearedjob_links
}

// RemoveJobLinkIDs removes the "job_links" edge to the JobSkill entity by IDs.
func (m *JobSkillMetaMutation) RemoveJobLinkIDs(ids ...uuid.UUID) {
	if m.removedjob_links == nil {
		m.removedjob_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.job_links, ids[i])
		m.removedjob_links[ids[i]] = struct{}{}
	}
}

// RemovedJobLinks returns the removed IDs of the "job_links" edge to the JobSkill entity.
func (m *JobSkillMetaMutation) RemovedJobLinksIDs() (ids []uuid.UUID) {
	for id := range m.removedjob_links {
		ids = append(ids, id)
	}
	return
}

// JobLinksIDs returns the "job_links" edge IDs in the mutation.
func (m *JobSkillMetaMutation) JobLinksIDs() (ids []uuid.UUID) {
	for id := range m.job_links {
		ids = append(ids, id)
	}
	return
}

// ResetJobLinks resets all changes to the "job_links" edge.
func (m *JobSkillMetaMutation) ResetJobLinks() {
	m.job_links = nil
	m.clearedjob_links = false
	m.removedjob_links = nil
}

// Where appends a list predicates to the JobSkillMetaMutation builder.
func (m *JobSkillMetaMutation) Where(ps ...predicate.JobSkillMeta) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobSkillMetaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobSkillMetaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobSkillMeta, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobSkillMetaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobSkillMetaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobSkillMeta).
func (m *JobSkillMetaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobSkillMetaMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.deleted_at != nil {
		fields = append(fields, jobskillmeta.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, jobskillmeta.FieldName)
	}
	if m.updated_at != nil {
		fields = append(fields, jobskillmeta.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, jobskillmeta.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobSkillMetaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobskillmeta.FieldDeletedAt:
		return m.DeletedAt()
	case jobskillmeta.FieldName:
		return m.Name()
	case jobskillmeta.FieldUpdatedAt:
		return m.UpdatedAt()
	case jobskillmeta.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobSkillMetaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobskillmeta.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobskillmeta.FieldName:
		return m.OldName(ctx)
	case jobskillmeta.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case jobskillmeta.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobSkillMeta field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobSkillMetaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobskillmeta.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobskillmeta.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jobskillmeta.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case jobskillmeta.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobSkillMeta field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobSkillMetaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobSkillMetaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobSkillMetaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobSkillMeta numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobSkillMetaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobskillmeta.FieldDeletedAt) {
		fields = append(fields, jobskillmeta.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobSkillMetaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobSkillMetaMutation) ClearField(name string) error {
	switch name {
	case jobskillmeta.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown JobSkillMeta nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobSkillMetaMutation) ResetField(name string) error {
	switch name {
	case jobskillmeta.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobskillmeta.FieldName:
		m.ResetName()
		return nil
	case jobskillmeta.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case jobskillmeta.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobSkillMeta field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobSkillMetaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job_links != nil {
		edges = append(edges, jobskillmeta.EdgeJobLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobSkillMetaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobskillmeta.EdgeJobLinks:
		ids := make([]ent.Value, 0, len(m.job_links))
		for id := range m.job_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobSkillMetaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedjob_links != nil {
		edges = append(edges, jobskillmeta.EdgeJobLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobSkillMetaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobskillmeta.EdgeJobLinks:
		ids := make([]ent.Value, 0, len(m.removedjob_links))
		for id := range m.removedjob_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobSkillMetaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob_links {
		edges = append(edges, jobskillmeta.EdgeJobLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobSkillMetaMutation) EdgeCleared(name string) bool {
	switch name {
	case jobskillmeta.EdgeJobLinks:
		return m.clearedjob_links
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobSkillMetaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobSkillMeta unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobSkillMetaMutation) ResetEdge(name string) error {
	switch name {
	case jobskillmeta.EdgeJobLinks:
		m.ResetJobLinks()
		return nil
	}
	return fmt.Errorf("unknown JobSkillMeta edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	deleted_at          *time.Time
	role                *string
	agent_name          *string
	_type               *string
	content             *string
	media_url           *string
	sequence            *int
	addsequence         *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	conversation        *uuid.UUID
	clearedconversation bool
	attachments         map[uuid.UUID]struct{}
	removedattachments  map[uuid.UUID]struct{}
	clearedattachments  bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uuid.UUID) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[message.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, message.FieldDeletedAt)
}

// SetConversationID sets the "conversation_id" field.
func (m *MessageMutation) SetConversationID(u uuid.UUID) {
	m.conversation = &u
}

// ConversationID returns the value of the "conversation_id" field in the mutation.
func (m *MessageMutation) ConversationID() (r uuid.UUID, exists bool) {
	v := m.conversation
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationID returns the old "conversation_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldConversationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationID: %w", err)
	}
	return oldValue.ConversationID, nil
}

// ResetConversationID resets all changes to the "conversation_id" field.
func (m *MessageMutation) ResetConversationID() {
	m.conversation = nil
}

// SetRole sets the "role" field.
func (m *MessageMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *MessageMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MessageMutation) ResetRole() {
	m.role = nil
}

// SetAgentName sets the "agent_name" field.
func (m *MessageMutation) SetAgentName(s string) {
	m.agent_name = &s
}

// AgentName returns the value of the "agent_name" field in the mutation.
func (m *MessageMutation) AgentName() (r string, exists bool) {
	v := m.agent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentName returns the old "agent_name" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldAgentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentName: %w", err)
	}
	return oldValue.AgentName, nil
}

// ClearAgentName clears the value of the "agent_name" field.
func (m *MessageMutation) ClearAgentName() {
	m.agent_name = nil
	m.clearedFields[message.FieldAgentName] = struct{}{}
}

// AgentNameCleared returns if the "agent_name" field was cleared in this mutation.
func (m *MessageMutation) AgentNameCleared() bool {
	_, ok := m.clearedFields[message.FieldAgentName]
	return ok
}

// ResetAgentName resets all changes to the "agent_name" field.
func (m *MessageMutation) ResetAgentName() {
	m.agent_name = nil
	delete(m.clearedFields, message.FieldAgentName)
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MessageMutation) ClearContent() {
	m.content = nil
	m.clearedFields[message.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MessageMutation) ContentCleared() bool {
	_, ok := m.clearedFields[message.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, message.FieldContent)
}

// SetMediaURL sets the "media_url" field.
func (m *MessageMutation) SetMediaURL(s string) {
	m.media_url = &s
}

// MediaURL returns the value of the "media_url" field in the mutation.
func (m *MessageMutation) MediaURL() (r string, exists bool) {
	v := m.media_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaURL returns the old "media_url" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldMediaURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaURL: %w", err)
	}
	return oldValue.MediaURL, nil
}

// ClearMediaURL clears the value of the "media_url" field.
func (m *MessageMutation) ClearMediaURL() {
	m.media_url = nil
	m.clearedFields[message.FieldMediaURL] = struct{}{}
}

// MediaURLCleared returns if the "media_url" field was cleared in this mutation.
func (m *MessageMutation) MediaURLCleared() bool {
	_, ok := m.clearedFields[message.FieldMediaURL]
	return ok
}

// ResetMediaURL resets all changes to the "media_url" field.
func (m *MessageMutation) ResetMediaURL() {
	m.media_url = nil
	delete(m.clearedFields, message.FieldMediaURL)
}

// SetSequence sets the "sequence" field.
func (m *MessageMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *MessageMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *MessageMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *MessageMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *MessageMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *MessageMutation) ClearConversation() {
	m.clearedconversation = true
	m.clearedFields[message.FieldConversationID] = struct{}{}
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *MessageMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ConversationIDs() (ids []uuid.UUID) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *MessageMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *MessageMutation) AddAttachmentIDs(ids ...uuid.UUID) {
	if m.attachments == nil {
		m.attachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *MessageMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *MessageMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *MessageMutation) RemoveAttachmentIDs(ids ...uuid.UUID) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *MessageMutation) RemovedAttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *MessageMutation) AttachmentsIDs() (ids []uuid.UUID) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *MessageMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.conversation != nil {
		fields = append(fields, message.FieldConversationID)
	}
	if m.role != nil {
		fields = append(fields, message.FieldRole)
	}
	if m.agent_name != nil {
		fields = append(fields, message.FieldAgentName)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.media_url != nil {
		fields = append(fields, message.FieldMediaURL)
	}
	if m.sequence != nil {
		fields = append(fields, message.FieldSequence)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldDeletedAt:
		return m.DeletedAt()
	case message.FieldConversationID:
		return m.ConversationID()
	case message.FieldRole:
		return m.Role()
	case message.FieldAgentName:
		return m.AgentName()
	case message.FieldType:
		return m.GetType()
	case message.FieldContent:
		return m.Content()
	case message.FieldMediaURL:
		return m.MediaURL()
	case message.FieldSequence:
		return m.Sequence()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case message.FieldConversationID:
		return m.OldConversationID(ctx)
	case message.FieldRole:
		return m.OldRole(ctx)
	case message.FieldAgentName:
		return m.OldAgentName(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldMediaURL:
		return m.OldMediaURL(ctx)
	case message.FieldSequence:
		return m.OldSequence(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case message.FieldConversationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationID(v)
		return nil
	case message.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case message.FieldAgentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentName(v)
		return nil
	case message.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldMediaURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaURL(v)
		return nil
	case message.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, message.FieldSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSequence:
		return m.AddedSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case message.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldDeletedAt) {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.FieldCleared(message.FieldAgentName) {
		fields = append(fields, message.FieldAgentName)
	}
	if m.FieldCleared(message.FieldContent) {
		fields = append(fields, message.FieldContent)
	}
	if m.FieldCleared(message.FieldMediaURL) {
		fields = append(fields, message.FieldMediaURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case message.FieldAgentName:
		m.ClearAgentName()
		return nil
	case message.FieldContent:
		m.ClearContent()
		return nil
	case message.FieldMediaURL:
		m.ClearMediaURL()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case message.FieldConversationID:
		m.ResetConversationID()
		return nil
	case message.FieldRole:
		m.ResetRole()
		return nil
	case message.FieldAgentName:
		m.ResetAgentName()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldMediaURL:
		m.ResetMediaURL()
		return nil
	case message.FieldSequence:
		m.ResetSequence()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.conversation != nil {
		edges = append(edges, message.EdgeConversation)
	}
	if m.attachments != nil {
		edges = append(edges, message.EdgeAttachments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattachments != nil {
		edges = append(edges, message.EdgeAttachments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconversation {
		edges = append(edges, message.EdgeConversation)
	}
	if m.clearedattachments {
		edges = append(edges, message.EdgeAttachments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeConversation:
		return m.clearedconversation
	case message.EdgeAttachments:
		return m.clearedattachments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ClearConversation()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ResetConversation()
		return nil
	case message.EdgeAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// NotificationEventMutation represents an operation that mutates the NotificationEvent nodes in the graph.
type NotificationEventMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	deleted_at     *time.Time
	event_type     *consts.NotificationEventType
	channel        *consts.NotificationChannel
	status         *consts.NotificationStatus
	payload        *map[string]interface{}
	template_id    *string
	target         *string
	retry_count    *int
	addretry_count *int
	max_retry      *int
	addmax_retry   *int
	timeout        *int
	addtimeout     *int
	last_error     *string
	trace_id       *string
	scheduled_at   *time.Time
	delivered_at   *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*NotificationEvent, error)
	predicates     []predicate.NotificationEvent
}

var _ ent.Mutation = (*NotificationEventMutation)(nil)

// notificationeventOption allows management of the mutation configuration using functional options.
type notificationeventOption func(*NotificationEventMutation)

// newNotificationEventMutation creates new mutation for the NotificationEvent entity.
func newNotificationEventMutation(c config, op Op, opts ...notificationeventOption) *NotificationEventMutation {
	m := &NotificationEventMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationEventID sets the ID field of the mutation.
func withNotificationEventID(id uuid.UUID) notificationeventOption {
	return func(m *NotificationEventMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationEvent
		)
		m.oldValue = func(ctx context.Context) (*NotificationEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationEvent sets the old NotificationEvent of the mutation.
func withNotificationEvent(node *NotificationEvent) notificationeventOption {
	return func(m *NotificationEventMutation) {
		m.oldValue = func(context.Context) (*NotificationEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationEvent entities.
func (m *NotificationEventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationEventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationEventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationEventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationEventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationEventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationevent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationEventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationevent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationEventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationevent.FieldDeletedAt)
}

// SetEventType sets the "event_type" field.
func (m *NotificationEventMutation) SetEventType(cet consts.NotificationEventType) {
	m.event_type = &cet
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *NotificationEventMutation) EventType() (r consts.NotificationEventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldEventType(ctx context.Context) (v consts.NotificationEventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *NotificationEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetChannel sets the "channel" field.
func (m *NotificationEventMutation) SetChannel(cc consts.NotificationChannel) {
	m.channel = &cc
}

// Channel returns the value of the "channel" field in the mutation.
func (m *NotificationEventMutation) Channel() (r consts.NotificationChannel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldChannel(ctx context.Context) (v consts.NotificationChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *NotificationEventMutation) ResetChannel() {
	m.channel = nil
}

// SetStatus sets the "status" field.
func (m *NotificationEventMutation) SetStatus(cs consts.NotificationStatus) {
	m.status = &cs
}

// Status returns the value of the "status" field in the mutation.
func (m *NotificationEventMutation) Status() (r consts.NotificationStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldStatus(ctx context.Context) (v consts.NotificationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotificationEventMutation) ResetStatus() {
	m.status = nil
}

// SetPayload sets the "payload" field.
func (m *NotificationEventMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *NotificationEventMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *NotificationEventMutation) ResetPayload() {
	m.payload = nil
}

// SetTemplateID sets the "template_id" field.
func (m *NotificationEventMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *NotificationEventMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *NotificationEventMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetTarget sets the "target" field.
func (m *NotificationEventMutation) SetTarget(s string) {
	m.target = &s
}

// Target returns the value of the "target" field in the mutation.
func (m *NotificationEventMutation) Target() (r string, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTarget returns the old "target" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldTarget(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTarget: %w", err)
	}
	return oldValue.Target, nil
}

// ResetTarget resets all changes to the "target" field.
func (m *NotificationEventMutation) ResetTarget() {
	m.target = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *NotificationEventMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *NotificationEventMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *NotificationEventMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *NotificationEventMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *NotificationEventMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetMaxRetry sets the "max_retry" field.
func (m *NotificationEventMutation) SetMaxRetry(i int) {
	m.max_retry = &i
	m.addmax_retry = nil
}

// MaxRetry returns the value of the "max_retry" field in the mutation.
func (m *NotificationEventMutation) MaxRetry() (r int, exists bool) {
	v := m.max_retry
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRetry returns the old "max_retry" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldMaxRetry(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRetry: %w", err)
	}
	return oldValue.MaxRetry, nil
}

// AddMaxRetry adds i to the "max_retry" field.
func (m *NotificationEventMutation) AddMaxRetry(i int) {
	if m.addmax_retry != nil {
		*m.addmax_retry += i
	} else {
		m.addmax_retry = &i
	}
}

// AddedMaxRetry returns the value that was added to the "max_retry" field in this mutation.
func (m *NotificationEventMutation) AddedMaxRetry() (r int, exists bool) {
	v := m.addmax_retry
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxRetry resets all changes to the "max_retry" field.
func (m *NotificationEventMutation) ResetMaxRetry() {
	m.max_retry = nil
	m.addmax_retry = nil
}

// SetTimeout sets the "timeout" field.
func (m *NotificationEventMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *NotificationEventMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *NotificationEventMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *NotificationEventMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *NotificationEventMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetLastError sets the "last_error" field.
func (m *NotificationEventMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *NotificationEventMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ClearLastError clears the value of the "last_error" field.
func (m *NotificationEventMutation) ClearLastError() {
	m.last_error = nil
	m.clearedFields[notificationevent.FieldLastError] = struct{}{}
}

// LastErrorCleared returns if the "last_error" field was cleared in this mutation.
func (m *NotificationEventMutation) LastErrorCleared() bool {
	_, ok := m.clearedFields[notificationevent.FieldLastError]
	return ok
}

// ResetLastError resets all changes to the "last_error" field.
func (m *NotificationEventMutation) ResetLastError() {
	m.last_error = nil
	delete(m.clearedFields, notificationevent.FieldLastError)
}

// SetTraceID sets the "trace_id" field.
func (m *NotificationEventMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *NotificationEventMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *NotificationEventMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[notificationevent.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *NotificationEventMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[notificationevent.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *NotificationEventMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, notificationevent.FieldTraceID)
}

// SetScheduledAt sets the "scheduled_at" field.
func (m *NotificationEventMutation) SetScheduledAt(t time.Time) {
	m.scheduled_at = &t
}

// ScheduledAt returns the value of the "scheduled_at" field in the mutation.
func (m *NotificationEventMutation) ScheduledAt() (r time.Time, exists bool) {
	v := m.scheduled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAt returns the old "scheduled_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldScheduledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAt: %w", err)
	}
	return oldValue.ScheduledAt, nil
}

// ClearScheduledAt clears the value of the "scheduled_at" field.
func (m *NotificationEventMutation) ClearScheduledAt() {
	m.scheduled_at = nil
	m.clearedFields[notificationevent.FieldScheduledAt] = struct{}{}
}

// ScheduledAtCleared returns if the "scheduled_at" field was cleared in this mutation.
func (m *NotificationEventMutation) ScheduledAtCleared() bool {
	_, ok := m.clearedFields[notificationevent.FieldScheduledAt]
	return ok
}

// ResetScheduledAt resets all changes to the "scheduled_at" field.
func (m *NotificationEventMutation) ResetScheduledAt() {
	m.scheduled_at = nil
	delete(m.clearedFields, notificationevent.FieldScheduledAt)
}

// SetDeliveredAt sets the "delivered_at" field.
func (m *NotificationEventMutation) SetDeliveredAt(t time.Time) {
	m.delivered_at = &t
}

// DeliveredAt returns the value of the "delivered_at" field in the mutation.
func (m *NotificationEventMutation) DeliveredAt() (r time.Time, exists bool) {
	v := m.delivered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveredAt returns the old "delivered_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldDeliveredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveredAt: %w", err)
	}
	return oldValue.DeliveredAt, nil
}

// ClearDeliveredAt clears the value of the "delivered_at" field.
func (m *NotificationEventMutation) ClearDeliveredAt() {
	m.delivered_at = nil
	m.clearedFields[notificationevent.FieldDeliveredAt] = struct{}{}
}

// DeliveredAtCleared returns if the "delivered_at" field was cleared in this mutation.
func (m *NotificationEventMutation) DeliveredAtCleared() bool {
	_, ok := m.clearedFields[notificationevent.FieldDeliveredAt]
	return ok
}

// ResetDeliveredAt resets all changes to the "delivered_at" field.
func (m *NotificationEventMutation) ResetDeliveredAt() {
	m.delivered_at = nil
	delete(m.clearedFields, notificationevent.FieldDeliveredAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationEvent entity.
// If the NotificationEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotificationEventMutation builder.
func (m *NotificationEventMutation) Where(ps ...predicate.NotificationEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationEvent).
func (m *NotificationEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationEventMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.deleted_at != nil {
		fields = append(fields, notificationevent.FieldDeletedAt)
	}
	if m.event_type != nil {
		fields = append(fields, notificationevent.FieldEventType)
	}
	if m.channel != nil {
		fields = append(fields, notificationevent.FieldChannel)
	}
	if m.status != nil {
		fields = append(fields, notificationevent.FieldStatus)
	}
	if m.payload != nil {
		fields = append(fields, notificationevent.FieldPayload)
	}
	if m.template_id != nil {
		fields = append(fields, notificationevent.FieldTemplateID)
	}
	if m.target != nil {
		fields = append(fields, notificationevent.FieldTarget)
	}
	if m.retry_count != nil {
		fields = append(fields, notificationevent.FieldRetryCount)
	}
	if m.max_retry != nil {
		fields = append(fields, notificationevent.FieldMaxRetry)
	}
	if m.timeout != nil {
		fields = append(fields, notificationevent.FieldTimeout)
	}
	if m.last_error != nil {
		fields = append(fields, notificationevent.FieldLastError)
	}
	if m.trace_id != nil {
		fields = append(fields, notificationevent.FieldTraceID)
	}
	if m.scheduled_at != nil {
		fields = append(fields, notificationevent.FieldScheduledAt)
	}
	if m.delivered_at != nil {
		fields = append(fields, notificationevent.FieldDeliveredAt)
	}
	if m.created_at != nil {
		fields = append(fields, notificationevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationevent.FieldDeletedAt:
		return m.DeletedAt()
	case notificationevent.FieldEventType:
		return m.EventType()
	case notificationevent.FieldChannel:
		return m.Channel()
	case notificationevent.FieldStatus:
		return m.Status()
	case notificationevent.FieldPayload:
		return m.Payload()
	case notificationevent.FieldTemplateID:
		return m.TemplateID()
	case notificationevent.FieldTarget:
		return m.Target()
	case notificationevent.FieldRetryCount:
		return m.RetryCount()
	case notificationevent.FieldMaxRetry:
		return m.MaxRetry()
	case notificationevent.FieldTimeout:
		return m.Timeout()
	case notificationevent.FieldLastError:
		return m.LastError()
	case notificationevent.FieldTraceID:
		return m.TraceID()
	case notificationevent.FieldScheduledAt:
		return m.ScheduledAt()
	case notificationevent.FieldDeliveredAt:
		return m.DeliveredAt()
	case notificationevent.FieldCreatedAt:
		return m.CreatedAt()
	case notificationevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationevent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationevent.FieldEventType:
		return m.OldEventType(ctx)
	case notificationevent.FieldChannel:
		return m.OldChannel(ctx)
	case notificationevent.FieldStatus:
		return m.OldStatus(ctx)
	case notificationevent.FieldPayload:
		return m.OldPayload(ctx)
	case notificationevent.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case notificationevent.FieldTarget:
		return m.OldTarget(ctx)
	case notificationevent.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case notificationevent.FieldMaxRetry:
		return m.OldMaxRetry(ctx)
	case notificationevent.FieldTimeout:
		return m.OldTimeout(ctx)
	case notificationevent.FieldLastError:
		return m.OldLastError(ctx)
	case notificationevent.FieldTraceID:
		return m.OldTraceID(ctx)
	case notificationevent.FieldScheduledAt:
		return m.OldScheduledAt(ctx)
	case notificationevent.FieldDeliveredAt:
		return m.OldDeliveredAt(ctx)
	case notificationevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationevent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationevent.FieldEventType:
		v, ok := value.(consts.NotificationEventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case notificationevent.FieldChannel:
		v, ok := value.(consts.NotificationChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case notificationevent.FieldStatus:
		v, ok := value.(consts.NotificationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notificationevent.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case notificationevent.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case notificationevent.FieldTarget:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTarget(v)
		return nil
	case notificationevent.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case notificationevent.FieldMaxRetry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRetry(v)
		return nil
	case notificationevent.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case notificationevent.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	case notificationevent.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case notificationevent.FieldScheduledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAt(v)
		return nil
	case notificationevent.FieldDeliveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveredAt(v)
		return nil
	case notificationevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationEventMutation) AddedFields() []string {
	var fields []string
	if m.addretry_count != nil {
		fields = append(fields, notificationevent.FieldRetryCount)
	}
	if m.addmax_retry != nil {
		fields = append(fields, notificationevent.FieldMaxRetry)
	}
	if m.addtimeout != nil {
		fields = append(fields, notificationevent.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notificationevent.FieldRetryCount:
		return m.AddedRetryCount()
	case notificationevent.FieldMaxRetry:
		return m.AddedMaxRetry()
	case notificationevent.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notificationevent.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case notificationevent.FieldMaxRetry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRetry(v)
		return nil
	case notificationevent.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationevent.FieldDeletedAt) {
		fields = append(fields, notificationevent.FieldDeletedAt)
	}
	if m.FieldCleared(notificationevent.FieldLastError) {
		fields = append(fields, notificationevent.FieldLastError)
	}
	if m.FieldCleared(notificationevent.FieldTraceID) {
		fields = append(fields, notificationevent.FieldTraceID)
	}
	if m.FieldCleared(notificationevent.FieldScheduledAt) {
		fields = append(fields, notificationevent.FieldScheduledAt)
	}
	if m.FieldCleared(notificationevent.FieldDeliveredAt) {
		fields = append(fields, notificationevent.FieldDeliveredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationEventMutation) ClearField(name string) error {
	switch name {
	case notificationevent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationevent.FieldLastError:
		m.ClearLastError()
		return nil
	case notificationevent.FieldTraceID:
		m.ClearTraceID()
		return nil
	case notificationevent.FieldScheduledAt:
		m.ClearScheduledAt()
		return nil
	case notificationevent.FieldDeliveredAt:
		m.ClearDeliveredAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationEventMutation) ResetField(name string) error {
	switch name {
	case notificationevent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationevent.FieldEventType:
		m.ResetEventType()
		return nil
	case notificationevent.FieldChannel:
		m.ResetChannel()
		return nil
	case notificationevent.FieldStatus:
		m.ResetStatus()
		return nil
	case notificationevent.FieldPayload:
		m.ResetPayload()
		return nil
	case notificationevent.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case notificationevent.FieldTarget:
		m.ResetTarget()
		return nil
	case notificationevent.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case notificationevent.FieldMaxRetry:
		m.ResetMaxRetry()
		return nil
	case notificationevent.FieldTimeout:
		m.ResetTimeout()
		return nil
	case notificationevent.FieldLastError:
		m.ResetLastError()
		return nil
	case notificationevent.FieldTraceID:
		m.ResetTraceID()
		return nil
	case notificationevent.FieldScheduledAt:
		m.ResetScheduledAt()
		return nil
	case notificationevent.FieldDeliveredAt:
		m.ResetDeliveredAt()
		return nil
	case notificationevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationEvent edge %s", name)
}

// NotificationSettingMutation represents an operation that mutates the NotificationSetting nodes in the graph.
type NotificationSettingMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	deleted_at      *time.Time
	channel         *consts.NotificationChannel
	enabled         *bool
	dingtalk_config *map[string]interface{}
	max_retry       *int
	addmax_retry    *int
	timeout         *int
	addtimeout      *int
	description     *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*NotificationSetting, error)
	predicates      []predicate.NotificationSetting
}

var _ ent.Mutation = (*NotificationSettingMutation)(nil)

// notificationsettingOption allows management of the mutation configuration using functional options.
type notificationsettingOption func(*NotificationSettingMutation)

// newNotificationSettingMutation creates new mutation for the NotificationSetting entity.
func newNotificationSettingMutation(c config, op Op, opts ...notificationsettingOption) *NotificationSettingMutation {
	m := &NotificationSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationSettingID sets the ID field of the mutation.
func withNotificationSettingID(id uuid.UUID) notificationsettingOption {
	return func(m *NotificationSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationSetting
		)
		m.oldValue = func(ctx context.Context) (*NotificationSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationSetting sets the old NotificationSetting of the mutation.
func withNotificationSetting(node *NotificationSetting) notificationsettingOption {
	return func(m *NotificationSettingMutation) {
		m.oldValue = func(context.Context) (*NotificationSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationSetting entities.
func (m *NotificationSettingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationSettingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationSettingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationSettingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationSettingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationSettingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notificationsetting.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationSettingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationSettingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notificationsetting.FieldDeletedAt)
}

// SetChannel sets the "channel" field.
func (m *NotificationSettingMutation) SetChannel(cc consts.NotificationChannel) {
	m.channel = &cc
}

// Channel returns the value of the "channel" field in the mutation.
func (m *NotificationSettingMutation) Channel() (r consts.NotificationChannel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldChannel(ctx context.Context) (v consts.NotificationChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *NotificationSettingMutation) ResetChannel() {
	m.channel = nil
}

// SetEnabled sets the "enabled" field.
func (m *NotificationSettingMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NotificationSettingMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NotificationSettingMutation) ResetEnabled() {
	m.enabled = nil
}

// SetDingtalkConfig sets the "dingtalk_config" field.
func (m *NotificationSettingMutation) SetDingtalkConfig(value map[string]interface{}) {
	m.dingtalk_config = &value
}

// DingtalkConfig returns the value of the "dingtalk_config" field in the mutation.
func (m *NotificationSettingMutation) DingtalkConfig() (r map[string]interface{}, exists bool) {
	v := m.dingtalk_config
	if v == nil {
		return
	}
	return *v, true
}

// OldDingtalkConfig returns the old "dingtalk_config" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldDingtalkConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDingtalkConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDingtalkConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDingtalkConfig: %w", err)
	}
	return oldValue.DingtalkConfig, nil
}

// ClearDingtalkConfig clears the value of the "dingtalk_config" field.
func (m *NotificationSettingMutation) ClearDingtalkConfig() {
	m.dingtalk_config = nil
	m.clearedFields[notificationsetting.FieldDingtalkConfig] = struct{}{}
}

// DingtalkConfigCleared returns if the "dingtalk_config" field was cleared in this mutation.
func (m *NotificationSettingMutation) DingtalkConfigCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldDingtalkConfig]
	return ok
}

// ResetDingtalkConfig resets all changes to the "dingtalk_config" field.
func (m *NotificationSettingMutation) ResetDingtalkConfig() {
	m.dingtalk_config = nil
	delete(m.clearedFields, notificationsetting.FieldDingtalkConfig)
}

// SetMaxRetry sets the "max_retry" field.
func (m *NotificationSettingMutation) SetMaxRetry(i int) {
	m.max_retry = &i
	m.addmax_retry = nil
}

// MaxRetry returns the value of the "max_retry" field in the mutation.
func (m *NotificationSettingMutation) MaxRetry() (r int, exists bool) {
	v := m.max_retry
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRetry returns the old "max_retry" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldMaxRetry(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRetry: %w", err)
	}
	return oldValue.MaxRetry, nil
}

// AddMaxRetry adds i to the "max_retry" field.
func (m *NotificationSettingMutation) AddMaxRetry(i int) {
	if m.addmax_retry != nil {
		*m.addmax_retry += i
	} else {
		m.addmax_retry = &i
	}
}

// AddedMaxRetry returns the value that was added to the "max_retry" field in this mutation.
func (m *NotificationSettingMutation) AddedMaxRetry() (r int, exists bool) {
	v := m.addmax_retry
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxRetry resets all changes to the "max_retry" field.
func (m *NotificationSettingMutation) ResetMaxRetry() {
	m.max_retry = nil
	m.addmax_retry = nil
}

// SetTimeout sets the "timeout" field.
func (m *NotificationSettingMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *NotificationSettingMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *NotificationSettingMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *NotificationSettingMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *NotificationSettingMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetDescription sets the "description" field.
func (m *NotificationSettingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotificationSettingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NotificationSettingMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[notificationsetting.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NotificationSettingMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[notificationsetting.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NotificationSettingMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, notificationsetting.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationSettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationSetting entity.
// If the NotificationSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the NotificationSettingMutation builder.
func (m *NotificationSettingMutation) Where(ps ...predicate.NotificationSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationSetting).
func (m *NotificationSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationSettingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, notificationsetting.FieldDeletedAt)
	}
	if m.channel != nil {
		fields = append(fields, notificationsetting.FieldChannel)
	}
	if m.enabled != nil {
		fields = append(fields, notificationsetting.FieldEnabled)
	}
	if m.dingtalk_config != nil {
		fields = append(fields, notificationsetting.FieldDingtalkConfig)
	}
	if m.max_retry != nil {
		fields = append(fields, notificationsetting.FieldMaxRetry)
	}
	if m.timeout != nil {
		fields = append(fields, notificationsetting.FieldTimeout)
	}
	if m.description != nil {
		fields = append(fields, notificationsetting.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, notificationsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationsetting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationsetting.FieldDeletedAt:
		return m.DeletedAt()
	case notificationsetting.FieldChannel:
		return m.Channel()
	case notificationsetting.FieldEnabled:
		return m.Enabled()
	case notificationsetting.FieldDingtalkConfig:
		return m.DingtalkConfig()
	case notificationsetting.FieldMaxRetry:
		return m.MaxRetry()
	case notificationsetting.FieldTimeout:
		return m.Timeout()
	case notificationsetting.FieldDescription:
		return m.Description()
	case notificationsetting.FieldCreatedAt:
		return m.CreatedAt()
	case notificationsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationsetting.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notificationsetting.FieldChannel:
		return m.OldChannel(ctx)
	case notificationsetting.FieldEnabled:
		return m.OldEnabled(ctx)
	case notificationsetting.FieldDingtalkConfig:
		return m.OldDingtalkConfig(ctx)
	case notificationsetting.FieldMaxRetry:
		return m.OldMaxRetry(ctx)
	case notificationsetting.FieldTimeout:
		return m.OldTimeout(ctx)
	case notificationsetting.FieldDescription:
		return m.OldDescription(ctx)
	case notificationsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationsetting.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notificationsetting.FieldChannel:
		v, ok := value.(consts.NotificationChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case notificationsetting.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case notificationsetting.FieldDingtalkConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDingtalkConfig(v)
		return nil
	case notificationsetting.FieldMaxRetry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRetry(v)
		return nil
	case notificationsetting.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case notificationsetting.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notificationsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationSettingMutation) AddedFields() []string {
	var fields []string
	if m.addmax_retry != nil {
		fields = append(fields, notificationsetting.FieldMaxRetry)
	}
	if m.addtimeout != nil {
		fields = append(fields, notificationsetting.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notificationsetting.FieldMaxRetry:
		return m.AddedMaxRetry()
	case notificationsetting.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notificationsetting.FieldMaxRetry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRetry(v)
		return nil
	case notificationsetting.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notificationsetting.FieldDeletedAt) {
		fields = append(fields, notificationsetting.FieldDeletedAt)
	}
	if m.FieldCleared(notificationsetting.FieldDingtalkConfig) {
		fields = append(fields, notificationsetting.FieldDingtalkConfig)
	}
	if m.FieldCleared(notificationsetting.FieldDescription) {
		fields = append(fields, notificationsetting.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationSettingMutation) ClearField(name string) error {
	switch name {
	case notificationsetting.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case notificationsetting.FieldDingtalkConfig:
		m.ClearDingtalkConfig()
		return nil
	case notificationsetting.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationSettingMutation) ResetField(name string) error {
	switch name {
	case notificationsetting.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notificationsetting.FieldChannel:
		m.ResetChannel()
		return nil
	case notificationsetting.FieldEnabled:
		m.ResetEnabled()
		return nil
	case notificationsetting.FieldDingtalkConfig:
		m.ResetDingtalkConfig()
		return nil
	case notificationsetting.FieldMaxRetry:
		m.ResetMaxRetry()
		return nil
	case notificationsetting.FieldTimeout:
		m.ResetTimeout()
		return nil
	case notificationsetting.FieldDescription:
		m.ResetDescription()
		return nil
	case notificationsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotificationSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationSetting edge %s", name)
}

// ResumeMutation represents an operation that mutates the Resume nodes in the graph.
type ResumeMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	deleted_at                    *time.Time
	name                          *string
	gender                        *string
	birthday                      *time.Time
	email                         *string
	phone                         *string
	current_city                  *string
	highest_education             *string
	years_experience              *float64
	addyears_experience           *float64
	resume_file_url               *string
	status                        *string
	error_message                 *string
	parsed_at                     *time.Time
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	user                          *uuid.UUID
	cleareduser                   bool
	educations                    map[uuid.UUID]struct{}
	removededucations             map[uuid.UUID]struct{}
	clearededucations             bool
	experiences                   map[uuid.UUID]struct{}
	removedexperiences            map[uuid.UUID]struct{}
	clearedexperiences            bool
	projects                      map[uuid.UUID]struct{}
	removedprojects               map[uuid.UUID]struct{}
	clearedprojects               bool
	skills                        map[uuid.UUID]struct{}
	removedskills                 map[uuid.UUID]struct{}
	clearedskills                 bool
	logs                          map[uuid.UUID]struct{}
	removedlogs                   map[uuid.UUID]struct{}
	clearedlogs                   bool
	document_parse                map[uuid.UUID]struct{}
	removeddocument_parse         map[uuid.UUID]struct{}
	cleareddocument_parse         bool
	job_applications              map[uuid.UUID]struct{}
	removedjob_applications       map[uuid.UUID]struct{}
	clearedjob_applications       bool
	screening_task_resumes        map[uuid.UUID]struct{}
	removedscreening_task_resumes map[uuid.UUID]struct{}
	clearedscreening_task_resumes bool
	screening_results             map[uuid.UUID]struct{}
	removedscreening_results      map[uuid.UUID]struct{}
	clearedscreening_results      bool
	done                          bool
	oldValue                      func(context.Context) (*Resume, error)
	predicates                    []predicate.Resume
}

var _ ent.Mutation = (*ResumeMutation)(nil)

// resumeOption allows management of the mutation configuration using functional options.
type resumeOption func(*ResumeMutation)

// newResumeMutation creates new mutation for the Resume entity.
func newResumeMutation(c config, op Op, opts ...resumeOption) *ResumeMutation {
	m := &ResumeMutation{
		config:        c,
		op:            op,
		typ:           TypeResume,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeID sets the ID field of the mutation.
func withResumeID(id uuid.UUID) resumeOption {
	return func(m *ResumeMutation) {
		var (
			err   error
			once  sync.Once
			value *Resume
		)
		m.oldValue = func(ctx context.Context) (*Resume, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resume.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResume sets the old Resume of the mutation.
func withResume(node *Resume) resumeOption {
	return func(m *ResumeMutation) {
		m.oldValue = func(context.Context) (*Resume, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Resume entities.
func (m *ResumeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resume.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resume.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resume.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resume.FieldDeletedAt)
}

// SetUploaderID sets the "uploader_id" field.
func (m *ResumeMutation) SetUploaderID(u uuid.UUID) {
	m.user = &u
}

// UploaderID returns the value of the "uploader_id" field in the mutation.
func (m *ResumeMutation) UploaderID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUploaderID returns the old "uploader_id" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldUploaderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploaderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploaderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploaderID: %w", err)
	}
	return oldValue.UploaderID, nil
}

// ResetUploaderID resets all changes to the "uploader_id" field.
func (m *ResumeMutation) ResetUploaderID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *ResumeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResumeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ResumeMutation) ClearName() {
	m.name = nil
	m.clearedFields[resume.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ResumeMutation) NameCleared() bool {
	_, ok := m.clearedFields[resume.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ResumeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, resume.FieldName)
}

// SetGender sets the "gender" field.
func (m *ResumeMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *ResumeMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *ResumeMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[resume.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *ResumeMutation) GenderCleared() bool {
	_, ok := m.clearedFields[resume.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *ResumeMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, resume.FieldGender)
}

// SetBirthday sets the "birthday" field.
func (m *ResumeMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *ResumeMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *ResumeMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[resume.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *ResumeMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[resume.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *ResumeMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, resume.FieldBirthday)
}

// SetEmail sets the "email" field.
func (m *ResumeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ResumeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ResumeMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[resume.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ResumeMutation) EmailCleared() bool {
	_, ok := m.clearedFields[resume.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ResumeMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, resume.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *ResumeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ResumeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *ResumeMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[resume.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *ResumeMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[resume.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *ResumeMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, resume.FieldPhone)
}

// SetCurrentCity sets the "current_city" field.
func (m *ResumeMutation) SetCurrentCity(s string) {
	m.current_city = &s
}

// CurrentCity returns the value of the "current_city" field in the mutation.
func (m *ResumeMutation) CurrentCity() (r string, exists bool) {
	v := m.current_city
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentCity returns the old "current_city" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldCurrentCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentCity: %w", err)
	}
	return oldValue.CurrentCity, nil
}

// ClearCurrentCity clears the value of the "current_city" field.
func (m *ResumeMutation) ClearCurrentCity() {
	m.current_city = nil
	m.clearedFields[resume.FieldCurrentCity] = struct{}{}
}

// CurrentCityCleared returns if the "current_city" field was cleared in this mutation.
func (m *ResumeMutation) CurrentCityCleared() bool {
	_, ok := m.clearedFields[resume.FieldCurrentCity]
	return ok
}

// ResetCurrentCity resets all changes to the "current_city" field.
func (m *ResumeMutation) ResetCurrentCity() {
	m.current_city = nil
	delete(m.clearedFields, resume.FieldCurrentCity)
}

// SetHighestEducation sets the "highest_education" field.
func (m *ResumeMutation) SetHighestEducation(s string) {
	m.highest_education = &s
}

// HighestEducation returns the value of the "highest_education" field in the mutation.
func (m *ResumeMutation) HighestEducation() (r string, exists bool) {
	v := m.highest_education
	if v == nil {
		return
	}
	return *v, true
}

// OldHighestEducation returns the old "highest_education" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldHighestEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighestEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighestEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighestEducation: %w", err)
	}
	return oldValue.HighestEducation, nil
}

// ClearHighestEducation clears the value of the "highest_education" field.
func (m *ResumeMutation) ClearHighestEducation() {
	m.highest_education = nil
	m.clearedFields[resume.FieldHighestEducation] = struct{}{}
}

// HighestEducationCleared returns if the "highest_education" field was cleared in this mutation.
func (m *ResumeMutation) HighestEducationCleared() bool {
	_, ok := m.clearedFields[resume.FieldHighestEducation]
	return ok
}

// ResetHighestEducation resets all changes to the "highest_education" field.
func (m *ResumeMutation) ResetHighestEducation() {
	m.highest_education = nil
	delete(m.clearedFields, resume.FieldHighestEducation)
}

// SetYearsExperience sets the "years_experience" field.
func (m *ResumeMutation) SetYearsExperience(f float64) {
	m.years_experience = &f
	m.addyears_experience = nil
}

// YearsExperience returns the value of the "years_experience" field in the mutation.
func (m *ResumeMutation) YearsExperience() (r float64, exists bool) {
	v := m.years_experience
	if v == nil {
		return
	}
	return *v, true
}

// OldYearsExperience returns the old "years_experience" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldYearsExperience(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYearsExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYearsExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearsExperience: %w", err)
	}
	return oldValue.YearsExperience, nil
}

// AddYearsExperience adds f to the "years_experience" field.
func (m *ResumeMutation) AddYearsExperience(f float64) {
	if m.addyears_experience != nil {
		*m.addyears_experience += f
	} else {
		m.addyears_experience = &f
	}
}

// AddedYearsExperience returns the value that was added to the "years_experience" field in this mutation.
func (m *ResumeMutation) AddedYearsExperience() (r float64, exists bool) {
	v := m.addyears_experience
	if v == nil {
		return
	}
	return *v, true
}

// ClearYearsExperience clears the value of the "years_experience" field.
func (m *ResumeMutation) ClearYearsExperience() {
	m.years_experience = nil
	m.addyears_experience = nil
	m.clearedFields[resume.FieldYearsExperience] = struct{}{}
}

// YearsExperienceCleared returns if the "years_experience" field was cleared in this mutation.
func (m *ResumeMutation) YearsExperienceCleared() bool {
	_, ok := m.clearedFields[resume.FieldYearsExperience]
	return ok
}

// ResetYearsExperience resets all changes to the "years_experience" field.
func (m *ResumeMutation) ResetYearsExperience() {
	m.years_experience = nil
	m.addyears_experience = nil
	delete(m.clearedFields, resume.FieldYearsExperience)
}

// SetResumeFileURL sets the "resume_file_url" field.
func (m *ResumeMutation) SetResumeFileURL(s string) {
	m.resume_file_url = &s
}

// ResumeFileURL returns the value of the "resume_file_url" field in the mutation.
func (m *ResumeMutation) ResumeFileURL() (r string, exists bool) {
	v := m.resume_file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeFileURL returns the old "resume_file_url" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldResumeFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeFileURL: %w", err)
	}
	return oldValue.ResumeFileURL, nil
}

// ClearResumeFileURL clears the value of the "resume_file_url" field.
func (m *ResumeMutation) ClearResumeFileURL() {
	m.resume_file_url = nil
	m.clearedFields[resume.FieldResumeFileURL] = struct{}{}
}

// ResumeFileURLCleared returns if the "resume_file_url" field was cleared in this mutation.
func (m *ResumeMutation) ResumeFileURLCleared() bool {
	_, ok := m.clearedFields[resume.FieldResumeFileURL]
	return ok
}

// ResetResumeFileURL resets all changes to the "resume_file_url" field.
func (m *ResumeMutation) ResetResumeFileURL() {
	m.resume_file_url = nil
	delete(m.clearedFields, resume.FieldResumeFileURL)
}

// SetStatus sets the "status" field.
func (m *ResumeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ResumeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ResumeMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ResumeMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ResumeMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ResumeMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[resume.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ResumeMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[resume.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ResumeMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, resume.FieldErrorMessage)
}

// SetParsedAt sets the "parsed_at" field.
func (m *ResumeMutation) SetParsedAt(t time.Time) {
	m.parsed_at = &t
}

// ParsedAt returns the value of the "parsed_at" field in the mutation.
func (m *ResumeMutation) ParsedAt() (r time.Time, exists bool) {
	v := m.parsed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldParsedAt returns the old "parsed_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldParsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParsedAt: %w", err)
	}
	return oldValue.ParsedAt, nil
}

// ClearParsedAt clears the value of the "parsed_at" field.
func (m *ResumeMutation) ClearParsedAt() {
	m.parsed_at = nil
	m.clearedFields[resume.FieldParsedAt] = struct{}{}
}

// ParsedAtCleared returns if the "parsed_at" field was cleared in this mutation.
func (m *ResumeMutation) ParsedAtCleared() bool {
	_, ok := m.clearedFields[resume.FieldParsedAt]
	return ok
}

// ResetParsedAt resets all changes to the "parsed_at" field.
func (m *ResumeMutation) ResetParsedAt() {
	m.parsed_at = nil
	delete(m.clearedFields, resume.FieldParsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resume entity.
// If the Resume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ResumeMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ResumeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[resume.FieldUploaderID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ResumeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ResumeMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ResumeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ResumeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddEducationIDs adds the "educations" edge to the ResumeEducation entity by ids.
func (m *ResumeMutation) AddEducationIDs(ids ...uuid.UUID) {
	if m.educations == nil {
		m.educations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.educations[ids[i]] = struct{}{}
	}
}

// ClearEducations clears the "educations" edge to the ResumeEducation entity.
func (m *ResumeMutation) ClearEducations() {
	m.clearededucations = true
}

// EducationsCleared reports if the "educations" edge to the ResumeEducation entity was cleared.
func (m *ResumeMutation) EducationsCleared() bool {
	return m.clearededucations
}

// RemoveEducationIDs removes the "educations" edge to the ResumeEducation entity by IDs.
func (m *ResumeMutation) RemoveEducationIDs(ids ...uuid.UUID) {
	if m.removededucations == nil {
		m.removededucations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.educations, ids[i])
		m.removededucations[ids[i]] = struct{}{}
	}
}

// RemovedEducations returns the removed IDs of the "educations" edge to the ResumeEducation entity.
func (m *ResumeMutation) RemovedEducationsIDs() (ids []uuid.UUID) {
	for id := range m.removededucations {
		ids = append(ids, id)
	}
	return
}

// EducationsIDs returns the "educations" edge IDs in the mutation.
func (m *ResumeMutation) EducationsIDs() (ids []uuid.UUID) {
	for id := range m.educations {
		ids = append(ids, id)
	}
	return
}

// ResetEducations resets all changes to the "educations" edge.
func (m *ResumeMutation) ResetEducations() {
	m.educations = nil
	m.clearededucations = false
	m.removededucations = nil
}

// AddExperienceIDs adds the "experiences" edge to the ResumeExperience entity by ids.
func (m *ResumeMutation) AddExperienceIDs(ids ...uuid.UUID) {
	if m.experiences == nil {
		m.experiences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.experiences[ids[i]] = struct{}{}
	}
}

// ClearExperiences clears the "experiences" edge to the ResumeExperience entity.
func (m *ResumeMutation) ClearExperiences() {
	m.clearedexperiences = true
}

// ExperiencesCleared reports if the "experiences" edge to the ResumeExperience entity was cleared.
func (m *ResumeMutation) ExperiencesCleared() bool {
	return m.clearedexperiences
}

// RemoveExperienceIDs removes the "experiences" edge to the ResumeExperience entity by IDs.
func (m *ResumeMutation) RemoveExperienceIDs(ids ...uuid.UUID) {
	if m.removedexperiences == nil {
		m.removedexperiences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.experiences, ids[i])
		m.removedexperiences[ids[i]] = struct{}{}
	}
}

// RemovedExperiences returns the removed IDs of the "experiences" edge to the ResumeExperience entity.
func (m *ResumeMutation) RemovedExperiencesIDs() (ids []uuid.UUID) {
	for id := range m.removedexperiences {
		ids = append(ids, id)
	}
	return
}

// ExperiencesIDs returns the "experiences" edge IDs in the mutation.
func (m *ResumeMutation) ExperiencesIDs() (ids []uuid.UUID) {
	for id := range m.experiences {
		ids = append(ids, id)
	}
	return
}

// ResetExperiences resets all changes to the "experiences" edge.
func (m *ResumeMutation) ResetExperiences() {
	m.experiences = nil
	m.clearedexperiences = false
	m.removedexperiences = nil
}

// AddProjectIDs adds the "projects" edge to the ResumeProject entity by ids.
func (m *ResumeMutation) AddProjectIDs(ids ...uuid.UUID) {
	if m.projects == nil {
		m.projects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the ResumeProject entity.
func (m *ResumeMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the ResumeProject entity was cleared.
func (m *ResumeMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the ResumeProject entity by IDs.
func (m *ResumeMutation) RemoveProjectIDs(ids ...uuid.UUID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the ResumeProject entity.
func (m *ResumeMutation) RemovedProjectsIDs() (ids []uuid.UUID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *ResumeMutation) ProjectsIDs() (ids []uuid.UUID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *ResumeMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddSkillIDs adds the "skills" edge to the ResumeSkill entity by ids.
func (m *ResumeMutation) AddSkillIDs(ids ...uuid.UUID) {
	if m.skills == nil {
		m.skills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the ResumeSkill entity.
func (m *ResumeMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the ResumeSkill entity was cleared.
func (m *ResumeMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the ResumeSkill entity by IDs.
func (m *ResumeMutation) RemoveSkillIDs(ids ...uuid.UUID) {
	if m.removedskills == nil {
		m.removedskills = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the ResumeSkill entity.
func (m *ResumeMutation) RemovedSkillsIDs() (ids []uuid.UUID) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *ResumeMutation) SkillsIDs() (ids []uuid.UUID) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *ResumeMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// AddLogIDs adds the "logs" edge to the ResumeLog entity by ids.
func (m *ResumeMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the ResumeLog entity.
func (m *ResumeMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the ResumeLog entity was cleared.
func (m *ResumeMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the ResumeLog entity by IDs.
func (m *ResumeMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the ResumeLog entity.
func (m *ResumeMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *ResumeMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *ResumeMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddDocumentParseIDs adds the "document_parse" edge to the ResumeDocumentParse entity by ids.
func (m *ResumeMutation) AddDocumentParseIDs(ids ...uuid.UUID) {
	if m.document_parse == nil {
		m.document_parse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.document_parse[ids[i]] = struct{}{}
	}
}

// ClearDocumentParse clears the "document_parse" edge to the ResumeDocumentParse entity.
func (m *ResumeMutation) ClearDocumentParse() {
	m.cleareddocument_parse = true
}

// DocumentParseCleared reports if the "document_parse" edge to the ResumeDocumentParse entity was cleared.
func (m *ResumeMutation) DocumentParseCleared() bool {
	return m.cleareddocument_parse
}

// RemoveDocumentParseIDs removes the "document_parse" edge to the ResumeDocumentParse entity by IDs.
func (m *ResumeMutation) RemoveDocumentParseIDs(ids ...uuid.UUID) {
	if m.removeddocument_parse == nil {
		m.removeddocument_parse = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.document_parse, ids[i])
		m.removeddocument_parse[ids[i]] = struct{}{}
	}
}

// RemovedDocumentParse returns the removed IDs of the "document_parse" edge to the ResumeDocumentParse entity.
func (m *ResumeMutation) RemovedDocumentParseIDs() (ids []uuid.UUID) {
	for id := range m.removeddocument_parse {
		ids = append(ids, id)
	}
	return
}

// DocumentParseIDs returns the "document_parse" edge IDs in the mutation.
func (m *ResumeMutation) DocumentParseIDs() (ids []uuid.UUID) {
	for id := range m.document_parse {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentParse resets all changes to the "document_parse" edge.
func (m *ResumeMutation) ResetDocumentParse() {
	m.document_parse = nil
	m.cleareddocument_parse = false
	m.removeddocument_parse = nil
}

// AddJobApplicationIDs adds the "job_applications" edge to the ResumeJobApplication entity by ids.
func (m *ResumeMutation) AddJobApplicationIDs(ids ...uuid.UUID) {
	if m.job_applications == nil {
		m.job_applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.job_applications[ids[i]] = struct{}{}
	}
}

// ClearJobApplications clears the "job_applications" edge to the ResumeJobApplication entity.
func (m *ResumeMutation) ClearJobApplications() {
	m.clearedjob_applications = true
}

// JobApplicationsCleared reports if the "job_applications" edge to the ResumeJobApplication entity was cleared.
func (m *ResumeMutation) JobApplicationsCleared() bool {
	return m.clearedjob_applications
}

// RemoveJobApplicationIDs removes the "job_applications" edge to the ResumeJobApplication entity by IDs.
func (m *ResumeMutation) RemoveJobApplicationIDs(ids ...uuid.UUID) {
	if m.removedjob_applications == nil {
		m.removedjob_applications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.job_applications, ids[i])
		m.removedjob_applications[ids[i]] = struct{}{}
	}
}

// RemovedJobApplications returns the removed IDs of the "job_applications" edge to the ResumeJobApplication entity.
func (m *ResumeMutation) RemovedJobApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedjob_applications {
		ids = append(ids, id)
	}
	return
}

// JobApplicationsIDs returns the "job_applications" edge IDs in the mutation.
func (m *ResumeMutation) JobApplicationsIDs() (ids []uuid.UUID) {
	for id := range m.job_applications {
		ids = append(ids, id)
	}
	return
}

// ResetJobApplications resets all changes to the "job_applications" edge.
func (m *ResumeMutation) ResetJobApplications() {
	m.job_applications = nil
	m.clearedjob_applications = false
	m.removedjob_applications = nil
}

// AddScreeningTaskResumeIDs adds the "screening_task_resumes" edge to the ScreeningTaskResume entity by ids.
func (m *ResumeMutation) AddScreeningTaskResumeIDs(ids ...uuid.UUID) {
	if m.screening_task_resumes == nil {
		m.screening_task_resumes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.screening_task_resumes[ids[i]] = struct{}{}
	}
}

// ClearScreeningTaskResumes clears the "screening_task_resumes" edge to the ScreeningTaskResume entity.
func (m *ResumeMutation) ClearScreeningTaskResumes() {
	m.clearedscreening_task_resumes = true
}

// ScreeningTaskResumesCleared reports if the "screening_task_resumes" edge to the ScreeningTaskResume entity was cleared.
func (m *ResumeMutation) ScreeningTaskResumesCleared() bool {
	return m.clearedscreening_task_resumes
}

// RemoveScreeningTaskResumeIDs removes the "screening_task_resumes" edge to the ScreeningTaskResume entity by IDs.
func (m *ResumeMutation) RemoveScreeningTaskResumeIDs(ids ...uuid.UUID) {
	if m.removedscreening_task_resumes == nil {
		m.removedscreening_task_resumes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.screening_task_resumes, ids[i])
		m.removedscreening_task_resumes[ids[i]] = struct{}{}
	}
}

// RemovedScreeningTaskResumes returns the removed IDs of the "screening_task_resumes" edge to the ScreeningTaskResume entity.
func (m *ResumeMutation) RemovedScreeningTaskResumesIDs() (ids []uuid.UUID) {
	for id := range m.removedscreening_task_resumes {
		ids = append(ids, id)
	}
	return
}

// ScreeningTaskResumesIDs returns the "screening_task_resumes" edge IDs in the mutation.
func (m *ResumeMutation) ScreeningTaskResumesIDs() (ids []uuid.UUID) {
	for id := range m.screening_task_resumes {
		ids = append(ids, id)
	}
	return
}

// ResetScreeningTaskResumes resets all changes to the "screening_task_resumes" edge.
func (m *ResumeMutation) ResetScreeningTaskResumes() {
	m.screening_task_resumes = nil
	m.clearedscreening_task_resumes = false
	m.removedscreening_task_resumes = nil
}

// AddScreeningResultIDs adds the "screening_results" edge to the ScreeningResult entity by ids.
func (m *ResumeMutation) AddScreeningResultIDs(ids ...uuid.UUID) {
	if m.screening_results == nil {
		m.screening_results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.screening_results[ids[i]] = struct{}{}
	}
}

// ClearScreeningResults clears the "screening_results" edge to the ScreeningResult entity.
func (m *ResumeMutation) ClearScreeningResults() {
	m.clearedscreening_results = true
}

// ScreeningResultsCleared reports if the "screening_results" edge to the ScreeningResult entity was cleared.
func (m *ResumeMutation) ScreeningResultsCleared() bool {
	return m.clearedscreening_results
}

// RemoveScreeningResultIDs removes the "screening_results" edge to the ScreeningResult entity by IDs.
func (m *ResumeMutation) RemoveScreeningResultIDs(ids ...uuid.UUID) {
	if m.removedscreening_results == nil {
		m.removedscreening_results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.screening_results, ids[i])
		m.removedscreening_results[ids[i]] = struct{}{}
	}
}

// RemovedScreeningResults returns the removed IDs of the "screening_results" edge to the ScreeningResult entity.
func (m *ResumeMutation) RemovedScreeningResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedscreening_results {
		ids = append(ids, id)
	}
	return
}

// ScreeningResultsIDs returns the "screening_results" edge IDs in the mutation.
func (m *ResumeMutation) ScreeningResultsIDs() (ids []uuid.UUID) {
	for id := range m.screening_results {
		ids = append(ids, id)
	}
	return
}

// ResetScreeningResults resets all changes to the "screening_results" edge.
func (m *ResumeMutation) ResetScreeningResults() {
	m.screening_results = nil
	m.clearedscreening_results = false
	m.removedscreening_results = nil
}

// Where appends a list predicates to the ResumeMutation builder.
func (m *ResumeMutation) Where(ps ...predicate.Resume) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resume, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resume).
func (m *ResumeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.deleted_at != nil {
		fields = append(fields, resume.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, resume.FieldUploaderID)
	}
	if m.name != nil {
		fields = append(fields, resume.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, resume.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, resume.FieldBirthday)
	}
	if m.email != nil {
		fields = append(fields, resume.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, resume.FieldPhone)
	}
	if m.current_city != nil {
		fields = append(fields, resume.FieldCurrentCity)
	}
	if m.highest_education != nil {
		fields = append(fields, resume.FieldHighestEducation)
	}
	if m.years_experience != nil {
		fields = append(fields, resume.FieldYearsExperience)
	}
	if m.resume_file_url != nil {
		fields = append(fields, resume.FieldResumeFileURL)
	}
	if m.status != nil {
		fields = append(fields, resume.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, resume.FieldErrorMessage)
	}
	if m.parsed_at != nil {
		fields = append(fields, resume.FieldParsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, resume.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resume.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resume.FieldDeletedAt:
		return m.DeletedAt()
	case resume.FieldUploaderID:
		return m.UploaderID()
	case resume.FieldName:
		return m.Name()
	case resume.FieldGender:
		return m.Gender()
	case resume.FieldBirthday:
		return m.Birthday()
	case resume.FieldEmail:
		return m.Email()
	case resume.FieldPhone:
		return m.Phone()
	case resume.FieldCurrentCity:
		return m.CurrentCity()
	case resume.FieldHighestEducation:
		return m.HighestEducation()
	case resume.FieldYearsExperience:
		return m.YearsExperience()
	case resume.FieldResumeFileURL:
		return m.ResumeFileURL()
	case resume.FieldStatus:
		return m.Status()
	case resume.FieldErrorMessage:
		return m.ErrorMessage()
	case resume.FieldParsedAt:
		return m.ParsedAt()
	case resume.FieldCreatedAt:
		return m.CreatedAt()
	case resume.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resume.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resume.FieldUploaderID:
		return m.OldUploaderID(ctx)
	case resume.FieldName:
		return m.OldName(ctx)
	case resume.FieldGender:
		return m.OldGender(ctx)
	case resume.FieldBirthday:
		return m.OldBirthday(ctx)
	case resume.FieldEmail:
		return m.OldEmail(ctx)
	case resume.FieldPhone:
		return m.OldPhone(ctx)
	case resume.FieldCurrentCity:
		return m.OldCurrentCity(ctx)
	case resume.FieldHighestEducation:
		return m.OldHighestEducation(ctx)
	case resume.FieldYearsExperience:
		return m.OldYearsExperience(ctx)
	case resume.FieldResumeFileURL:
		return m.OldResumeFileURL(ctx)
	case resume.FieldStatus:
		return m.OldStatus(ctx)
	case resume.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case resume.FieldParsedAt:
		return m.OldParsedAt(ctx)
	case resume.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resume.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Resume field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resume.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resume.FieldUploaderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploaderID(v)
		return nil
	case resume.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resume.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case resume.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case resume.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case resume.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case resume.FieldCurrentCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentCity(v)
		return nil
	case resume.FieldHighestEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighestEducation(v)
		return nil
	case resume.FieldYearsExperience:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearsExperience(v)
		return nil
	case resume.FieldResumeFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeFileURL(v)
		return nil
	case resume.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resume.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case resume.FieldParsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParsedAt(v)
		return nil
	case resume.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resume.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Resume field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeMutation) AddedFields() []string {
	var fields []string
	if m.addyears_experience != nil {
		fields = append(fields, resume.FieldYearsExperience)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resume.FieldYearsExperience:
		return m.AddedYearsExperience()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resume.FieldYearsExperience:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYearsExperience(v)
		return nil
	}
	return fmt.Errorf("unknown Resume numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resume.FieldDeletedAt) {
		fields = append(fields, resume.FieldDeletedAt)
	}
	if m.FieldCleared(resume.FieldName) {
		fields = append(fields, resume.FieldName)
	}
	if m.FieldCleared(resume.FieldGender) {
		fields = append(fields, resume.FieldGender)
	}
	if m.FieldCleared(resume.FieldBirthday) {
		fields = append(fields, resume.FieldBirthday)
	}
	if m.FieldCleared(resume.FieldEmail) {
		fields = append(fields, resume.FieldEmail)
	}
	if m.FieldCleared(resume.FieldPhone) {
		fields = append(fields, resume.FieldPhone)
	}
	if m.FieldCleared(resume.FieldCurrentCity) {
		fields = append(fields, resume.FieldCurrentCity)
	}
	if m.FieldCleared(resume.FieldHighestEducation) {
		fields = append(fields, resume.FieldHighestEducation)
	}
	if m.FieldCleared(resume.FieldYearsExperience) {
		fields = append(fields, resume.FieldYearsExperience)
	}
	if m.FieldCleared(resume.FieldResumeFileURL) {
		fields = append(fields, resume.FieldResumeFileURL)
	}
	if m.FieldCleared(resume.FieldErrorMessage) {
		fields = append(fields, resume.FieldErrorMessage)
	}
	if m.FieldCleared(resume.FieldParsedAt) {
		fields = append(fields, resume.FieldParsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeMutation) ClearField(name string) error {
	switch name {
	case resume.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resume.FieldName:
		m.ClearName()
		return nil
	case resume.FieldGender:
		m.ClearGender()
		return nil
	case resume.FieldBirthday:
		m.ClearBirthday()
		return nil
	case resume.FieldEmail:
		m.ClearEmail()
		return nil
	case resume.FieldPhone:
		m.ClearPhone()
		return nil
	case resume.FieldCurrentCity:
		m.ClearCurrentCity()
		return nil
	case resume.FieldHighestEducation:
		m.ClearHighestEducation()
		return nil
	case resume.FieldYearsExperience:
		m.ClearYearsExperience()
		return nil
	case resume.FieldResumeFileURL:
		m.ClearResumeFileURL()
		return nil
	case resume.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case resume.FieldParsedAt:
		m.ClearParsedAt()
		return nil
	}
	return fmt.Errorf("unknown Resume nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeMutation) ResetField(name string) error {
	switch name {
	case resume.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resume.FieldUploaderID:
		m.ResetUploaderID()
		return nil
	case resume.FieldName:
		m.ResetName()
		return nil
	case resume.FieldGender:
		m.ResetGender()
		return nil
	case resume.FieldBirthday:
		m.ResetBirthday()
		return nil
	case resume.FieldEmail:
		m.ResetEmail()
		return nil
	case resume.FieldPhone:
		m.ResetPhone()
		return nil
	case resume.FieldCurrentCity:
		m.ResetCurrentCity()
		return nil
	case resume.FieldHighestEducation:
		m.ResetHighestEducation()
		return nil
	case resume.FieldYearsExperience:
		m.ResetYearsExperience()
		return nil
	case resume.FieldResumeFileURL:
		m.ResetResumeFileURL()
		return nil
	case resume.FieldStatus:
		m.ResetStatus()
		return nil
	case resume.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case resume.FieldParsedAt:
		m.ResetParsedAt()
		return nil
	case resume.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resume.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Resume field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.user != nil {
		edges = append(edges, resume.EdgeUser)
	}
	if m.educations != nil {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.experiences != nil {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.projects != nil {
		edges = append(edges, resume.EdgeProjects)
	}
	if m.skills != nil {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.logs != nil {
		edges = append(edges, resume.EdgeLogs)
	}
	if m.document_parse != nil {
		edges = append(edges, resume.EdgeDocumentParse)
	}
	if m.job_applications != nil {
		edges = append(edges, resume.EdgeJobApplications)
	}
	if m.screening_task_resumes != nil {
		edges = append(edges, resume.EdgeScreeningTaskResumes)
	}
	if m.screening_results != nil {
		edges = append(edges, resume.EdgeScreeningResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resume.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case resume.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.educations))
		for id := range m.educations {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeExperiences:
		ids := make([]ent.Value, 0, len(m.experiences))
		for id := range m.experiences {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeDocumentParse:
		ids := make([]ent.Value, 0, len(m.document_parse))
		for id := range m.document_parse {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeJobApplications:
		ids := make([]ent.Value, 0, len(m.job_applications))
		for id := range m.job_applications {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeScreeningTaskResumes:
		ids := make([]ent.Value, 0, len(m.screening_task_resumes))
		for id := range m.screening_task_resumes {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeScreeningResults:
		ids := make([]ent.Value, 0, len(m.screening_results))
		for id := range m.screening_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removededucations != nil {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.removedexperiences != nil {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.removedprojects != nil {
		edges = append(edges, resume.EdgeProjects)
	}
	if m.removedskills != nil {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.removedlogs != nil {
		edges = append(edges, resume.EdgeLogs)
	}
	if m.removeddocument_parse != nil {
		edges = append(edges, resume.EdgeDocumentParse)
	}
	if m.removedjob_applications != nil {
		edges = append(edges, resume.EdgeJobApplications)
	}
	if m.removedscreening_task_resumes != nil {
		edges = append(edges, resume.EdgeScreeningTaskResumes)
	}
	if m.removedscreening_results != nil {
		edges = append(edges, resume.EdgeScreeningResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resume.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.removededucations))
		for id := range m.removededucations {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeExperiences:
		ids := make([]ent.Value, 0, len(m.removedexperiences))
		for id := range m.removedexperiences {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeDocumentParse:
		ids := make([]ent.Value, 0, len(m.removeddocument_parse))
		for id := range m.removeddocument_parse {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeJobApplications:
		ids := make([]ent.Value, 0, len(m.removedjob_applications))
		for id := range m.removedjob_applications {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeScreeningTaskResumes:
		ids := make([]ent.Value, 0, len(m.removedscreening_task_resumes))
		for id := range m.removedscreening_task_resumes {
			ids = append(ids, id)
		}
		return ids
	case resume.EdgeScreeningResults:
		ids := make([]ent.Value, 0, len(m.removedscreening_results))
		for id := range m.removedscreening_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.cleareduser {
		edges = append(edges, resume.EdgeUser)
	}
	if m.clearededucations {
		edges = append(edges, resume.EdgeEducations)
	}
	if m.clearedexperiences {
		edges = append(edges, resume.EdgeExperiences)
	}
	if m.clearedprojects {
		edges = append(edges, resume.EdgeProjects)
	}
	if m.clearedskills {
		edges = append(edges, resume.EdgeSkills)
	}
	if m.clearedlogs {
		edges = append(edges, resume.EdgeLogs)
	}
	if m.cleareddocument_parse {
		edges = append(edges, resume.EdgeDocumentParse)
	}
	if m.clearedjob_applications {
		edges = append(edges, resume.EdgeJobApplications)
	}
	if m.clearedscreening_task_resumes {
		edges = append(edges, resume.EdgeScreeningTaskResumes)
	}
	if m.clearedscreening_results {
		edges = append(edges, resume.EdgeScreeningResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeMutation) EdgeCleared(name string) bool {
	switch name {
	case resume.EdgeUser:
		return m.cleareduser
	case resume.EdgeEducations:
		return m.clearededucations
	case resume.EdgeExperiences:
		return m.clearedexperiences
	case resume.EdgeProjects:
		return m.clearedprojects
	case resume.EdgeSkills:
		return m.clearedskills
	case resume.EdgeLogs:
		return m.clearedlogs
	case resume.EdgeDocumentParse:
		return m.cleareddocument_parse
	case resume.EdgeJobApplications:
		return m.clearedjob_applications
	case resume.EdgeScreeningTaskResumes:
		return m.clearedscreening_task_resumes
	case resume.EdgeScreeningResults:
		return m.clearedscreening_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeMutation) ClearEdge(name string) error {
	switch name {
	case resume.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Resume unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeMutation) ResetEdge(name string) error {
	switch name {
	case resume.EdgeUser:
		m.ResetUser()
		return nil
	case resume.EdgeEducations:
		m.ResetEducations()
		return nil
	case resume.EdgeExperiences:
		m.ResetExperiences()
		return nil
	case resume.EdgeProjects:
		m.ResetProjects()
		return nil
	case resume.EdgeSkills:
		m.ResetSkills()
		return nil
	case resume.EdgeLogs:
		m.ResetLogs()
		return nil
	case resume.EdgeDocumentParse:
		m.ResetDocumentParse()
		return nil
	case resume.EdgeJobApplications:
		m.ResetJobApplications()
		return nil
	case resume.EdgeScreeningTaskResumes:
		m.ResetScreeningTaskResumes()
		return nil
	case resume.EdgeScreeningResults:
		m.ResetScreeningResults()
		return nil
	}
	return fmt.Errorf("unknown Resume edge %s", name)
}

// ResumeDocumentParseMutation represents an operation that mutates the ResumeDocumentParse nodes in the graph.
type ResumeDocumentParseMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	file_id       *string
	content       *string
	file_type     *string
	filename      *string
	title         *string
	upload_at     *time.Time
	status        *string
	error_message *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeDocumentParse, error)
	predicates    []predicate.ResumeDocumentParse
}

var _ ent.Mutation = (*ResumeDocumentParseMutation)(nil)

// resumedocumentparseOption allows management of the mutation configuration using functional options.
type resumedocumentparseOption func(*ResumeDocumentParseMutation)

// newResumeDocumentParseMutation creates new mutation for the ResumeDocumentParse entity.
func newResumeDocumentParseMutation(c config, op Op, opts ...resumedocumentparseOption) *ResumeDocumentParseMutation {
	m := &ResumeDocumentParseMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeDocumentParse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeDocumentParseID sets the ID field of the mutation.
func withResumeDocumentParseID(id uuid.UUID) resumedocumentparseOption {
	return func(m *ResumeDocumentParseMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeDocumentParse
		)
		m.oldValue = func(ctx context.Context) (*ResumeDocumentParse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeDocumentParse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeDocumentParse sets the old ResumeDocumentParse of the mutation.
func withResumeDocumentParse(node *ResumeDocumentParse) resumedocumentparseOption {
	return func(m *ResumeDocumentParseMutation) {
		m.oldValue = func(context.Context) (*ResumeDocumentParse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeDocumentParseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeDocumentParseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeDocumentParse entities.
func (m *ResumeDocumentParseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeDocumentParseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeDocumentParseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeDocumentParse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeDocumentParseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeDocumentParseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeDocumentParseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumedocumentparse.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeDocumentParseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumedocumentparse.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeDocumentParseMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeDocumentParseMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeDocumentParseMutation) ResetResumeID() {
	m.resume = nil
}

// SetFileID sets the "file_id" field.
func (m *ResumeDocumentParseMutation) SetFileID(s string) {
	m.file_id = &s
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *ResumeDocumentParseMutation) FileID() (r string, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldFileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *ResumeDocumentParseMutation) ClearFileID() {
	m.file_id = nil
	m.clearedFields[resumedocumentparse.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *ResumeDocumentParseMutation) ResetFileID() {
	m.file_id = nil
	delete(m.clearedFields, resumedocumentparse.FieldFileID)
}

// SetContent sets the "content" field.
func (m *ResumeDocumentParseMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ResumeDocumentParseMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *ResumeDocumentParseMutation) ClearContent() {
	m.content = nil
	m.clearedFields[resumedocumentparse.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) ContentCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *ResumeDocumentParseMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, resumedocumentparse.FieldContent)
}

// SetFileType sets the "file_type" field.
func (m *ResumeDocumentParseMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *ResumeDocumentParseMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ClearFileType clears the value of the "file_type" field.
func (m *ResumeDocumentParseMutation) ClearFileType() {
	m.file_type = nil
	m.clearedFields[resumedocumentparse.FieldFileType] = struct{}{}
}

// FileTypeCleared returns if the "file_type" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) FileTypeCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldFileType]
	return ok
}

// ResetFileType resets all changes to the "file_type" field.
func (m *ResumeDocumentParseMutation) ResetFileType() {
	m.file_type = nil
	delete(m.clearedFields, resumedocumentparse.FieldFileType)
}

// SetFilename sets the "filename" field.
func (m *ResumeDocumentParseMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *ResumeDocumentParseMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ClearFilename clears the value of the "filename" field.
func (m *ResumeDocumentParseMutation) ClearFilename() {
	m.filename = nil
	m.clearedFields[resumedocumentparse.FieldFilename] = struct{}{}
}

// FilenameCleared returns if the "filename" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) FilenameCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldFilename]
	return ok
}

// ResetFilename resets all changes to the "filename" field.
func (m *ResumeDocumentParseMutation) ResetFilename() {
	m.filename = nil
	delete(m.clearedFields, resumedocumentparse.FieldFilename)
}

// SetTitle sets the "title" field.
func (m *ResumeDocumentParseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ResumeDocumentParseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ResumeDocumentParseMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[resumedocumentparse.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) TitleCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ResumeDocumentParseMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, resumedocumentparse.FieldTitle)
}

// SetUploadAt sets the "upload_at" field.
func (m *ResumeDocumentParseMutation) SetUploadAt(t time.Time) {
	m.upload_at = &t
}

// UploadAt returns the value of the "upload_at" field in the mutation.
func (m *ResumeDocumentParseMutation) UploadAt() (r time.Time, exists bool) {
	v := m.upload_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadAt returns the old "upload_at" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldUploadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadAt: %w", err)
	}
	return oldValue.UploadAt, nil
}

// ClearUploadAt clears the value of the "upload_at" field.
func (m *ResumeDocumentParseMutation) ClearUploadAt() {
	m.upload_at = nil
	m.clearedFields[resumedocumentparse.FieldUploadAt] = struct{}{}
}

// UploadAtCleared returns if the "upload_at" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) UploadAtCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldUploadAt]
	return ok
}

// ResetUploadAt resets all changes to the "upload_at" field.
func (m *ResumeDocumentParseMutation) ResetUploadAt() {
	m.upload_at = nil
	delete(m.clearedFields, resumedocumentparse.FieldUploadAt)
}

// SetStatus sets the "status" field.
func (m *ResumeDocumentParseMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ResumeDocumentParseMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ResumeDocumentParseMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ResumeDocumentParseMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ResumeDocumentParseMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ResumeDocumentParseMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[resumedocumentparse.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ResumeDocumentParseMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[resumedocumentparse.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ResumeDocumentParseMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, resumedocumentparse.FieldErrorMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeDocumentParseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeDocumentParseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeDocumentParseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeDocumentParseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeDocumentParseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeDocumentParse entity.
// If the ResumeDocumentParse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeDocumentParseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeDocumentParseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeDocumentParseMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumedocumentparse.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeDocumentParseMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeDocumentParseMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeDocumentParseMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeDocumentParseMutation builder.
func (m *ResumeDocumentParseMutation) Where(ps ...predicate.ResumeDocumentParse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeDocumentParseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeDocumentParseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeDocumentParse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeDocumentParseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeDocumentParseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeDocumentParse).
func (m *ResumeDocumentParseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeDocumentParseMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.deleted_at != nil {
		fields = append(fields, resumedocumentparse.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumedocumentparse.FieldResumeID)
	}
	if m.file_id != nil {
		fields = append(fields, resumedocumentparse.FieldFileID)
	}
	if m.content != nil {
		fields = append(fields, resumedocumentparse.FieldContent)
	}
	if m.file_type != nil {
		fields = append(fields, resumedocumentparse.FieldFileType)
	}
	if m.filename != nil {
		fields = append(fields, resumedocumentparse.FieldFilename)
	}
	if m.title != nil {
		fields = append(fields, resumedocumentparse.FieldTitle)
	}
	if m.upload_at != nil {
		fields = append(fields, resumedocumentparse.FieldUploadAt)
	}
	if m.status != nil {
		fields = append(fields, resumedocumentparse.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, resumedocumentparse.FieldErrorMessage)
	}
	if m.created_at != nil {
		fields = append(fields, resumedocumentparse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumedocumentparse.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeDocumentParseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		return m.DeletedAt()
	case resumedocumentparse.FieldResumeID:
		return m.ResumeID()
	case resumedocumentparse.FieldFileID:
		return m.FileID()
	case resumedocumentparse.FieldContent:
		return m.Content()
	case resumedocumentparse.FieldFileType:
		return m.FileType()
	case resumedocumentparse.FieldFilename:
		return m.Filename()
	case resumedocumentparse.FieldTitle:
		return m.Title()
	case resumedocumentparse.FieldUploadAt:
		return m.UploadAt()
	case resumedocumentparse.FieldStatus:
		return m.Status()
	case resumedocumentparse.FieldErrorMessage:
		return m.ErrorMessage()
	case resumedocumentparse.FieldCreatedAt:
		return m.CreatedAt()
	case resumedocumentparse.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeDocumentParseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumedocumentparse.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumedocumentparse.FieldFileID:
		return m.OldFileID(ctx)
	case resumedocumentparse.FieldContent:
		return m.OldContent(ctx)
	case resumedocumentparse.FieldFileType:
		return m.OldFileType(ctx)
	case resumedocumentparse.FieldFilename:
		return m.OldFilename(ctx)
	case resumedocumentparse.FieldTitle:
		return m.OldTitle(ctx)
	case resumedocumentparse.FieldUploadAt:
		return m.OldUploadAt(ctx)
	case resumedocumentparse.FieldStatus:
		return m.OldStatus(ctx)
	case resumedocumentparse.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case resumedocumentparse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumedocumentparse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeDocumentParse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeDocumentParseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumedocumentparse.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumedocumentparse.FieldFileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case resumedocumentparse.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case resumedocumentparse.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case resumedocumentparse.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case resumedocumentparse.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case resumedocumentparse.FieldUploadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadAt(v)
		return nil
	case resumedocumentparse.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resumedocumentparse.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case resumedocumentparse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumedocumentparse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeDocumentParseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeDocumentParseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeDocumentParseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeDocumentParse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeDocumentParseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumedocumentparse.FieldDeletedAt) {
		fields = append(fields, resumedocumentparse.FieldDeletedAt)
	}
	if m.FieldCleared(resumedocumentparse.FieldFileID) {
		fields = append(fields, resumedocumentparse.FieldFileID)
	}
	if m.FieldCleared(resumedocumentparse.FieldContent) {
		fields = append(fields, resumedocumentparse.FieldContent)
	}
	if m.FieldCleared(resumedocumentparse.FieldFileType) {
		fields = append(fields, resumedocumentparse.FieldFileType)
	}
	if m.FieldCleared(resumedocumentparse.FieldFilename) {
		fields = append(fields, resumedocumentparse.FieldFilename)
	}
	if m.FieldCleared(resumedocumentparse.FieldTitle) {
		fields = append(fields, resumedocumentparse.FieldTitle)
	}
	if m.FieldCleared(resumedocumentparse.FieldUploadAt) {
		fields = append(fields, resumedocumentparse.FieldUploadAt)
	}
	if m.FieldCleared(resumedocumentparse.FieldErrorMessage) {
		fields = append(fields, resumedocumentparse.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeDocumentParseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeDocumentParseMutation) ClearField(name string) error {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumedocumentparse.FieldFileID:
		m.ClearFileID()
		return nil
	case resumedocumentparse.FieldContent:
		m.ClearContent()
		return nil
	case resumedocumentparse.FieldFileType:
		m.ClearFileType()
		return nil
	case resumedocumentparse.FieldFilename:
		m.ClearFilename()
		return nil
	case resumedocumentparse.FieldTitle:
		m.ClearTitle()
		return nil
	case resumedocumentparse.FieldUploadAt:
		m.ClearUploadAt()
		return nil
	case resumedocumentparse.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeDocumentParseMutation) ResetField(name string) error {
	switch name {
	case resumedocumentparse.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumedocumentparse.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumedocumentparse.FieldFileID:
		m.ResetFileID()
		return nil
	case resumedocumentparse.FieldContent:
		m.ResetContent()
		return nil
	case resumedocumentparse.FieldFileType:
		m.ResetFileType()
		return nil
	case resumedocumentparse.FieldFilename:
		m.ResetFilename()
		return nil
	case resumedocumentparse.FieldTitle:
		m.ResetTitle()
		return nil
	case resumedocumentparse.FieldUploadAt:
		m.ResetUploadAt()
		return nil
	case resumedocumentparse.FieldStatus:
		m.ResetStatus()
		return nil
	case resumedocumentparse.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case resumedocumentparse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumedocumentparse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeDocumentParseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumedocumentparse.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeDocumentParseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumedocumentparse.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeDocumentParseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeDocumentParseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeDocumentParseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumedocumentparse.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeDocumentParseMutation) EdgeCleared(name string) bool {
	switch name {
	case resumedocumentparse.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeDocumentParseMutation) ClearEdge(name string) error {
	switch name {
	case resumedocumentparse.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeDocumentParseMutation) ResetEdge(name string) error {
	switch name {
	case resumedocumentparse.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeDocumentParse edge %s", name)
}

// ResumeEducationMutation represents an operation that mutates the ResumeEducation nodes in the graph.
type ResumeEducationMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	deleted_at      *time.Time
	school          *string
	degree          *string
	major           *string
	university_type *consts.UniversityType
	start_date      *time.Time
	end_date        *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	resume          *uuid.UUID
	clearedresume   bool
	done            bool
	oldValue        func(context.Context) (*ResumeEducation, error)
	predicates      []predicate.ResumeEducation
}

var _ ent.Mutation = (*ResumeEducationMutation)(nil)

// resumeeducationOption allows management of the mutation configuration using functional options.
type resumeeducationOption func(*ResumeEducationMutation)

// newResumeEducationMutation creates new mutation for the ResumeEducation entity.
func newResumeEducationMutation(c config, op Op, opts ...resumeeducationOption) *ResumeEducationMutation {
	m := &ResumeEducationMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeEducation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeEducationID sets the ID field of the mutation.
func withResumeEducationID(id uuid.UUID) resumeeducationOption {
	return func(m *ResumeEducationMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeEducation
		)
		m.oldValue = func(ctx context.Context) (*ResumeEducation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeEducation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeEducation sets the old ResumeEducation of the mutation.
func withResumeEducation(node *ResumeEducation) resumeeducationOption {
	return func(m *ResumeEducationMutation) {
		m.oldValue = func(context.Context) (*ResumeEducation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeEducationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeEducationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeEducation entities.
func (m *ResumeEducationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeEducationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeEducationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeEducation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeEducationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeEducationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeEducationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumeeducation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeEducationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeEducationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumeeducation.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeEducationMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeEducationMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeEducationMutation) ResetResumeID() {
	m.resume = nil
}

// SetSchool sets the "school" field.
func (m *ResumeEducationMutation) SetSchool(s string) {
	m.school = &s
}

// School returns the value of the "school" field in the mutation.
func (m *ResumeEducationMutation) School() (r string, exists bool) {
	v := m.school
	if v == nil {
		return
	}
	return *v, true
}

// OldSchool returns the old "school" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldSchool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchool: %w", err)
	}
	return oldValue.School, nil
}

// ClearSchool clears the value of the "school" field.
func (m *ResumeEducationMutation) ClearSchool() {
	m.school = nil
	m.clearedFields[resumeeducation.FieldSchool] = struct{}{}
}

// SchoolCleared returns if the "school" field was cleared in this mutation.
func (m *ResumeEducationMutation) SchoolCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldSchool]
	return ok
}

// ResetSchool resets all changes to the "school" field.
func (m *ResumeEducationMutation) ResetSchool() {
	m.school = nil
	delete(m.clearedFields, resumeeducation.FieldSchool)
}

// SetDegree sets the "degree" field.
func (m *ResumeEducationMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the value of the "degree" field in the mutation.
func (m *ResumeEducationMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old "degree" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ClearDegree clears the value of the "degree" field.
func (m *ResumeEducationMutation) ClearDegree() {
	m.degree = nil
	m.clearedFields[resumeeducation.FieldDegree] = struct{}{}
}

// DegreeCleared returns if the "degree" field was cleared in this mutation.
func (m *ResumeEducationMutation) DegreeCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldDegree]
	return ok
}

// ResetDegree resets all changes to the "degree" field.
func (m *ResumeEducationMutation) ResetDegree() {
	m.degree = nil
	delete(m.clearedFields, resumeeducation.FieldDegree)
}

// SetMajor sets the "major" field.
func (m *ResumeEducationMutation) SetMajor(s string) {
	m.major = &s
}

// Major returns the value of the "major" field in the mutation.
func (m *ResumeEducationMutation) Major() (r string, exists bool) {
	v := m.major
	if v == nil {
		return
	}
	return *v, true
}

// OldMajor returns the old "major" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldMajor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMajor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMajor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMajor: %w", err)
	}
	return oldValue.Major, nil
}

// ClearMajor clears the value of the "major" field.
func (m *ResumeEducationMutation) ClearMajor() {
	m.major = nil
	m.clearedFields[resumeeducation.FieldMajor] = struct{}{}
}

// MajorCleared returns if the "major" field was cleared in this mutation.
func (m *ResumeEducationMutation) MajorCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldMajor]
	return ok
}

// ResetMajor resets all changes to the "major" field.
func (m *ResumeEducationMutation) ResetMajor() {
	m.major = nil
	delete(m.clearedFields, resumeeducation.FieldMajor)
}

// SetUniversityType sets the "university_type" field.
func (m *ResumeEducationMutation) SetUniversityType(ct consts.UniversityType) {
	m.university_type = &ct
}

// UniversityType returns the value of the "university_type" field in the mutation.
func (m *ResumeEducationMutation) UniversityType() (r consts.UniversityType, exists bool) {
	v := m.university_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUniversityType returns the old "university_type" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldUniversityType(ctx context.Context) (v consts.UniversityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniversityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniversityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniversityType: %w", err)
	}
	return oldValue.UniversityType, nil
}

// ClearUniversityType clears the value of the "university_type" field.
func (m *ResumeEducationMutation) ClearUniversityType() {
	m.university_type = nil
	m.clearedFields[resumeeducation.FieldUniversityType] = struct{}{}
}

// UniversityTypeCleared returns if the "university_type" field was cleared in this mutation.
func (m *ResumeEducationMutation) UniversityTypeCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldUniversityType]
	return ok
}

// ResetUniversityType resets all changes to the "university_type" field.
func (m *ResumeEducationMutation) ResetUniversityType() {
	m.university_type = nil
	delete(m.clearedFields, resumeeducation.FieldUniversityType)
}

// SetStartDate sets the "start_date" field.
func (m *ResumeEducationMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ResumeEducationMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ResumeEducationMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[resumeeducation.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ResumeEducationMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ResumeEducationMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, resumeeducation.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ResumeEducationMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ResumeEducationMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ResumeEducationMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[resumeeducation.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ResumeEducationMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[resumeeducation.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ResumeEducationMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, resumeeducation.FieldEndDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeEducationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeEducationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeEducationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeEducationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeEducationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeEducation entity.
// If the ResumeEducation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeEducationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeEducationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeEducationMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumeeducation.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeEducationMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeEducationMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeEducationMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeEducationMutation builder.
func (m *ResumeEducationMutation) Where(ps ...predicate.ResumeEducation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeEducationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeEducationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeEducation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeEducationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeEducationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeEducation).
func (m *ResumeEducationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeEducationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, resumeeducation.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumeeducation.FieldResumeID)
	}
	if m.school != nil {
		fields = append(fields, resumeeducation.FieldSchool)
	}
	if m.degree != nil {
		fields = append(fields, resumeeducation.FieldDegree)
	}
	if m.major != nil {
		fields = append(fields, resumeeducation.FieldMajor)
	}
	if m.university_type != nil {
		fields = append(fields, resumeeducation.FieldUniversityType)
	}
	if m.start_date != nil {
		fields = append(fields, resumeeducation.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, resumeeducation.FieldEndDate)
	}
	if m.created_at != nil {
		fields = append(fields, resumeeducation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumeeducation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeEducationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumeeducation.FieldDeletedAt:
		return m.DeletedAt()
	case resumeeducation.FieldResumeID:
		return m.ResumeID()
	case resumeeducation.FieldSchool:
		return m.School()
	case resumeeducation.FieldDegree:
		return m.Degree()
	case resumeeducation.FieldMajor:
		return m.Major()
	case resumeeducation.FieldUniversityType:
		return m.UniversityType()
	case resumeeducation.FieldStartDate:
		return m.StartDate()
	case resumeeducation.FieldEndDate:
		return m.EndDate()
	case resumeeducation.FieldCreatedAt:
		return m.CreatedAt()
	case resumeeducation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeEducationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumeeducation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumeeducation.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumeeducation.FieldSchool:
		return m.OldSchool(ctx)
	case resumeeducation.FieldDegree:
		return m.OldDegree(ctx)
	case resumeeducation.FieldMajor:
		return m.OldMajor(ctx)
	case resumeeducation.FieldUniversityType:
		return m.OldUniversityType(ctx)
	case resumeeducation.FieldStartDate:
		return m.OldStartDate(ctx)
	case resumeeducation.FieldEndDate:
		return m.OldEndDate(ctx)
	case resumeeducation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumeeducation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeEducation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeEducationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumeeducation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumeeducation.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumeeducation.FieldSchool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchool(v)
		return nil
	case resumeeducation.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	case resumeeducation.FieldMajor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMajor(v)
		return nil
	case resumeeducation.FieldUniversityType:
		v, ok := value.(consts.UniversityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniversityType(v)
		return nil
	case resumeeducation.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case resumeeducation.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case resumeeducation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumeeducation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeEducationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeEducationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeEducationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeEducation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeEducationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumeeducation.FieldDeletedAt) {
		fields = append(fields, resumeeducation.FieldDeletedAt)
	}
	if m.FieldCleared(resumeeducation.FieldSchool) {
		fields = append(fields, resumeeducation.FieldSchool)
	}
	if m.FieldCleared(resumeeducation.FieldDegree) {
		fields = append(fields, resumeeducation.FieldDegree)
	}
	if m.FieldCleared(resumeeducation.FieldMajor) {
		fields = append(fields, resumeeducation.FieldMajor)
	}
	if m.FieldCleared(resumeeducation.FieldUniversityType) {
		fields = append(fields, resumeeducation.FieldUniversityType)
	}
	if m.FieldCleared(resumeeducation.FieldStartDate) {
		fields = append(fields, resumeeducation.FieldStartDate)
	}
	if m.FieldCleared(resumeeducation.FieldEndDate) {
		fields = append(fields, resumeeducation.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeEducationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeEducationMutation) ClearField(name string) error {
	switch name {
	case resumeeducation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumeeducation.FieldSchool:
		m.ClearSchool()
		return nil
	case resumeeducation.FieldDegree:
		m.ClearDegree()
		return nil
	case resumeeducation.FieldMajor:
		m.ClearMajor()
		return nil
	case resumeeducation.FieldUniversityType:
		m.ClearUniversityType()
		return nil
	case resumeeducation.FieldStartDate:
		m.ClearStartDate()
		return nil
	case resumeeducation.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeEducationMutation) ResetField(name string) error {
	switch name {
	case resumeeducation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumeeducation.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumeeducation.FieldSchool:
		m.ResetSchool()
		return nil
	case resumeeducation.FieldDegree:
		m.ResetDegree()
		return nil
	case resumeeducation.FieldMajor:
		m.ResetMajor()
		return nil
	case resumeeducation.FieldUniversityType:
		m.ResetUniversityType()
		return nil
	case resumeeducation.FieldStartDate:
		m.ResetStartDate()
		return nil
	case resumeeducation.FieldEndDate:
		m.ResetEndDate()
		return nil
	case resumeeducation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumeeducation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeEducationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumeeducation.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeEducationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumeeducation.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeEducationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeEducationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeEducationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumeeducation.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeEducationMutation) EdgeCleared(name string) bool {
	switch name {
	case resumeeducation.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeEducationMutation) ClearEdge(name string) error {
	switch name {
	case resumeeducation.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeEducationMutation) ResetEdge(name string) error {
	switch name {
	case resumeeducation.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeEducation edge %s", name)
}

// ResumeExperienceMutation represents an operation that mutates the ResumeExperience nodes in the graph.
type ResumeExperienceMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	company       *string
	position      *string
	title         *string
	start_date    *time.Time
	end_date      *time.Time
	description   *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeExperience, error)
	predicates    []predicate.ResumeExperience
}

var _ ent.Mutation = (*ResumeExperienceMutation)(nil)

// resumeexperienceOption allows management of the mutation configuration using functional options.
type resumeexperienceOption func(*ResumeExperienceMutation)

// newResumeExperienceMutation creates new mutation for the ResumeExperience entity.
func newResumeExperienceMutation(c config, op Op, opts ...resumeexperienceOption) *ResumeExperienceMutation {
	m := &ResumeExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeExperienceID sets the ID field of the mutation.
func withResumeExperienceID(id uuid.UUID) resumeexperienceOption {
	return func(m *ResumeExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeExperience
		)
		m.oldValue = func(ctx context.Context) (*ResumeExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeExperience sets the old ResumeExperience of the mutation.
func withResumeExperience(node *ResumeExperience) resumeexperienceOption {
	return func(m *ResumeExperienceMutation) {
		m.oldValue = func(context.Context) (*ResumeExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeExperience entities.
func (m *ResumeExperienceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeExperienceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeExperienceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeExperienceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeExperienceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeExperienceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumeexperience.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeExperienceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeExperienceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumeexperience.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeExperienceMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeExperienceMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeExperienceMutation) ResetResumeID() {
	m.resume = nil
}

// SetCompany sets the "company" field.
func (m *ResumeExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *ResumeExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *ResumeExperienceMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[resumeexperience.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *ResumeExperienceMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *ResumeExperienceMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, resumeexperience.FieldCompany)
}

// SetPosition sets the "position" field.
func (m *ResumeExperienceMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *ResumeExperienceMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *ResumeExperienceMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[resumeexperience.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *ResumeExperienceMutation) PositionCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *ResumeExperienceMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, resumeexperience.FieldPosition)
}

// SetTitle sets the "title" field.
func (m *ResumeExperienceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ResumeExperienceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ResumeExperienceMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[resumeexperience.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ResumeExperienceMutation) TitleCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ResumeExperienceMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, resumeexperience.FieldTitle)
}

// SetStartDate sets the "start_date" field.
func (m *ResumeExperienceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ResumeExperienceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ResumeExperienceMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[resumeexperience.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ResumeExperienceMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ResumeExperienceMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, resumeexperience.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ResumeExperienceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ResumeExperienceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ResumeExperienceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[resumeexperience.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ResumeExperienceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ResumeExperienceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, resumeexperience.FieldEndDate)
}

// SetDescription sets the "description" field.
func (m *ResumeExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResumeExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResumeExperienceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resumeexperience.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResumeExperienceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resumeexperience.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResumeExperienceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resumeexperience.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeExperienceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeExperienceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeExperienceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeExperienceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeExperience entity.
// If the ResumeExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeExperienceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeExperienceMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumeexperience.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeExperienceMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeExperienceMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeExperienceMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeExperienceMutation builder.
func (m *ResumeExperienceMutation) Where(ps ...predicate.ResumeExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeExperience).
func (m *ResumeExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeExperienceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, resumeexperience.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumeexperience.FieldResumeID)
	}
	if m.company != nil {
		fields = append(fields, resumeexperience.FieldCompany)
	}
	if m.position != nil {
		fields = append(fields, resumeexperience.FieldPosition)
	}
	if m.title != nil {
		fields = append(fields, resumeexperience.FieldTitle)
	}
	if m.start_date != nil {
		fields = append(fields, resumeexperience.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, resumeexperience.FieldEndDate)
	}
	if m.description != nil {
		fields = append(fields, resumeexperience.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, resumeexperience.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumeexperience.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumeexperience.FieldDeletedAt:
		return m.DeletedAt()
	case resumeexperience.FieldResumeID:
		return m.ResumeID()
	case resumeexperience.FieldCompany:
		return m.Company()
	case resumeexperience.FieldPosition:
		return m.Position()
	case resumeexperience.FieldTitle:
		return m.Title()
	case resumeexperience.FieldStartDate:
		return m.StartDate()
	case resumeexperience.FieldEndDate:
		return m.EndDate()
	case resumeexperience.FieldDescription:
		return m.Description()
	case resumeexperience.FieldCreatedAt:
		return m.CreatedAt()
	case resumeexperience.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumeexperience.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumeexperience.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumeexperience.FieldCompany:
		return m.OldCompany(ctx)
	case resumeexperience.FieldPosition:
		return m.OldPosition(ctx)
	case resumeexperience.FieldTitle:
		return m.OldTitle(ctx)
	case resumeexperience.FieldStartDate:
		return m.OldStartDate(ctx)
	case resumeexperience.FieldEndDate:
		return m.OldEndDate(ctx)
	case resumeexperience.FieldDescription:
		return m.OldDescription(ctx)
	case resumeexperience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumeexperience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumeexperience.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumeexperience.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumeexperience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case resumeexperience.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case resumeexperience.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case resumeexperience.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case resumeexperience.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case resumeexperience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resumeexperience.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumeexperience.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeExperienceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeExperienceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumeexperience.FieldDeletedAt) {
		fields = append(fields, resumeexperience.FieldDeletedAt)
	}
	if m.FieldCleared(resumeexperience.FieldCompany) {
		fields = append(fields, resumeexperience.FieldCompany)
	}
	if m.FieldCleared(resumeexperience.FieldPosition) {
		fields = append(fields, resumeexperience.FieldPosition)
	}
	if m.FieldCleared(resumeexperience.FieldTitle) {
		fields = append(fields, resumeexperience.FieldTitle)
	}
	if m.FieldCleared(resumeexperience.FieldStartDate) {
		fields = append(fields, resumeexperience.FieldStartDate)
	}
	if m.FieldCleared(resumeexperience.FieldEndDate) {
		fields = append(fields, resumeexperience.FieldEndDate)
	}
	if m.FieldCleared(resumeexperience.FieldDescription) {
		fields = append(fields, resumeexperience.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeExperienceMutation) ClearField(name string) error {
	switch name {
	case resumeexperience.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumeexperience.FieldCompany:
		m.ClearCompany()
		return nil
	case resumeexperience.FieldPosition:
		m.ClearPosition()
		return nil
	case resumeexperience.FieldTitle:
		m.ClearTitle()
		return nil
	case resumeexperience.FieldStartDate:
		m.ClearStartDate()
		return nil
	case resumeexperience.FieldEndDate:
		m.ClearEndDate()
		return nil
	case resumeexperience.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeExperienceMutation) ResetField(name string) error {
	switch name {
	case resumeexperience.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumeexperience.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumeexperience.FieldCompany:
		m.ResetCompany()
		return nil
	case resumeexperience.FieldPosition:
		m.ResetPosition()
		return nil
	case resumeexperience.FieldTitle:
		m.ResetTitle()
		return nil
	case resumeexperience.FieldStartDate:
		m.ResetStartDate()
		return nil
	case resumeexperience.FieldEndDate:
		m.ResetEndDate()
		return nil
	case resumeexperience.FieldDescription:
		m.ResetDescription()
		return nil
	case resumeexperience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumeexperience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumeexperience.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumeexperience.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumeexperience.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case resumeexperience.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeExperienceMutation) ClearEdge(name string) error {
	switch name {
	case resumeexperience.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeExperienceMutation) ResetEdge(name string) error {
	switch name {
	case resumeexperience.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeExperience edge %s", name)
}

// ResumeJobApplicationMutation represents an operation that mutates the ResumeJobApplication nodes in the graph.
type ResumeJobApplicationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	deleted_at          *time.Time
	status              *string
	source              *string
	notes               *string
	applied_at          *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	resume              *uuid.UUID
	clearedresume       bool
	job_position        *uuid.UUID
	clearedjob_position bool
	done                bool
	oldValue            func(context.Context) (*ResumeJobApplication, error)
	predicates          []predicate.ResumeJobApplication
}

var _ ent.Mutation = (*ResumeJobApplicationMutation)(nil)

// resumejobapplicationOption allows management of the mutation configuration using functional options.
type resumejobapplicationOption func(*ResumeJobApplicationMutation)

// newResumeJobApplicationMutation creates new mutation for the ResumeJobApplication entity.
func newResumeJobApplicationMutation(c config, op Op, opts ...resumejobapplicationOption) *ResumeJobApplicationMutation {
	m := &ResumeJobApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeJobApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeJobApplicationID sets the ID field of the mutation.
func withResumeJobApplicationID(id uuid.UUID) resumejobapplicationOption {
	return func(m *ResumeJobApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeJobApplication
		)
		m.oldValue = func(ctx context.Context) (*ResumeJobApplication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeJobApplication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeJobApplication sets the old ResumeJobApplication of the mutation.
func withResumeJobApplication(node *ResumeJobApplication) resumejobapplicationOption {
	return func(m *ResumeJobApplicationMutation) {
		m.oldValue = func(context.Context) (*ResumeJobApplication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeJobApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeJobApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeJobApplication entities.
func (m *ResumeJobApplicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeJobApplicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeJobApplicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeJobApplication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeJobApplicationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeJobApplicationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeJobApplicationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumejobapplication.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeJobApplicationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumejobapplication.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeJobApplicationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumejobapplication.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeJobApplicationMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeJobApplicationMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeJobApplicationMutation) ResetResumeID() {
	m.resume = nil
}

// SetJobPositionID sets the "job_position_id" field.
func (m *ResumeJobApplicationMutation) SetJobPositionID(u uuid.UUID) {
	m.job_position = &u
}

// JobPositionID returns the value of the "job_position_id" field in the mutation.
func (m *ResumeJobApplicationMutation) JobPositionID() (r uuid.UUID, exists bool) {
	v := m.job_position
	if v == nil {
		return
	}
	return *v, true
}

// OldJobPositionID returns the old "job_position_id" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldJobPositionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobPositionID: %w", err)
	}
	return oldValue.JobPositionID, nil
}

// ResetJobPositionID resets all changes to the "job_position_id" field.
func (m *ResumeJobApplicationMutation) ResetJobPositionID() {
	m.job_position = nil
}

// SetStatus sets the "status" field.
func (m *ResumeJobApplicationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ResumeJobApplicationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ResumeJobApplicationMutation) ResetStatus() {
	m.status = nil
}

// SetSource sets the "source" field.
func (m *ResumeJobApplicationMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ResumeJobApplicationMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ResumeJobApplicationMutation) ClearSource() {
	m.source = nil
	m.clearedFields[resumejobapplication.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ResumeJobApplicationMutation) SourceCleared() bool {
	_, ok := m.clearedFields[resumejobapplication.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ResumeJobApplicationMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, resumejobapplication.FieldSource)
}

// SetNotes sets the "notes" field.
func (m *ResumeJobApplicationMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ResumeJobApplicationMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ResumeJobApplicationMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[resumejobapplication.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ResumeJobApplicationMutation) NotesCleared() bool {
	_, ok := m.clearedFields[resumejobapplication.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ResumeJobApplicationMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, resumejobapplication.FieldNotes)
}

// SetAppliedAt sets the "applied_at" field.
func (m *ResumeJobApplicationMutation) SetAppliedAt(t time.Time) {
	m.applied_at = &t
}

// AppliedAt returns the value of the "applied_at" field in the mutation.
func (m *ResumeJobApplicationMutation) AppliedAt() (r time.Time, exists bool) {
	v := m.applied_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedAt returns the old "applied_at" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldAppliedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedAt: %w", err)
	}
	return oldValue.AppliedAt, nil
}

// ResetAppliedAt resets all changes to the "applied_at" field.
func (m *ResumeJobApplicationMutation) ResetAppliedAt() {
	m.applied_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeJobApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeJobApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeJobApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeJobApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeJobApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeJobApplication entity.
// If the ResumeJobApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeJobApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeJobApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeJobApplicationMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumejobapplication.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeJobApplicationMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeJobApplicationMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeJobApplicationMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// ClearJobPosition clears the "job_position" edge to the JobPosition entity.
func (m *ResumeJobApplicationMutation) ClearJobPosition() {
	m.clearedjob_position = true
	m.clearedFields[resumejobapplication.FieldJobPositionID] = struct{}{}
}

// JobPositionCleared reports if the "job_position" edge to the JobPosition entity was cleared.
func (m *ResumeJobApplicationMutation) JobPositionCleared() bool {
	return m.clearedjob_position
}

// JobPositionIDs returns the "job_position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobPositionID instead. It exists only for internal usage by the builders.
func (m *ResumeJobApplicationMutation) JobPositionIDs() (ids []uuid.UUID) {
	if id := m.job_position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobPosition resets all changes to the "job_position" edge.
func (m *ResumeJobApplicationMutation) ResetJobPosition() {
	m.job_position = nil
	m.clearedjob_position = false
}

// Where appends a list predicates to the ResumeJobApplicationMutation builder.
func (m *ResumeJobApplicationMutation) Where(ps ...predicate.ResumeJobApplication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeJobApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeJobApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeJobApplication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeJobApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeJobApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeJobApplication).
func (m *ResumeJobApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeJobApplicationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, resumejobapplication.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumejobapplication.FieldResumeID)
	}
	if m.job_position != nil {
		fields = append(fields, resumejobapplication.FieldJobPositionID)
	}
	if m.status != nil {
		fields = append(fields, resumejobapplication.FieldStatus)
	}
	if m.source != nil {
		fields = append(fields, resumejobapplication.FieldSource)
	}
	if m.notes != nil {
		fields = append(fields, resumejobapplication.FieldNotes)
	}
	if m.applied_at != nil {
		fields = append(fields, resumejobapplication.FieldAppliedAt)
	}
	if m.created_at != nil {
		fields = append(fields, resumejobapplication.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumejobapplication.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeJobApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumejobapplication.FieldDeletedAt:
		return m.DeletedAt()
	case resumejobapplication.FieldResumeID:
		return m.ResumeID()
	case resumejobapplication.FieldJobPositionID:
		return m.JobPositionID()
	case resumejobapplication.FieldStatus:
		return m.Status()
	case resumejobapplication.FieldSource:
		return m.Source()
	case resumejobapplication.FieldNotes:
		return m.Notes()
	case resumejobapplication.FieldAppliedAt:
		return m.AppliedAt()
	case resumejobapplication.FieldCreatedAt:
		return m.CreatedAt()
	case resumejobapplication.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeJobApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumejobapplication.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumejobapplication.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumejobapplication.FieldJobPositionID:
		return m.OldJobPositionID(ctx)
	case resumejobapplication.FieldStatus:
		return m.OldStatus(ctx)
	case resumejobapplication.FieldSource:
		return m.OldSource(ctx)
	case resumejobapplication.FieldNotes:
		return m.OldNotes(ctx)
	case resumejobapplication.FieldAppliedAt:
		return m.OldAppliedAt(ctx)
	case resumejobapplication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumejobapplication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeJobApplication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeJobApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumejobapplication.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumejobapplication.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumejobapplication.FieldJobPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobPositionID(v)
		return nil
	case resumejobapplication.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resumejobapplication.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case resumejobapplication.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case resumejobapplication.FieldAppliedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedAt(v)
		return nil
	case resumejobapplication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumejobapplication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeJobApplication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeJobApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeJobApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeJobApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeJobApplication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeJobApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumejobapplication.FieldDeletedAt) {
		fields = append(fields, resumejobapplication.FieldDeletedAt)
	}
	if m.FieldCleared(resumejobapplication.FieldSource) {
		fields = append(fields, resumejobapplication.FieldSource)
	}
	if m.FieldCleared(resumejobapplication.FieldNotes) {
		fields = append(fields, resumejobapplication.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeJobApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeJobApplicationMutation) ClearField(name string) error {
	switch name {
	case resumejobapplication.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumejobapplication.FieldSource:
		m.ClearSource()
		return nil
	case resumejobapplication.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown ResumeJobApplication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeJobApplicationMutation) ResetField(name string) error {
	switch name {
	case resumejobapplication.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumejobapplication.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumejobapplication.FieldJobPositionID:
		m.ResetJobPositionID()
		return nil
	case resumejobapplication.FieldStatus:
		m.ResetStatus()
		return nil
	case resumejobapplication.FieldSource:
		m.ResetSource()
		return nil
	case resumejobapplication.FieldNotes:
		m.ResetNotes()
		return nil
	case resumejobapplication.FieldAppliedAt:
		m.ResetAppliedAt()
		return nil
	case resumejobapplication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumejobapplication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeJobApplication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeJobApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.resume != nil {
		edges = append(edges, resumejobapplication.EdgeResume)
	}
	if m.job_position != nil {
		edges = append(edges, resumejobapplication.EdgeJobPosition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeJobApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumejobapplication.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	case resumejobapplication.EdgeJobPosition:
		if id := m.job_position; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeJobApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeJobApplicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeJobApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresume {
		edges = append(edges, resumejobapplication.EdgeResume)
	}
	if m.clearedjob_position {
		edges = append(edges, resumejobapplication.EdgeJobPosition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeJobApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case resumejobapplication.EdgeResume:
		return m.clearedresume
	case resumejobapplication.EdgeJobPosition:
		return m.clearedjob_position
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeJobApplicationMutation) ClearEdge(name string) error {
	switch name {
	case resumejobapplication.EdgeResume:
		m.ClearResume()
		return nil
	case resumejobapplication.EdgeJobPosition:
		m.ClearJobPosition()
		return nil
	}
	return fmt.Errorf("unknown ResumeJobApplication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeJobApplicationMutation) ResetEdge(name string) error {
	switch name {
	case resumejobapplication.EdgeResume:
		m.ResetResume()
		return nil
	case resumejobapplication.EdgeJobPosition:
		m.ResetJobPosition()
		return nil
	}
	return fmt.Errorf("unknown ResumeJobApplication edge %s", name)
}

// ResumeLogMutation represents an operation that mutates the ResumeLog nodes in the graph.
type ResumeLogMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	action        *string
	message       *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeLog, error)
	predicates    []predicate.ResumeLog
}

var _ ent.Mutation = (*ResumeLogMutation)(nil)

// resumelogOption allows management of the mutation configuration using functional options.
type resumelogOption func(*ResumeLogMutation)

// newResumeLogMutation creates new mutation for the ResumeLog entity.
func newResumeLogMutation(c config, op Op, opts ...resumelogOption) *ResumeLogMutation {
	m := &ResumeLogMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeLogID sets the ID field of the mutation.
func withResumeLogID(id uuid.UUID) resumelogOption {
	return func(m *ResumeLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeLog
		)
		m.oldValue = func(ctx context.Context) (*ResumeLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeLog sets the old ResumeLog of the mutation.
func withResumeLog(node *ResumeLog) resumelogOption {
	return func(m *ResumeLogMutation) {
		m.oldValue = func(context.Context) (*ResumeLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeLog entities.
func (m *ResumeLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumelog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumelog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumelog.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeLogMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeLogMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeLogMutation) ResetResumeID() {
	m.resume = nil
}

// SetAction sets the "action" field.
func (m *ResumeLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *ResumeLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *ResumeLogMutation) ResetAction() {
	m.action = nil
}

// SetMessage sets the "message" field.
func (m *ResumeLogMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ResumeLogMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *ResumeLogMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[resumelog.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *ResumeLogMutation) MessageCleared() bool {
	_, ok := m.clearedFields[resumelog.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *ResumeLogMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, resumelog.FieldMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeLog entity.
// If the ResumeLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeLogMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumelog.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeLogMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeLogMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeLogMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeLogMutation builder.
func (m *ResumeLogMutation) Where(ps ...predicate.ResumeLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeLog).
func (m *ResumeLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.deleted_at != nil {
		fields = append(fields, resumelog.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumelog.FieldResumeID)
	}
	if m.action != nil {
		fields = append(fields, resumelog.FieldAction)
	}
	if m.message != nil {
		fields = append(fields, resumelog.FieldMessage)
	}
	if m.created_at != nil {
		fields = append(fields, resumelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumelog.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumelog.FieldDeletedAt:
		return m.DeletedAt()
	case resumelog.FieldResumeID:
		return m.ResumeID()
	case resumelog.FieldAction:
		return m.Action()
	case resumelog.FieldMessage:
		return m.Message()
	case resumelog.FieldCreatedAt:
		return m.CreatedAt()
	case resumelog.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumelog.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumelog.FieldAction:
		return m.OldAction(ctx)
	case resumelog.FieldMessage:
		return m.OldMessage(ctx)
	case resumelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumelog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumelog.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumelog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case resumelog.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case resumelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumelog.FieldDeletedAt) {
		fields = append(fields, resumelog.FieldDeletedAt)
	}
	if m.FieldCleared(resumelog.FieldMessage) {
		fields = append(fields, resumelog.FieldMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeLogMutation) ClearField(name string) error {
	switch name {
	case resumelog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumelog.FieldMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown ResumeLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeLogMutation) ResetField(name string) error {
	switch name {
	case resumelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumelog.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumelog.FieldAction:
		m.ResetAction()
		return nil
	case resumelog.FieldMessage:
		m.ResetMessage()
		return nil
	case resumelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumelog.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumelog.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumelog.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeLogMutation) EdgeCleared(name string) bool {
	switch name {
	case resumelog.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeLogMutation) ClearEdge(name string) error {
	switch name {
	case resumelog.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeLogMutation) ResetEdge(name string) error {
	switch name {
	case resumelog.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeLog edge %s", name)
}

// ResumeProjectMutation represents an operation that mutates the ResumeProject nodes in the graph.
type ResumeProjectMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	deleted_at       *time.Time
	name             *string
	role             *string
	company          *string
	start_date       *time.Time
	end_date         *time.Time
	description      *string
	responsibilities *string
	achievements     *string
	technologies     *string
	project_url      *string
	project_type     *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	resume           *uuid.UUID
	clearedresume    bool
	done             bool
	oldValue         func(context.Context) (*ResumeProject, error)
	predicates       []predicate.ResumeProject
}

var _ ent.Mutation = (*ResumeProjectMutation)(nil)

// resumeprojectOption allows management of the mutation configuration using functional options.
type resumeprojectOption func(*ResumeProjectMutation)

// newResumeProjectMutation creates new mutation for the ResumeProject entity.
func newResumeProjectMutation(c config, op Op, opts ...resumeprojectOption) *ResumeProjectMutation {
	m := &ResumeProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeProjectID sets the ID field of the mutation.
func withResumeProjectID(id uuid.UUID) resumeprojectOption {
	return func(m *ResumeProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeProject
		)
		m.oldValue = func(ctx context.Context) (*ResumeProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeProject sets the old ResumeProject of the mutation.
func withResumeProject(node *ResumeProject) resumeprojectOption {
	return func(m *ResumeProjectMutation) {
		m.oldValue = func(context.Context) (*ResumeProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeProject entities.
func (m *ResumeProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeProjectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeProjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeProjectMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumeproject.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeProjectMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumeproject.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeProjectMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeProjectMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeProjectMutation) ResetResumeID() {
	m.resume = nil
}

// SetName sets the "name" field.
func (m *ResumeProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ResumeProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ResumeProjectMutation) ClearName() {
	m.name = nil
	m.clearedFields[resumeproject.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ResumeProjectMutation) NameCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ResumeProjectMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, resumeproject.FieldName)
}

// SetRole sets the "role" field.
func (m *ResumeProjectMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *ResumeProjectMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *ResumeProjectMutation) ClearRole() {
	m.role = nil
	m.clearedFields[resumeproject.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *ResumeProjectMutation) RoleCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *ResumeProjectMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, resumeproject.FieldRole)
}

// SetCompany sets the "company" field.
func (m *ResumeProjectMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *ResumeProjectMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *ResumeProjectMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[resumeproject.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *ResumeProjectMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *ResumeProjectMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, resumeproject.FieldCompany)
}

// SetStartDate sets the "start_date" field.
func (m *ResumeProjectMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ResumeProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ResumeProjectMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[resumeproject.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ResumeProjectMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ResumeProjectMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, resumeproject.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ResumeProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ResumeProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ResumeProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[resumeproject.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ResumeProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ResumeProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, resumeproject.FieldEndDate)
}

// SetDescription sets the "description" field.
func (m *ResumeProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResumeProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResumeProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resumeproject.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResumeProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResumeProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resumeproject.FieldDescription)
}

// SetResponsibilities sets the "responsibilities" field.
func (m *ResumeProjectMutation) SetResponsibilities(s string) {
	m.responsibilities = &s
}

// Responsibilities returns the value of the "responsibilities" field in the mutation.
func (m *ResumeProjectMutation) Responsibilities() (r string, exists bool) {
	v := m.responsibilities
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsibilities returns the old "responsibilities" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldResponsibilities(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsibilities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsibilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsibilities: %w", err)
	}
	return oldValue.Responsibilities, nil
}

// ClearResponsibilities clears the value of the "responsibilities" field.
func (m *ResumeProjectMutation) ClearResponsibilities() {
	m.responsibilities = nil
	m.clearedFields[resumeproject.FieldResponsibilities] = struct{}{}
}

// ResponsibilitiesCleared returns if the "responsibilities" field was cleared in this mutation.
func (m *ResumeProjectMutation) ResponsibilitiesCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldResponsibilities]
	return ok
}

// ResetResponsibilities resets all changes to the "responsibilities" field.
func (m *ResumeProjectMutation) ResetResponsibilities() {
	m.responsibilities = nil
	delete(m.clearedFields, resumeproject.FieldResponsibilities)
}

// SetAchievements sets the "achievements" field.
func (m *ResumeProjectMutation) SetAchievements(s string) {
	m.achievements = &s
}

// Achievements returns the value of the "achievements" field in the mutation.
func (m *ResumeProjectMutation) Achievements() (r string, exists bool) {
	v := m.achievements
	if v == nil {
		return
	}
	return *v, true
}

// OldAchievements returns the old "achievements" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldAchievements(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAchievements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAchievements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAchievements: %w", err)
	}
	return oldValue.Achievements, nil
}

// ClearAchievements clears the value of the "achievements" field.
func (m *ResumeProjectMutation) ClearAchievements() {
	m.achievements = nil
	m.clearedFields[resumeproject.FieldAchievements] = struct{}{}
}

// AchievementsCleared returns if the "achievements" field was cleared in this mutation.
func (m *ResumeProjectMutation) AchievementsCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldAchievements]
	return ok
}

// ResetAchievements resets all changes to the "achievements" field.
func (m *ResumeProjectMutation) ResetAchievements() {
	m.achievements = nil
	delete(m.clearedFields, resumeproject.FieldAchievements)
}

// SetTechnologies sets the "technologies" field.
func (m *ResumeProjectMutation) SetTechnologies(s string) {
	m.technologies = &s
}

// Technologies returns the value of the "technologies" field in the mutation.
func (m *ResumeProjectMutation) Technologies() (r string, exists bool) {
	v := m.technologies
	if v == nil {
		return
	}
	return *v, true
}

// OldTechnologies returns the old "technologies" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldTechnologies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechnologies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechnologies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechnologies: %w", err)
	}
	return oldValue.Technologies, nil
}

// ClearTechnologies clears the value of the "technologies" field.
func (m *ResumeProjectMutation) ClearTechnologies() {
	m.technologies = nil
	m.clearedFields[resumeproject.FieldTechnologies] = struct{}{}
}

// TechnologiesCleared returns if the "technologies" field was cleared in this mutation.
func (m *ResumeProjectMutation) TechnologiesCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldTechnologies]
	return ok
}

// ResetTechnologies resets all changes to the "technologies" field.
func (m *ResumeProjectMutation) ResetTechnologies() {
	m.technologies = nil
	delete(m.clearedFields, resumeproject.FieldTechnologies)
}

// SetProjectURL sets the "project_url" field.
func (m *ResumeProjectMutation) SetProjectURL(s string) {
	m.project_url = &s
}

// ProjectURL returns the value of the "project_url" field in the mutation.
func (m *ResumeProjectMutation) ProjectURL() (r string, exists bool) {
	v := m.project_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectURL returns the old "project_url" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldProjectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectURL: %w", err)
	}
	return oldValue.ProjectURL, nil
}

// ClearProjectURL clears the value of the "project_url" field.
func (m *ResumeProjectMutation) ClearProjectURL() {
	m.project_url = nil
	m.clearedFields[resumeproject.FieldProjectURL] = struct{}{}
}

// ProjectURLCleared returns if the "project_url" field was cleared in this mutation.
func (m *ResumeProjectMutation) ProjectURLCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldProjectURL]
	return ok
}

// ResetProjectURL resets all changes to the "project_url" field.
func (m *ResumeProjectMutation) ResetProjectURL() {
	m.project_url = nil
	delete(m.clearedFields, resumeproject.FieldProjectURL)
}

// SetProjectType sets the "project_type" field.
func (m *ResumeProjectMutation) SetProjectType(s string) {
	m.project_type = &s
}

// ProjectType returns the value of the "project_type" field in the mutation.
func (m *ResumeProjectMutation) ProjectType() (r string, exists bool) {
	v := m.project_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectType returns the old "project_type" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldProjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectType: %w", err)
	}
	return oldValue.ProjectType, nil
}

// ClearProjectType clears the value of the "project_type" field.
func (m *ResumeProjectMutation) ClearProjectType() {
	m.project_type = nil
	m.clearedFields[resumeproject.FieldProjectType] = struct{}{}
}

// ProjectTypeCleared returns if the "project_type" field was cleared in this mutation.
func (m *ResumeProjectMutation) ProjectTypeCleared() bool {
	_, ok := m.clearedFields[resumeproject.FieldProjectType]
	return ok
}

// ResetProjectType resets all changes to the "project_type" field.
func (m *ResumeProjectMutation) ResetProjectType() {
	m.project_type = nil
	delete(m.clearedFields, resumeproject.FieldProjectType)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeProject entity.
// If the ResumeProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeProjectMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumeproject.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeProjectMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeProjectMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeProjectMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeProjectMutation builder.
func (m *ResumeProjectMutation) Where(ps ...predicate.ResumeProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeProject).
func (m *ResumeProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeProjectMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.deleted_at != nil {
		fields = append(fields, resumeproject.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumeproject.FieldResumeID)
	}
	if m.name != nil {
		fields = append(fields, resumeproject.FieldName)
	}
	if m.role != nil {
		fields = append(fields, resumeproject.FieldRole)
	}
	if m.company != nil {
		fields = append(fields, resumeproject.FieldCompany)
	}
	if m.start_date != nil {
		fields = append(fields, resumeproject.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, resumeproject.FieldEndDate)
	}
	if m.description != nil {
		fields = append(fields, resumeproject.FieldDescription)
	}
	if m.responsibilities != nil {
		fields = append(fields, resumeproject.FieldResponsibilities)
	}
	if m.achievements != nil {
		fields = append(fields, resumeproject.FieldAchievements)
	}
	if m.technologies != nil {
		fields = append(fields, resumeproject.FieldTechnologies)
	}
	if m.project_url != nil {
		fields = append(fields, resumeproject.FieldProjectURL)
	}
	if m.project_type != nil {
		fields = append(fields, resumeproject.FieldProjectType)
	}
	if m.created_at != nil {
		fields = append(fields, resumeproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumeproject.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumeproject.FieldDeletedAt:
		return m.DeletedAt()
	case resumeproject.FieldResumeID:
		return m.ResumeID()
	case resumeproject.FieldName:
		return m.Name()
	case resumeproject.FieldRole:
		return m.Role()
	case resumeproject.FieldCompany:
		return m.Company()
	case resumeproject.FieldStartDate:
		return m.StartDate()
	case resumeproject.FieldEndDate:
		return m.EndDate()
	case resumeproject.FieldDescription:
		return m.Description()
	case resumeproject.FieldResponsibilities:
		return m.Responsibilities()
	case resumeproject.FieldAchievements:
		return m.Achievements()
	case resumeproject.FieldTechnologies:
		return m.Technologies()
	case resumeproject.FieldProjectURL:
		return m.ProjectURL()
	case resumeproject.FieldProjectType:
		return m.ProjectType()
	case resumeproject.FieldCreatedAt:
		return m.CreatedAt()
	case resumeproject.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumeproject.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumeproject.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumeproject.FieldName:
		return m.OldName(ctx)
	case resumeproject.FieldRole:
		return m.OldRole(ctx)
	case resumeproject.FieldCompany:
		return m.OldCompany(ctx)
	case resumeproject.FieldStartDate:
		return m.OldStartDate(ctx)
	case resumeproject.FieldEndDate:
		return m.OldEndDate(ctx)
	case resumeproject.FieldDescription:
		return m.OldDescription(ctx)
	case resumeproject.FieldResponsibilities:
		return m.OldResponsibilities(ctx)
	case resumeproject.FieldAchievements:
		return m.OldAchievements(ctx)
	case resumeproject.FieldTechnologies:
		return m.OldTechnologies(ctx)
	case resumeproject.FieldProjectURL:
		return m.OldProjectURL(ctx)
	case resumeproject.FieldProjectType:
		return m.OldProjectType(ctx)
	case resumeproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumeproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumeproject.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumeproject.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumeproject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resumeproject.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case resumeproject.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case resumeproject.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case resumeproject.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case resumeproject.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resumeproject.FieldResponsibilities:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsibilities(v)
		return nil
	case resumeproject.FieldAchievements:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAchievements(v)
		return nil
	case resumeproject.FieldTechnologies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechnologies(v)
		return nil
	case resumeproject.FieldProjectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectURL(v)
		return nil
	case resumeproject.FieldProjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectType(v)
		return nil
	case resumeproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumeproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumeproject.FieldDeletedAt) {
		fields = append(fields, resumeproject.FieldDeletedAt)
	}
	if m.FieldCleared(resumeproject.FieldName) {
		fields = append(fields, resumeproject.FieldName)
	}
	if m.FieldCleared(resumeproject.FieldRole) {
		fields = append(fields, resumeproject.FieldRole)
	}
	if m.FieldCleared(resumeproject.FieldCompany) {
		fields = append(fields, resumeproject.FieldCompany)
	}
	if m.FieldCleared(resumeproject.FieldStartDate) {
		fields = append(fields, resumeproject.FieldStartDate)
	}
	if m.FieldCleared(resumeproject.FieldEndDate) {
		fields = append(fields, resumeproject.FieldEndDate)
	}
	if m.FieldCleared(resumeproject.FieldDescription) {
		fields = append(fields, resumeproject.FieldDescription)
	}
	if m.FieldCleared(resumeproject.FieldResponsibilities) {
		fields = append(fields, resumeproject.FieldResponsibilities)
	}
	if m.FieldCleared(resumeproject.FieldAchievements) {
		fields = append(fields, resumeproject.FieldAchievements)
	}
	if m.FieldCleared(resumeproject.FieldTechnologies) {
		fields = append(fields, resumeproject.FieldTechnologies)
	}
	if m.FieldCleared(resumeproject.FieldProjectURL) {
		fields = append(fields, resumeproject.FieldProjectURL)
	}
	if m.FieldCleared(resumeproject.FieldProjectType) {
		fields = append(fields, resumeproject.FieldProjectType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeProjectMutation) ClearField(name string) error {
	switch name {
	case resumeproject.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumeproject.FieldName:
		m.ClearName()
		return nil
	case resumeproject.FieldRole:
		m.ClearRole()
		return nil
	case resumeproject.FieldCompany:
		m.ClearCompany()
		return nil
	case resumeproject.FieldStartDate:
		m.ClearStartDate()
		return nil
	case resumeproject.FieldEndDate:
		m.ClearEndDate()
		return nil
	case resumeproject.FieldDescription:
		m.ClearDescription()
		return nil
	case resumeproject.FieldResponsibilities:
		m.ClearResponsibilities()
		return nil
	case resumeproject.FieldAchievements:
		m.ClearAchievements()
		return nil
	case resumeproject.FieldTechnologies:
		m.ClearTechnologies()
		return nil
	case resumeproject.FieldProjectURL:
		m.ClearProjectURL()
		return nil
	case resumeproject.FieldProjectType:
		m.ClearProjectType()
		return nil
	}
	return fmt.Errorf("unknown ResumeProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeProjectMutation) ResetField(name string) error {
	switch name {
	case resumeproject.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumeproject.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumeproject.FieldName:
		m.ResetName()
		return nil
	case resumeproject.FieldRole:
		m.ResetRole()
		return nil
	case resumeproject.FieldCompany:
		m.ResetCompany()
		return nil
	case resumeproject.FieldStartDate:
		m.ResetStartDate()
		return nil
	case resumeproject.FieldEndDate:
		m.ResetEndDate()
		return nil
	case resumeproject.FieldDescription:
		m.ResetDescription()
		return nil
	case resumeproject.FieldResponsibilities:
		m.ResetResponsibilities()
		return nil
	case resumeproject.FieldAchievements:
		m.ResetAchievements()
		return nil
	case resumeproject.FieldTechnologies:
		m.ResetTechnologies()
		return nil
	case resumeproject.FieldProjectURL:
		m.ResetProjectURL()
		return nil
	case resumeproject.FieldProjectType:
		m.ResetProjectType()
		return nil
	case resumeproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumeproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumeproject.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumeproject.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumeproject.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case resumeproject.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeProjectMutation) ClearEdge(name string) error {
	switch name {
	case resumeproject.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeProjectMutation) ResetEdge(name string) error {
	switch name {
	case resumeproject.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeProject edge %s", name)
}

// ResumeSkillMutation represents an operation that mutates the ResumeSkill nodes in the graph.
type ResumeSkillMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	skill_name    *string
	level         *string
	description   *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	resume        *uuid.UUID
	clearedresume bool
	done          bool
	oldValue      func(context.Context) (*ResumeSkill, error)
	predicates    []predicate.ResumeSkill
}

var _ ent.Mutation = (*ResumeSkillMutation)(nil)

// resumeskillOption allows management of the mutation configuration using functional options.
type resumeskillOption func(*ResumeSkillMutation)

// newResumeSkillMutation creates new mutation for the ResumeSkill entity.
func newResumeSkillMutation(c config, op Op, opts ...resumeskillOption) *ResumeSkillMutation {
	m := &ResumeSkillMutation{
		config:        c,
		op:            op,
		typ:           TypeResumeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResumeSkillID sets the ID field of the mutation.
func withResumeSkillID(id uuid.UUID) resumeskillOption {
	return func(m *ResumeSkillMutation) {
		var (
			err   error
			once  sync.Once
			value *ResumeSkill
		)
		m.oldValue = func(ctx context.Context) (*ResumeSkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResumeSkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResumeSkill sets the old ResumeSkill of the mutation.
func withResumeSkill(node *ResumeSkill) resumeskillOption {
	return func(m *ResumeSkillMutation) {
		m.oldValue = func(context.Context) (*ResumeSkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResumeSkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResumeSkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResumeSkill entities.
func (m *ResumeSkillMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResumeSkillMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResumeSkillMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResumeSkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResumeSkillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResumeSkillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResumeSkillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resumeskill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResumeSkillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resumeskill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResumeSkillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resumeskill.FieldDeletedAt)
}

// SetResumeID sets the "resume_id" field.
func (m *ResumeSkillMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ResumeSkillMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ResumeSkillMutation) ResetResumeID() {
	m.resume = nil
}

// SetSkillName sets the "skill_name" field.
func (m *ResumeSkillMutation) SetSkillName(s string) {
	m.skill_name = &s
}

// SkillName returns the value of the "skill_name" field in the mutation.
func (m *ResumeSkillMutation) SkillName() (r string, exists bool) {
	v := m.skill_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillName returns the old "skill_name" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldSkillName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillName: %w", err)
	}
	return oldValue.SkillName, nil
}

// ClearSkillName clears the value of the "skill_name" field.
func (m *ResumeSkillMutation) ClearSkillName() {
	m.skill_name = nil
	m.clearedFields[resumeskill.FieldSkillName] = struct{}{}
}

// SkillNameCleared returns if the "skill_name" field was cleared in this mutation.
func (m *ResumeSkillMutation) SkillNameCleared() bool {
	_, ok := m.clearedFields[resumeskill.FieldSkillName]
	return ok
}

// ResetSkillName resets all changes to the "skill_name" field.
func (m *ResumeSkillMutation) ResetSkillName() {
	m.skill_name = nil
	delete(m.clearedFields, resumeskill.FieldSkillName)
}

// SetLevel sets the "level" field.
func (m *ResumeSkillMutation) SetLevel(s string) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *ResumeSkillMutation) Level() (r string, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ClearLevel clears the value of the "level" field.
func (m *ResumeSkillMutation) ClearLevel() {
	m.level = nil
	m.clearedFields[resumeskill.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *ResumeSkillMutation) LevelCleared() bool {
	_, ok := m.clearedFields[resumeskill.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *ResumeSkillMutation) ResetLevel() {
	m.level = nil
	delete(m.clearedFields, resumeskill.FieldLevel)
}

// SetDescription sets the "description" field.
func (m *ResumeSkillMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResumeSkillMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResumeSkillMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resumeskill.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResumeSkillMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resumeskill.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResumeSkillMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resumeskill.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResumeSkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResumeSkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResumeSkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResumeSkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResumeSkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResumeSkill entity.
// If the ResumeSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResumeSkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResumeSkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ResumeSkillMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[resumeskill.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ResumeSkillMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ResumeSkillMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ResumeSkillMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ResumeSkillMutation builder.
func (m *ResumeSkillMutation) Where(ps ...predicate.ResumeSkill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResumeSkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResumeSkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResumeSkill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResumeSkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResumeSkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResumeSkill).
func (m *ResumeSkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResumeSkillMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.deleted_at != nil {
		fields = append(fields, resumeskill.FieldDeletedAt)
	}
	if m.resume != nil {
		fields = append(fields, resumeskill.FieldResumeID)
	}
	if m.skill_name != nil {
		fields = append(fields, resumeskill.FieldSkillName)
	}
	if m.level != nil {
		fields = append(fields, resumeskill.FieldLevel)
	}
	if m.description != nil {
		fields = append(fields, resumeskill.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, resumeskill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resumeskill.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResumeSkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resumeskill.FieldDeletedAt:
		return m.DeletedAt()
	case resumeskill.FieldResumeID:
		return m.ResumeID()
	case resumeskill.FieldSkillName:
		return m.SkillName()
	case resumeskill.FieldLevel:
		return m.Level()
	case resumeskill.FieldDescription:
		return m.Description()
	case resumeskill.FieldCreatedAt:
		return m.CreatedAt()
	case resumeskill.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResumeSkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resumeskill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resumeskill.FieldResumeID:
		return m.OldResumeID(ctx)
	case resumeskill.FieldSkillName:
		return m.OldSkillName(ctx)
	case resumeskill.FieldLevel:
		return m.OldLevel(ctx)
	case resumeskill.FieldDescription:
		return m.OldDescription(ctx)
	case resumeskill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resumeskill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResumeSkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeSkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resumeskill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resumeskill.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case resumeskill.FieldSkillName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillName(v)
		return nil
	case resumeskill.FieldLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case resumeskill.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resumeskill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resumeskill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResumeSkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResumeSkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResumeSkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResumeSkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResumeSkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resumeskill.FieldDeletedAt) {
		fields = append(fields, resumeskill.FieldDeletedAt)
	}
	if m.FieldCleared(resumeskill.FieldSkillName) {
		fields = append(fields, resumeskill.FieldSkillName)
	}
	if m.FieldCleared(resumeskill.FieldLevel) {
		fields = append(fields, resumeskill.FieldLevel)
	}
	if m.FieldCleared(resumeskill.FieldDescription) {
		fields = append(fields, resumeskill.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResumeSkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResumeSkillMutation) ClearField(name string) error {
	switch name {
	case resumeskill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resumeskill.FieldSkillName:
		m.ClearSkillName()
		return nil
	case resumeskill.FieldLevel:
		m.ClearLevel()
		return nil
	case resumeskill.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResumeSkillMutation) ResetField(name string) error {
	switch name {
	case resumeskill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resumeskill.FieldResumeID:
		m.ResetResumeID()
		return nil
	case resumeskill.FieldSkillName:
		m.ResetSkillName()
		return nil
	case resumeskill.FieldLevel:
		m.ResetLevel()
		return nil
	case resumeskill.FieldDescription:
		m.ResetDescription()
		return nil
	case resumeskill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resumeskill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResumeSkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.resume != nil {
		edges = append(edges, resumeskill.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResumeSkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resumeskill.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResumeSkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResumeSkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResumeSkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedresume {
		edges = append(edges, resumeskill.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResumeSkillMutation) EdgeCleared(name string) bool {
	switch name {
	case resumeskill.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResumeSkillMutation) ClearEdge(name string) error {
	switch name {
	case resumeskill.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResumeSkillMutation) ResetEdge(name string) error {
	switch name {
	case resumeskill.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ResumeSkill edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	name               *string
	description        *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	admins             map[uuid.UUID]struct{}
	removedadmins      map[uuid.UUID]struct{}
	clearedadmins      bool
	admin_roles        map[uuid.UUID]struct{}
	removedadmin_roles map[uuid.UUID]struct{}
	clearedadmin_roles bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddAdminIDs adds the "admins" edge to the Admin entity by ids.
func (m *RoleMutation) AddAdminIDs(ids ...uuid.UUID) {
	if m.admins == nil {
		m.admins = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.admins[ids[i]] = struct{}{}
	}
}

// ClearAdmins clears the "admins" edge to the Admin entity.
func (m *RoleMutation) ClearAdmins() {
	m.clearedadmins = true
}

// AdminsCleared reports if the "admins" edge to the Admin entity was cleared.
func (m *RoleMutation) AdminsCleared() bool {
	return m.clearedadmins
}

// RemoveAdminIDs removes the "admins" edge to the Admin entity by IDs.
func (m *RoleMutation) RemoveAdminIDs(ids ...uuid.UUID) {
	if m.removedadmins == nil {
		m.removedadmins = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.admins, ids[i])
		m.removedadmins[ids[i]] = struct{}{}
	}
}

// RemovedAdmins returns the removed IDs of the "admins" edge to the Admin entity.
func (m *RoleMutation) RemovedAdminsIDs() (ids []uuid.UUID) {
	for id := range m.removedadmins {
		ids = append(ids, id)
	}
	return
}

// AdminsIDs returns the "admins" edge IDs in the mutation.
func (m *RoleMutation) AdminsIDs() (ids []uuid.UUID) {
	for id := range m.admins {
		ids = append(ids, id)
	}
	return
}

// ResetAdmins resets all changes to the "admins" edge.
func (m *RoleMutation) ResetAdmins() {
	m.admins = nil
	m.clearedadmins = false
	m.removedadmins = nil
}

// AddAdminRoleIDs adds the "admin_roles" edge to the AdminRole entity by ids.
func (m *RoleMutation) AddAdminRoleIDs(ids ...uuid.UUID) {
	if m.admin_roles == nil {
		m.admin_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.admin_roles[ids[i]] = struct{}{}
	}
}

// ClearAdminRoles clears the "admin_roles" edge to the AdminRole entity.
func (m *RoleMutation) ClearAdminRoles() {
	m.clearedadmin_roles = true
}

// AdminRolesCleared reports if the "admin_roles" edge to the AdminRole entity was cleared.
func (m *RoleMutation) AdminRolesCleared() bool {
	return m.clearedadmin_roles
}

// RemoveAdminRoleIDs removes the "admin_roles" edge to the AdminRole entity by IDs.
func (m *RoleMutation) RemoveAdminRoleIDs(ids ...uuid.UUID) {
	if m.removedadmin_roles == nil {
		m.removedadmin_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.admin_roles, ids[i])
		m.removedadmin_roles[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoles returns the removed IDs of the "admin_roles" edge to the AdminRole entity.
func (m *RoleMutation) RemovedAdminRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedadmin_roles {
		ids = append(ids, id)
	}
	return
}

// AdminRolesIDs returns the "admin_roles" edge IDs in the mutation.
func (m *RoleMutation) AdminRolesIDs() (ids []uuid.UUID) {
	for id := range m.admin_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoles resets all changes to the "admin_roles" edge.
func (m *RoleMutation) ResetAdminRoles() {
	m.admin_roles = nil
	m.clearedadmin_roles = false
	m.removedadmin_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.admins != nil {
		edges = append(edges, role.EdgeAdmins)
	}
	if m.admin_roles != nil {
		edges = append(edges, role.EdgeAdminRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.admins))
		for id := range m.admins {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.admin_roles))
		for id := range m.admin_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedadmins != nil {
		edges = append(edges, role.EdgeAdmins)
	}
	if m.removedadmin_roles != nil {
		edges = append(edges, role.EdgeAdminRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.removedadmins))
		for id := range m.removedadmins {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.removedadmin_roles))
		for id := range m.removedadmin_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedadmins {
		edges = append(edges, role.EdgeAdmins)
	}
	if m.clearedadmin_roles {
		edges = append(edges, role.EdgeAdminRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeAdmins:
		return m.clearedadmins
	case role.EdgeAdminRoles:
		return m.clearedadmin_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeAdmins:
		m.ResetAdmins()
		return nil
	case role.EdgeAdminRoles:
		m.ResetAdminRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// ScreeningNodeRunMutation represents an operation that mutates the ScreeningNodeRun nodes in the graph.
type ScreeningNodeRunMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	deleted_at         *time.Time
	node_key           *string
	status             *string
	attempt_no         *int
	addattempt_no      *int
	trace_id           *string
	agent_version      *string
	model_name         *string
	model_provider     *string
	llm_params         *map[string]interface{}
	input_payload      *map[string]interface{}
	output_payload     *map[string]interface{}
	error_message      *string
	tokens_input       *int64
	addtokens_input    *int64
	tokens_output      *int64
	addtokens_output   *int64
	total_cost         *float64
	addtotal_cost      *float64
	started_at         *time.Time
	finished_at        *time.Time
	duration_ms        *int
	addduration_ms     *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	task               *uuid.UUID
	clearedtask        bool
	task_resume        *uuid.UUID
	clearedtask_resume bool
	done               bool
	oldValue           func(context.Context) (*ScreeningNodeRun, error)
	predicates         []predicate.ScreeningNodeRun
}

var _ ent.Mutation = (*ScreeningNodeRunMutation)(nil)

// screeningnoderunOption allows management of the mutation configuration using functional options.
type screeningnoderunOption func(*ScreeningNodeRunMutation)

// newScreeningNodeRunMutation creates new mutation for the ScreeningNodeRun entity.
func newScreeningNodeRunMutation(c config, op Op, opts ...screeningnoderunOption) *ScreeningNodeRunMutation {
	m := &ScreeningNodeRunMutation{
		config:        c,
		op:            op,
		typ:           TypeScreeningNodeRun,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScreeningNodeRunID sets the ID field of the mutation.
func withScreeningNodeRunID(id uuid.UUID) screeningnoderunOption {
	return func(m *ScreeningNodeRunMutation) {
		var (
			err   error
			once  sync.Once
			value *ScreeningNodeRun
		)
		m.oldValue = func(ctx context.Context) (*ScreeningNodeRun, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScreeningNodeRun.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScreeningNodeRun sets the old ScreeningNodeRun of the mutation.
func withScreeningNodeRun(node *ScreeningNodeRun) screeningnoderunOption {
	return func(m *ScreeningNodeRunMutation) {
		m.oldValue = func(context.Context) (*ScreeningNodeRun, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScreeningNodeRunMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScreeningNodeRunMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScreeningNodeRun entities.
func (m *ScreeningNodeRunMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScreeningNodeRunMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScreeningNodeRunMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScreeningNodeRun.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScreeningNodeRunMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScreeningNodeRunMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ScreeningNodeRunMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[screeningnoderun.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScreeningNodeRunMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, screeningnoderun.FieldDeletedAt)
}

// SetTaskID sets the "task_id" field.
func (m *ScreeningNodeRunMutation) SetTaskID(u uuid.UUID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ScreeningNodeRunMutation) TaskID() (r uuid.UUID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ScreeningNodeRunMutation) ResetTaskID() {
	m.task = nil
}

// SetTaskResumeID sets the "task_resume_id" field.
func (m *ScreeningNodeRunMutation) SetTaskResumeID(u uuid.UUID) {
	m.task_resume = &u
}

// TaskResumeID returns the value of the "task_resume_id" field in the mutation.
func (m *ScreeningNodeRunMutation) TaskResumeID() (r uuid.UUID, exists bool) {
	v := m.task_resume
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskResumeID returns the old "task_resume_id" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldTaskResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskResumeID: %w", err)
	}
	return oldValue.TaskResumeID, nil
}

// ResetTaskResumeID resets all changes to the "task_resume_id" field.
func (m *ScreeningNodeRunMutation) ResetTaskResumeID() {
	m.task_resume = nil
}

// SetNodeKey sets the "node_key" field.
func (m *ScreeningNodeRunMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *ScreeningNodeRunMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ClearNodeKey clears the value of the "node_key" field.
func (m *ScreeningNodeRunMutation) ClearNodeKey() {
	m.node_key = nil
	m.clearedFields[screeningnoderun.FieldNodeKey] = struct{}{}
}

// NodeKeyCleared returns if the "node_key" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) NodeKeyCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldNodeKey]
	return ok
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *ScreeningNodeRunMutation) ResetNodeKey() {
	m.node_key = nil
	delete(m.clearedFields, screeningnoderun.FieldNodeKey)
}

// SetStatus sets the "status" field.
func (m *ScreeningNodeRunMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ScreeningNodeRunMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ScreeningNodeRunMutation) ResetStatus() {
	m.status = nil
}

// SetAttemptNo sets the "attempt_no" field.
func (m *ScreeningNodeRunMutation) SetAttemptNo(i int) {
	m.attempt_no = &i
	m.addattempt_no = nil
}

// AttemptNo returns the value of the "attempt_no" field in the mutation.
func (m *ScreeningNodeRunMutation) AttemptNo() (r int, exists bool) {
	v := m.attempt_no
	if v == nil {
		return
	}
	return *v, true
}

// OldAttemptNo returns the old "attempt_no" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldAttemptNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttemptNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttemptNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttemptNo: %w", err)
	}
	return oldValue.AttemptNo, nil
}

// AddAttemptNo adds i to the "attempt_no" field.
func (m *ScreeningNodeRunMutation) AddAttemptNo(i int) {
	if m.addattempt_no != nil {
		*m.addattempt_no += i
	} else {
		m.addattempt_no = &i
	}
}

// AddedAttemptNo returns the value that was added to the "attempt_no" field in this mutation.
func (m *ScreeningNodeRunMutation) AddedAttemptNo() (r int, exists bool) {
	v := m.addattempt_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttemptNo resets all changes to the "attempt_no" field.
func (m *ScreeningNodeRunMutation) ResetAttemptNo() {
	m.attempt_no = nil
	m.addattempt_no = nil
}

// SetTraceID sets the "trace_id" field.
func (m *ScreeningNodeRunMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *ScreeningNodeRunMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *ScreeningNodeRunMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[screeningnoderun.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *ScreeningNodeRunMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, screeningnoderun.FieldTraceID)
}

// SetAgentVersion sets the "agent_version" field.
func (m *ScreeningNodeRunMutation) SetAgentVersion(s string) {
	m.agent_version = &s
}

// AgentVersion returns the value of the "agent_version" field in the mutation.
func (m *ScreeningNodeRunMutation) AgentVersion() (r string, exists bool) {
	v := m.agent_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentVersion returns the old "agent_version" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldAgentVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentVersion: %w", err)
	}
	return oldValue.AgentVersion, nil
}

// ClearAgentVersion clears the value of the "agent_version" field.
func (m *ScreeningNodeRunMutation) ClearAgentVersion() {
	m.agent_version = nil
	m.clearedFields[screeningnoderun.FieldAgentVersion] = struct{}{}
}

// AgentVersionCleared returns if the "agent_version" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) AgentVersionCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldAgentVersion]
	return ok
}

// ResetAgentVersion resets all changes to the "agent_version" field.
func (m *ScreeningNodeRunMutation) ResetAgentVersion() {
	m.agent_version = nil
	delete(m.clearedFields, screeningnoderun.FieldAgentVersion)
}

// SetModelName sets the "model_name" field.
func (m *ScreeningNodeRunMutation) SetModelName(s string) {
	m.model_name = &s
}

// ModelName returns the value of the "model_name" field in the mutation.
func (m *ScreeningNodeRunMutation) ModelName() (r string, exists bool) {
	v := m.model_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModelName returns the old "model_name" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldModelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelName: %w", err)
	}
	return oldValue.ModelName, nil
}

// ClearModelName clears the value of the "model_name" field.
func (m *ScreeningNodeRunMutation) ClearModelName() {
	m.model_name = nil
	m.clearedFields[screeningnoderun.FieldModelName] = struct{}{}
}

// ModelNameCleared returns if the "model_name" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) ModelNameCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldModelName]
	return ok
}

// ResetModelName resets all changes to the "model_name" field.
func (m *ScreeningNodeRunMutation) ResetModelName() {
	m.model_name = nil
	delete(m.clearedFields, screeningnoderun.FieldModelName)
}

// SetModelProvider sets the "model_provider" field.
func (m *ScreeningNodeRunMutation) SetModelProvider(s string) {
	m.model_provider = &s
}

// ModelProvider returns the value of the "model_provider" field in the mutation.
func (m *ScreeningNodeRunMutation) ModelProvider() (r string, exists bool) {
	v := m.model_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldModelProvider returns the old "model_provider" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldModelProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelProvider: %w", err)
	}
	return oldValue.ModelProvider, nil
}

// ClearModelProvider clears the value of the "model_provider" field.
func (m *ScreeningNodeRunMutation) ClearModelProvider() {
	m.model_provider = nil
	m.clearedFields[screeningnoderun.FieldModelProvider] = struct{}{}
}

// ModelProviderCleared returns if the "model_provider" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) ModelProviderCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldModelProvider]
	return ok
}

// ResetModelProvider resets all changes to the "model_provider" field.
func (m *ScreeningNodeRunMutation) ResetModelProvider() {
	m.model_provider = nil
	delete(m.clearedFields, screeningnoderun.FieldModelProvider)
}

// SetLlmParams sets the "llm_params" field.
func (m *ScreeningNodeRunMutation) SetLlmParams(value map[string]interface{}) {
	m.llm_params = &value
}

// LlmParams returns the value of the "llm_params" field in the mutation.
func (m *ScreeningNodeRunMutation) LlmParams() (r map[string]interface{}, exists bool) {
	v := m.llm_params
	if v == nil {
		return
	}
	return *v, true
}

// OldLlmParams returns the old "llm_params" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldLlmParams(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLlmParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLlmParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLlmParams: %w", err)
	}
	return oldValue.LlmParams, nil
}

// ClearLlmParams clears the value of the "llm_params" field.
func (m *ScreeningNodeRunMutation) ClearLlmParams() {
	m.llm_params = nil
	m.clearedFields[screeningnoderun.FieldLlmParams] = struct{}{}
}

// LlmParamsCleared returns if the "llm_params" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) LlmParamsCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldLlmParams]
	return ok
}

// ResetLlmParams resets all changes to the "llm_params" field.
func (m *ScreeningNodeRunMutation) ResetLlmParams() {
	m.llm_params = nil
	delete(m.clearedFields, screeningnoderun.FieldLlmParams)
}

// SetInputPayload sets the "input_payload" field.
func (m *ScreeningNodeRunMutation) SetInputPayload(value map[string]interface{}) {
	m.input_payload = &value
}

// InputPayload returns the value of the "input_payload" field in the mutation.
func (m *ScreeningNodeRunMutation) InputPayload() (r map[string]interface{}, exists bool) {
	v := m.input_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldInputPayload returns the old "input_payload" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldInputPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputPayload: %w", err)
	}
	return oldValue.InputPayload, nil
}

// ClearInputPayload clears the value of the "input_payload" field.
func (m *ScreeningNodeRunMutation) ClearInputPayload() {
	m.input_payload = nil
	m.clearedFields[screeningnoderun.FieldInputPayload] = struct{}{}
}

// InputPayloadCleared returns if the "input_payload" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) InputPayloadCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldInputPayload]
	return ok
}

// ResetInputPayload resets all changes to the "input_payload" field.
func (m *ScreeningNodeRunMutation) ResetInputPayload() {
	m.input_payload = nil
	delete(m.clearedFields, screeningnoderun.FieldInputPayload)
}

// SetOutputPayload sets the "output_payload" field.
func (m *ScreeningNodeRunMutation) SetOutputPayload(value map[string]interface{}) {
	m.output_payload = &value
}

// OutputPayload returns the value of the "output_payload" field in the mutation.
func (m *ScreeningNodeRunMutation) OutputPayload() (r map[string]interface{}, exists bool) {
	v := m.output_payload
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputPayload returns the old "output_payload" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldOutputPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputPayload: %w", err)
	}
	return oldValue.OutputPayload, nil
}

// ClearOutputPayload clears the value of the "output_payload" field.
func (m *ScreeningNodeRunMutation) ClearOutputPayload() {
	m.output_payload = nil
	m.clearedFields[screeningnoderun.FieldOutputPayload] = struct{}{}
}

// OutputPayloadCleared returns if the "output_payload" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) OutputPayloadCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldOutputPayload]
	return ok
}

// ResetOutputPayload resets all changes to the "output_payload" field.
func (m *ScreeningNodeRunMutation) ResetOutputPayload() {
	m.output_payload = nil
	delete(m.clearedFields, screeningnoderun.FieldOutputPayload)
}

// SetErrorMessage sets the "error_message" field.
func (m *ScreeningNodeRunMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ScreeningNodeRunMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ScreeningNodeRunMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[screeningnoderun.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ScreeningNodeRunMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, screeningnoderun.FieldErrorMessage)
}

// SetTokensInput sets the "tokens_input" field.
func (m *ScreeningNodeRunMutation) SetTokensInput(i int64) {
	m.tokens_input = &i
	m.addtokens_input = nil
}

// TokensInput returns the value of the "tokens_input" field in the mutation.
func (m *ScreeningNodeRunMutation) TokensInput() (r int64, exists bool) {
	v := m.tokens_input
	if v == nil {
		return
	}
	return *v, true
}

// OldTokensInput returns the old "tokens_input" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldTokensInput(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokensInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokensInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokensInput: %w", err)
	}
	return oldValue.TokensInput, nil
}

// AddTokensInput adds i to the "tokens_input" field.
func (m *ScreeningNodeRunMutation) AddTokensInput(i int64) {
	if m.addtokens_input != nil {
		*m.addtokens_input += i
	} else {
		m.addtokens_input = &i
	}
}

// AddedTokensInput returns the value that was added to the "tokens_input" field in this mutation.
func (m *ScreeningNodeRunMutation) AddedTokensInput() (r int64, exists bool) {
	v := m.addtokens_input
	if v == nil {
		return
	}
	return *v, true
}

// ClearTokensInput clears the value of the "tokens_input" field.
func (m *ScreeningNodeRunMutation) ClearTokensInput() {
	m.tokens_input = nil
	m.addtokens_input = nil
	m.clearedFields[screeningnoderun.FieldTokensInput] = struct{}{}
}

// TokensInputCleared returns if the "tokens_input" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) TokensInputCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldTokensInput]
	return ok
}

// ResetTokensInput resets all changes to the "tokens_input" field.
func (m *ScreeningNodeRunMutation) ResetTokensInput() {
	m.tokens_input = nil
	m.addtokens_input = nil
	delete(m.clearedFields, screeningnoderun.FieldTokensInput)
}

// SetTokensOutput sets the "tokens_output" field.
func (m *ScreeningNodeRunMutation) SetTokensOutput(i int64) {
	m.tokens_output = &i
	m.addtokens_output = nil
}

// TokensOutput returns the value of the "tokens_output" field in the mutation.
func (m *ScreeningNodeRunMutation) TokensOutput() (r int64, exists bool) {
	v := m.tokens_output
	if v == nil {
		return
	}
	return *v, true
}

// OldTokensOutput returns the old "tokens_output" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldTokensOutput(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokensOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokensOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokensOutput: %w", err)
	}
	return oldValue.TokensOutput, nil
}

// AddTokensOutput adds i to the "tokens_output" field.
func (m *ScreeningNodeRunMutation) AddTokensOutput(i int64) {
	if m.addtokens_output != nil {
		*m.addtokens_output += i
	} else {
		m.addtokens_output = &i
	}
}

// AddedTokensOutput returns the value that was added to the "tokens_output" field in this mutation.
func (m *ScreeningNodeRunMutation) AddedTokensOutput() (r int64, exists bool) {
	v := m.addtokens_output
	if v == nil {
		return
	}
	return *v, true
}

// ClearTokensOutput clears the value of the "tokens_output" field.
func (m *ScreeningNodeRunMutation) ClearTokensOutput() {
	m.tokens_output = nil
	m.addtokens_output = nil
	m.clearedFields[screeningnoderun.FieldTokensOutput] = struct{}{}
}

// TokensOutputCleared returns if the "tokens_output" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) TokensOutputCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldTokensOutput]
	return ok
}

// ResetTokensOutput resets all changes to the "tokens_output" field.
func (m *ScreeningNodeRunMutation) ResetTokensOutput() {
	m.tokens_output = nil
	m.addtokens_output = nil
	delete(m.clearedFields, screeningnoderun.FieldTokensOutput)
}

// SetTotalCost sets the "total_cost" field.
func (m *ScreeningNodeRunMutation) SetTotalCost(f float64) {
	m.total_cost = &f
	m.addtotal_cost = nil
}

// TotalCost returns the value of the "total_cost" field in the mutation.
func (m *ScreeningNodeRunMutation) TotalCost() (r float64, exists bool) {
	v := m.total_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "total_cost" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldTotalCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "total_cost" field.
func (m *ScreeningNodeRunMutation) AddTotalCost(f float64) {
	if m.addtotal_cost != nil {
		*m.addtotal_cost += f
	} else {
		m.addtotal_cost = &f
	}
}

// AddedTotalCost returns the value that was added to the "total_cost" field in this mutation.
func (m *ScreeningNodeRunMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotal_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalCost clears the value of the "total_cost" field.
func (m *ScreeningNodeRunMutation) ClearTotalCost() {
	m.total_cost = nil
	m.addtotal_cost = nil
	m.clearedFields[screeningnoderun.FieldTotalCost] = struct{}{}
}

// TotalCostCleared returns if the "total_cost" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) TotalCostCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldTotalCost]
	return ok
}

// ResetTotalCost resets all changes to the "total_cost" field.
func (m *ScreeningNodeRunMutation) ResetTotalCost() {
	m.total_cost = nil
	m.addtotal_cost = nil
	delete(m.clearedFields, screeningnoderun.FieldTotalCost)
}

// SetStartedAt sets the "started_at" field.
func (m *ScreeningNodeRunMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ScreeningNodeRunMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ScreeningNodeRunMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[screeningnoderun.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ScreeningNodeRunMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, screeningnoderun.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *ScreeningNodeRunMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ScreeningNodeRunMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *ScreeningNodeRunMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[screeningnoderun.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ScreeningNodeRunMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, screeningnoderun.FieldFinishedAt)
}

// SetDurationMs sets the "duration_ms" field.
func (m *ScreeningNodeRunMutation) SetDurationMs(i int) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *ScreeningNodeRunMutation) DurationMs() (r int, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldDurationMs(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *ScreeningNodeRunMutation) AddDurationMs(i int) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *ScreeningNodeRunMutation) AddedDurationMs() (r int, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *ScreeningNodeRunMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[screeningnoderun.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *ScreeningNodeRunMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[screeningnoderun.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *ScreeningNodeRunMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, screeningnoderun.FieldDurationMs)
}

// SetCreatedAt sets the "created_at" field.
func (m *ScreeningNodeRunMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScreeningNodeRunMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScreeningNodeRunMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScreeningNodeRunMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScreeningNodeRunMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScreeningNodeRun entity.
// If the ScreeningNodeRun object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningNodeRunMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScreeningNodeRunMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the ScreeningTask entity.
func (m *ScreeningNodeRunMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[screeningnoderun.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the ScreeningTask entity was cleared.
func (m *ScreeningNodeRunMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ScreeningNodeRunMutation) TaskIDs() (ids []uuid.UUID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *ScreeningNodeRunMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTaskResume clears the "task_resume" edge to the ScreeningTaskResume entity.
func (m *ScreeningNodeRunMutation) ClearTaskResume() {
	m.clearedtask_resume = true
	m.clearedFields[screeningnoderun.FieldTaskResumeID] = struct{}{}
}

// TaskResumeCleared reports if the "task_resume" edge to the ScreeningTaskResume entity was cleared.
func (m *ScreeningNodeRunMutation) TaskResumeCleared() bool {
	return m.clearedtask_resume
}

// TaskResumeIDs returns the "task_resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskResumeID instead. It exists only for internal usage by the builders.
func (m *ScreeningNodeRunMutation) TaskResumeIDs() (ids []uuid.UUID) {
	if id := m.task_resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskResume resets all changes to the "task_resume" edge.
func (m *ScreeningNodeRunMutation) ResetTaskResume() {
	m.task_resume = nil
	m.clearedtask_resume = false
}

// Where appends a list predicates to the ScreeningNodeRunMutation builder.
func (m *ScreeningNodeRunMutation) Where(ps ...predicate.ScreeningNodeRun) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScreeningNodeRunMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScreeningNodeRunMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScreeningNodeRun, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScreeningNodeRunMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScreeningNodeRunMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScreeningNodeRun).
func (m *ScreeningNodeRunMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScreeningNodeRunMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.deleted_at != nil {
		fields = append(fields, screeningnoderun.FieldDeletedAt)
	}
	if m.task != nil {
		fields = append(fields, screeningnoderun.FieldTaskID)
	}
	if m.task_resume != nil {
		fields = append(fields, screeningnoderun.FieldTaskResumeID)
	}
	if m.node_key != nil {
		fields = append(fields, screeningnoderun.FieldNodeKey)
	}
	if m.status != nil {
		fields = append(fields, screeningnoderun.FieldStatus)
	}
	if m.attempt_no != nil {
		fields = append(fields, screeningnoderun.FieldAttemptNo)
	}
	if m.trace_id != nil {
		fields = append(fields, screeningnoderun.FieldTraceID)
	}
	if m.agent_version != nil {
		fields = append(fields, screeningnoderun.FieldAgentVersion)
	}
	if m.model_name != nil {
		fields = append(fields, screeningnoderun.FieldModelName)
	}
	if m.model_provider != nil {
		fields = append(fields, screeningnoderun.FieldModelProvider)
	}
	if m.llm_params != nil {
		fields = append(fields, screeningnoderun.FieldLlmParams)
	}
	if m.input_payload != nil {
		fields = append(fields, screeningnoderun.FieldInputPayload)
	}
	if m.output_payload != nil {
		fields = append(fields, screeningnoderun.FieldOutputPayload)
	}
	if m.error_message != nil {
		fields = append(fields, screeningnoderun.FieldErrorMessage)
	}
	if m.tokens_input != nil {
		fields = append(fields, screeningnoderun.FieldTokensInput)
	}
	if m.tokens_output != nil {
		fields = append(fields, screeningnoderun.FieldTokensOutput)
	}
	if m.total_cost != nil {
		fields = append(fields, screeningnoderun.FieldTotalCost)
	}
	if m.started_at != nil {
		fields = append(fields, screeningnoderun.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, screeningnoderun.FieldFinishedAt)
	}
	if m.duration_ms != nil {
		fields = append(fields, screeningnoderun.FieldDurationMs)
	}
	if m.created_at != nil {
		fields = append(fields, screeningnoderun.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, screeningnoderun.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScreeningNodeRunMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case screeningnoderun.FieldDeletedAt:
		return m.DeletedAt()
	case screeningnoderun.FieldTaskID:
		return m.TaskID()
	case screeningnoderun.FieldTaskResumeID:
		return m.TaskResumeID()
	case screeningnoderun.FieldNodeKey:
		return m.NodeKey()
	case screeningnoderun.FieldStatus:
		return m.Status()
	case screeningnoderun.FieldAttemptNo:
		return m.AttemptNo()
	case screeningnoderun.FieldTraceID:
		return m.TraceID()
	case screeningnoderun.FieldAgentVersion:
		return m.AgentVersion()
	case screeningnoderun.FieldModelName:
		return m.ModelName()
	case screeningnoderun.FieldModelProvider:
		return m.ModelProvider()
	case screeningnoderun.FieldLlmParams:
		return m.LlmParams()
	case screeningnoderun.FieldInputPayload:
		return m.InputPayload()
	case screeningnoderun.FieldOutputPayload:
		return m.OutputPayload()
	case screeningnoderun.FieldErrorMessage:
		return m.ErrorMessage()
	case screeningnoderun.FieldTokensInput:
		return m.TokensInput()
	case screeningnoderun.FieldTokensOutput:
		return m.TokensOutput()
	case screeningnoderun.FieldTotalCost:
		return m.TotalCost()
	case screeningnoderun.FieldStartedAt:
		return m.StartedAt()
	case screeningnoderun.FieldFinishedAt:
		return m.FinishedAt()
	case screeningnoderun.FieldDurationMs:
		return m.DurationMs()
	case screeningnoderun.FieldCreatedAt:
		return m.CreatedAt()
	case screeningnoderun.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScreeningNodeRunMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case screeningnoderun.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case screeningnoderun.FieldTaskID:
		return m.OldTaskID(ctx)
	case screeningnoderun.FieldTaskResumeID:
		return m.OldTaskResumeID(ctx)
	case screeningnoderun.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case screeningnoderun.FieldStatus:
		return m.OldStatus(ctx)
	case screeningnoderun.FieldAttemptNo:
		return m.OldAttemptNo(ctx)
	case screeningnoderun.FieldTraceID:
		return m.OldTraceID(ctx)
	case screeningnoderun.FieldAgentVersion:
		return m.OldAgentVersion(ctx)
	case screeningnoderun.FieldModelName:
		return m.OldModelName(ctx)
	case screeningnoderun.FieldModelProvider:
		return m.OldModelProvider(ctx)
	case screeningnoderun.FieldLlmParams:
		return m.OldLlmParams(ctx)
	case screeningnoderun.FieldInputPayload:
		return m.OldInputPayload(ctx)
	case screeningnoderun.FieldOutputPayload:
		return m.OldOutputPayload(ctx)
	case screeningnoderun.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case screeningnoderun.FieldTokensInput:
		return m.OldTokensInput(ctx)
	case screeningnoderun.FieldTokensOutput:
		return m.OldTokensOutput(ctx)
	case screeningnoderun.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case screeningnoderun.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case screeningnoderun.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case screeningnoderun.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case screeningnoderun.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case screeningnoderun.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ScreeningNodeRun field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningNodeRunMutation) SetField(name string, value ent.Value) error {
	switch name {
	case screeningnoderun.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case screeningnoderun.FieldTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case screeningnoderun.FieldTaskResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskResumeID(v)
		return nil
	case screeningnoderun.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case screeningnoderun.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case screeningnoderun.FieldAttemptNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttemptNo(v)
		return nil
	case screeningnoderun.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case screeningnoderun.FieldAgentVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentVersion(v)
		return nil
	case screeningnoderun.FieldModelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelName(v)
		return nil
	case screeningnoderun.FieldModelProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelProvider(v)
		return nil
	case screeningnoderun.FieldLlmParams:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLlmParams(v)
		return nil
	case screeningnoderun.FieldInputPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputPayload(v)
		return nil
	case screeningnoderun.FieldOutputPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputPayload(v)
		return nil
	case screeningnoderun.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case screeningnoderun.FieldTokensInput:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokensInput(v)
		return nil
	case screeningnoderun.FieldTokensOutput:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokensOutput(v)
		return nil
	case screeningnoderun.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case screeningnoderun.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case screeningnoderun.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case screeningnoderun.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case screeningnoderun.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case screeningnoderun.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningNodeRun field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScreeningNodeRunMutation) AddedFields() []string {
	var fields []string
	if m.addattempt_no != nil {
		fields = append(fields, screeningnoderun.FieldAttemptNo)
	}
	if m.addtokens_input != nil {
		fields = append(fields, screeningnoderun.FieldTokensInput)
	}
	if m.addtokens_output != nil {
		fields = append(fields, screeningnoderun.FieldTokensOutput)
	}
	if m.addtotal_cost != nil {
		fields = append(fields, screeningnoderun.FieldTotalCost)
	}
	if m.addduration_ms != nil {
		fields = append(fields, screeningnoderun.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScreeningNodeRunMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case screeningnoderun.FieldAttemptNo:
		return m.AddedAttemptNo()
	case screeningnoderun.FieldTokensInput:
		return m.AddedTokensInput()
	case screeningnoderun.FieldTokensOutput:
		return m.AddedTokensOutput()
	case screeningnoderun.FieldTotalCost:
		return m.AddedTotalCost()
	case screeningnoderun.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningNodeRunMutation) AddField(name string, value ent.Value) error {
	switch name {
	case screeningnoderun.FieldAttemptNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttemptNo(v)
		return nil
	case screeningnoderun.FieldTokensInput:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokensInput(v)
		return nil
	case screeningnoderun.FieldTokensOutput:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokensOutput(v)
		return nil
	case screeningnoderun.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	case screeningnoderun.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningNodeRun numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScreeningNodeRunMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(screeningnoderun.FieldDeletedAt) {
		fields = append(fields, screeningnoderun.FieldDeletedAt)
	}
	if m.FieldCleared(screeningnoderun.FieldNodeKey) {
		fields = append(fields, screeningnoderun.FieldNodeKey)
	}
	if m.FieldCleared(screeningnoderun.FieldTraceID) {
		fields = append(fields, screeningnoderun.FieldTraceID)
	}
	if m.FieldCleared(screeningnoderun.FieldAgentVersion) {
		fields = append(fields, screeningnoderun.FieldAgentVersion)
	}
	if m.FieldCleared(screeningnoderun.FieldModelName) {
		fields = append(fields, screeningnoderun.FieldModelName)
	}
	if m.FieldCleared(screeningnoderun.FieldModelProvider) {
		fields = append(fields, screeningnoderun.FieldModelProvider)
	}
	if m.FieldCleared(screeningnoderun.FieldLlmParams) {
		fields = append(fields, screeningnoderun.FieldLlmParams)
	}
	if m.FieldCleared(screeningnoderun.FieldInputPayload) {
		fields = append(fields, screeningnoderun.FieldInputPayload)
	}
	if m.FieldCleared(screeningnoderun.FieldOutputPayload) {
		fields = append(fields, screeningnoderun.FieldOutputPayload)
	}
	if m.FieldCleared(screeningnoderun.FieldErrorMessage) {
		fields = append(fields, screeningnoderun.FieldErrorMessage)
	}
	if m.FieldCleared(screeningnoderun.FieldTokensInput) {
		fields = append(fields, screeningnoderun.FieldTokensInput)
	}
	if m.FieldCleared(screeningnoderun.FieldTokensOutput) {
		fields = append(fields, screeningnoderun.FieldTokensOutput)
	}
	if m.FieldCleared(screeningnoderun.FieldTotalCost) {
		fields = append(fields, screeningnoderun.FieldTotalCost)
	}
	if m.FieldCleared(screeningnoderun.FieldStartedAt) {
		fields = append(fields, screeningnoderun.FieldStartedAt)
	}
	if m.FieldCleared(screeningnoderun.FieldFinishedAt) {
		fields = append(fields, screeningnoderun.FieldFinishedAt)
	}
	if m.FieldCleared(screeningnoderun.FieldDurationMs) {
		fields = append(fields, screeningnoderun.FieldDurationMs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScreeningNodeRunMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScreeningNodeRunMutation) ClearField(name string) error {
	switch name {
	case screeningnoderun.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case screeningnoderun.FieldNodeKey:
		m.ClearNodeKey()
		return nil
	case screeningnoderun.FieldTraceID:
		m.ClearTraceID()
		return nil
	case screeningnoderun.FieldAgentVersion:
		m.ClearAgentVersion()
		return nil
	case screeningnoderun.FieldModelName:
		m.ClearModelName()
		return nil
	case screeningnoderun.FieldModelProvider:
		m.ClearModelProvider()
		return nil
	case screeningnoderun.FieldLlmParams:
		m.ClearLlmParams()
		return nil
	case screeningnoderun.FieldInputPayload:
		m.ClearInputPayload()
		return nil
	case screeningnoderun.FieldOutputPayload:
		m.ClearOutputPayload()
		return nil
	case screeningnoderun.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case screeningnoderun.FieldTokensInput:
		m.ClearTokensInput()
		return nil
	case screeningnoderun.FieldTokensOutput:
		m.ClearTokensOutput()
		return nil
	case screeningnoderun.FieldTotalCost:
		m.ClearTotalCost()
		return nil
	case screeningnoderun.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case screeningnoderun.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case screeningnoderun.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	}
	return fmt.Errorf("unknown ScreeningNodeRun nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScreeningNodeRunMutation) ResetField(name string) error {
	switch name {
	case screeningnoderun.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case screeningnoderun.FieldTaskID:
		m.ResetTaskID()
		return nil
	case screeningnoderun.FieldTaskResumeID:
		m.ResetTaskResumeID()
		return nil
	case screeningnoderun.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case screeningnoderun.FieldStatus:
		m.ResetStatus()
		return nil
	case screeningnoderun.FieldAttemptNo:
		m.ResetAttemptNo()
		return nil
	case screeningnoderun.FieldTraceID:
		m.ResetTraceID()
		return nil
	case screeningnoderun.FieldAgentVersion:
		m.ResetAgentVersion()
		return nil
	case screeningnoderun.FieldModelName:
		m.ResetModelName()
		return nil
	case screeningnoderun.FieldModelProvider:
		m.ResetModelProvider()
		return nil
	case screeningnoderun.FieldLlmParams:
		m.ResetLlmParams()
		return nil
	case screeningnoderun.FieldInputPayload:
		m.ResetInputPayload()
		return nil
	case screeningnoderun.FieldOutputPayload:
		m.ResetOutputPayload()
		return nil
	case screeningnoderun.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case screeningnoderun.FieldTokensInput:
		m.ResetTokensInput()
		return nil
	case screeningnoderun.FieldTokensOutput:
		m.ResetTokensOutput()
		return nil
	case screeningnoderun.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case screeningnoderun.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case screeningnoderun.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case screeningnoderun.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case screeningnoderun.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case screeningnoderun.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ScreeningNodeRun field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScreeningNodeRunMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, screeningnoderun.EdgeTask)
	}
	if m.task_resume != nil {
		edges = append(edges, screeningnoderun.EdgeTaskResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScreeningNodeRunMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case screeningnoderun.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case screeningnoderun.EdgeTaskResume:
		if id := m.task_resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScreeningNodeRunMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScreeningNodeRunMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScreeningNodeRunMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, screeningnoderun.EdgeTask)
	}
	if m.clearedtask_resume {
		edges = append(edges, screeningnoderun.EdgeTaskResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScreeningNodeRunMutation) EdgeCleared(name string) bool {
	switch name {
	case screeningnoderun.EdgeTask:
		return m.clearedtask
	case screeningnoderun.EdgeTaskResume:
		return m.clearedtask_resume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScreeningNodeRunMutation) ClearEdge(name string) error {
	switch name {
	case screeningnoderun.EdgeTask:
		m.ClearTask()
		return nil
	case screeningnoderun.EdgeTaskResume:
		m.ClearTaskResume()
		return nil
	}
	return fmt.Errorf("unknown ScreeningNodeRun unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScreeningNodeRunMutation) ResetEdge(name string) error {
	switch name {
	case screeningnoderun.EdgeTask:
		m.ResetTask()
		return nil
	case screeningnoderun.EdgeTaskResume:
		m.ResetTaskResume()
		return nil
	}
	return fmt.Errorf("unknown ScreeningNodeRun edge %s", name)
}

// ScreeningResultMutation represents an operation that mutates the ScreeningResult nodes in the graph.
type ScreeningResultMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	deleted_at            *time.Time
	overall_score         *float64
	addoverall_score      *float64
	match_level           *screeningresult.MatchLevel
	dimension_scores      *map[string]interface{}
	skill_detail          *map[string]interface{}
	responsibility_detail *map[string]interface{}
	experience_detail     *map[string]interface{}
	education_detail      *map[string]interface{}
	industry_detail       *map[string]interface{}
	basic_detail          *map[string]interface{}
	recommendations       *[]string
	appendrecommendations []string
	trace_id              *string
	runtime_metadata      *map[string]interface{}
	sub_agent_versions    *map[string]interface{}
	matched_at            *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	task                  *uuid.UUID
	clearedtask           bool
	job_position          *uuid.UUID
	clearedjob_position   bool
	resume                *uuid.UUID
	clearedresume         bool
	done                  bool
	oldValue              func(context.Context) (*ScreeningResult, error)
	predicates            []predicate.ScreeningResult
}

var _ ent.Mutation = (*ScreeningResultMutation)(nil)

// screeningresultOption allows management of the mutation configuration using functional options.
type screeningresultOption func(*ScreeningResultMutation)

// newScreeningResultMutation creates new mutation for the ScreeningResult entity.
func newScreeningResultMutation(c config, op Op, opts ...screeningresultOption) *ScreeningResultMutation {
	m := &ScreeningResultMutation{
		config:        c,
		op:            op,
		typ:           TypeScreeningResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScreeningResultID sets the ID field of the mutation.
func withScreeningResultID(id uuid.UUID) screeningresultOption {
	return func(m *ScreeningResultMutation) {
		var (
			err   error
			once  sync.Once
			value *ScreeningResult
		)
		m.oldValue = func(ctx context.Context) (*ScreeningResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScreeningResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScreeningResult sets the old ScreeningResult of the mutation.
func withScreeningResult(node *ScreeningResult) screeningresultOption {
	return func(m *ScreeningResultMutation) {
		m.oldValue = func(context.Context) (*ScreeningResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScreeningResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScreeningResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScreeningResult entities.
func (m *ScreeningResultMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScreeningResultMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScreeningResultMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScreeningResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScreeningResultMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScreeningResultMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ScreeningResultMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[screeningresult.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ScreeningResultMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScreeningResultMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, screeningresult.FieldDeletedAt)
}

// SetTaskID sets the "task_id" field.
func (m *ScreeningResultMutation) SetTaskID(u uuid.UUID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ScreeningResultMutation) TaskID() (r uuid.UUID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ScreeningResultMutation) ResetTaskID() {
	m.task = nil
}

// SetJobPositionID sets the "job_position_id" field.
func (m *ScreeningResultMutation) SetJobPositionID(u uuid.UUID) {
	m.job_position = &u
}

// JobPositionID returns the value of the "job_position_id" field in the mutation.
func (m *ScreeningResultMutation) JobPositionID() (r uuid.UUID, exists bool) {
	v := m.job_position
	if v == nil {
		return
	}
	return *v, true
}

// OldJobPositionID returns the old "job_position_id" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldJobPositionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobPositionID: %w", err)
	}
	return oldValue.JobPositionID, nil
}

// ResetJobPositionID resets all changes to the "job_position_id" field.
func (m *ScreeningResultMutation) ResetJobPositionID() {
	m.job_position = nil
}

// SetResumeID sets the "resume_id" field.
func (m *ScreeningResultMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ScreeningResultMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ScreeningResultMutation) ResetResumeID() {
	m.resume = nil
}

// SetOverallScore sets the "overall_score" field.
func (m *ScreeningResultMutation) SetOverallScore(f float64) {
	m.overall_score = &f
	m.addoverall_score = nil
}

// OverallScore returns the value of the "overall_score" field in the mutation.
func (m *ScreeningResultMutation) OverallScore() (r float64, exists bool) {
	v := m.overall_score
	if v == nil {
		return
	}
	return *v, true
}

// OldOverallScore returns the old "overall_score" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldOverallScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverallScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverallScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverallScore: %w", err)
	}
	return oldValue.OverallScore, nil
}

// AddOverallScore adds f to the "overall_score" field.
func (m *ScreeningResultMutation) AddOverallScore(f float64) {
	if m.addoverall_score != nil {
		*m.addoverall_score += f
	} else {
		m.addoverall_score = &f
	}
}

// AddedOverallScore returns the value that was added to the "overall_score" field in this mutation.
func (m *ScreeningResultMutation) AddedOverallScore() (r float64, exists bool) {
	v := m.addoverall_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverallScore resets all changes to the "overall_score" field.
func (m *ScreeningResultMutation) ResetOverallScore() {
	m.overall_score = nil
	m.addoverall_score = nil
}

// SetMatchLevel sets the "match_level" field.
func (m *ScreeningResultMutation) SetMatchLevel(sl screeningresult.MatchLevel) {
	m.match_level = &sl
}

// MatchLevel returns the value of the "match_level" field in the mutation.
func (m *ScreeningResultMutation) MatchLevel() (r screeningresult.MatchLevel, exists bool) {
	v := m.match_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchLevel returns the old "match_level" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldMatchLevel(ctx context.Context) (v screeningresult.MatchLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchLevel: %w", err)
	}
	return oldValue.MatchLevel, nil
}

// ClearMatchLevel clears the value of the "match_level" field.
func (m *ScreeningResultMutation) ClearMatchLevel() {
	m.match_level = nil
	m.clearedFields[screeningresult.FieldMatchLevel] = struct{}{}
}

// MatchLevelCleared returns if the "match_level" field was cleared in this mutation.
func (m *ScreeningResultMutation) MatchLevelCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldMatchLevel]
	return ok
}

// ResetMatchLevel resets all changes to the "match_level" field.
func (m *ScreeningResultMutation) ResetMatchLevel() {
	m.match_level = nil
	delete(m.clearedFields, screeningresult.FieldMatchLevel)
}

// SetDimensionScores sets the "dimension_scores" field.
func (m *ScreeningResultMutation) SetDimensionScores(value map[string]interface{}) {
	m.dimension_scores = &value
}

// DimensionScores returns the value of the "dimension_scores" field in the mutation.
func (m *ScreeningResultMutation) DimensionScores() (r map[string]interface{}, exists bool) {
	v := m.dimension_scores
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensionScores returns the old "dimension_scores" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldDimensionScores(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensionScores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensionScores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensionScores: %w", err)
	}
	return oldValue.DimensionScores, nil
}

// ClearDimensionScores clears the value of the "dimension_scores" field.
func (m *ScreeningResultMutation) ClearDimensionScores() {
	m.dimension_scores = nil
	m.clearedFields[screeningresult.FieldDimensionScores] = struct{}{}
}

// DimensionScoresCleared returns if the "dimension_scores" field was cleared in this mutation.
func (m *ScreeningResultMutation) DimensionScoresCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldDimensionScores]
	return ok
}

// ResetDimensionScores resets all changes to the "dimension_scores" field.
func (m *ScreeningResultMutation) ResetDimensionScores() {
	m.dimension_scores = nil
	delete(m.clearedFields, screeningresult.FieldDimensionScores)
}

// SetSkillDetail sets the "skill_detail" field.
func (m *ScreeningResultMutation) SetSkillDetail(value map[string]interface{}) {
	m.skill_detail = &value
}

// SkillDetail returns the value of the "skill_detail" field in the mutation.
func (m *ScreeningResultMutation) SkillDetail() (r map[string]interface{}, exists bool) {
	v := m.skill_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillDetail returns the old "skill_detail" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldSkillDetail(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillDetail: %w", err)
	}
	return oldValue.SkillDetail, nil
}

// ClearSkillDetail clears the value of the "skill_detail" field.
func (m *ScreeningResultMutation) ClearSkillDetail() {
	m.skill_detail = nil
	m.clearedFields[screeningresult.FieldSkillDetail] = struct{}{}
}

// SkillDetailCleared returns if the "skill_detail" field was cleared in this mutation.
func (m *ScreeningResultMutation) SkillDetailCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldSkillDetail]
	return ok
}

// ResetSkillDetail resets all changes to the "skill_detail" field.
func (m *ScreeningResultMutation) ResetSkillDetail() {
	m.skill_detail = nil
	delete(m.clearedFields, screeningresult.FieldSkillDetail)
}

// SetResponsibilityDetail sets the "responsibility_detail" field.
func (m *ScreeningResultMutation) SetResponsibilityDetail(value map[string]interface{}) {
	m.responsibility_detail = &value
}

// ResponsibilityDetail returns the value of the "responsibility_detail" field in the mutation.
func (m *ScreeningResultMutation) ResponsibilityDetail() (r map[string]interface{}, exists bool) {
	v := m.responsibility_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsibilityDetail returns the old "responsibility_detail" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldResponsibilityDetail(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsibilityDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsibilityDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsibilityDetail: %w", err)
	}
	return oldValue.ResponsibilityDetail, nil
}

// ClearResponsibilityDetail clears the value of the "responsibility_detail" field.
func (m *ScreeningResultMutation) ClearResponsibilityDetail() {
	m.responsibility_detail = nil
	m.clearedFields[screeningresult.FieldResponsibilityDetail] = struct{}{}
}

// ResponsibilityDetailCleared returns if the "responsibility_detail" field was cleared in this mutation.
func (m *ScreeningResultMutation) ResponsibilityDetailCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldResponsibilityDetail]
	return ok
}

// ResetResponsibilityDetail resets all changes to the "responsibility_detail" field.
func (m *ScreeningResultMutation) ResetResponsibilityDetail() {
	m.responsibility_detail = nil
	delete(m.clearedFields, screeningresult.FieldResponsibilityDetail)
}

// SetExperienceDetail sets the "experience_detail" field.
func (m *ScreeningResultMutation) SetExperienceDetail(value map[string]interface{}) {
	m.experience_detail = &value
}

// ExperienceDetail returns the value of the "experience_detail" field in the mutation.
func (m *ScreeningResultMutation) ExperienceDetail() (r map[string]interface{}, exists bool) {
	v := m.experience_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceDetail returns the old "experience_detail" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldExperienceDetail(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceDetail: %w", err)
	}
	return oldValue.ExperienceDetail, nil
}

// ClearExperienceDetail clears the value of the "experience_detail" field.
func (m *ScreeningResultMutation) ClearExperienceDetail() {
	m.experience_detail = nil
	m.clearedFields[screeningresult.FieldExperienceDetail] = struct{}{}
}

// ExperienceDetailCleared returns if the "experience_detail" field was cleared in this mutation.
func (m *ScreeningResultMutation) ExperienceDetailCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldExperienceDetail]
	return ok
}

// ResetExperienceDetail resets all changes to the "experience_detail" field.
func (m *ScreeningResultMutation) ResetExperienceDetail() {
	m.experience_detail = nil
	delete(m.clearedFields, screeningresult.FieldExperienceDetail)
}

// SetEducationDetail sets the "education_detail" field.
func (m *ScreeningResultMutation) SetEducationDetail(value map[string]interface{}) {
	m.education_detail = &value
}

// EducationDetail returns the value of the "education_detail" field in the mutation.
func (m *ScreeningResultMutation) EducationDetail() (r map[string]interface{}, exists bool) {
	v := m.education_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationDetail returns the old "education_detail" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldEducationDetail(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationDetail: %w", err)
	}
	return oldValue.EducationDetail, nil
}

// ClearEducationDetail clears the value of the "education_detail" field.
func (m *ScreeningResultMutation) ClearEducationDetail() {
	m.education_detail = nil
	m.clearedFields[screeningresult.FieldEducationDetail] = struct{}{}
}

// EducationDetailCleared returns if the "education_detail" field was cleared in this mutation.
func (m *ScreeningResultMutation) EducationDetailCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldEducationDetail]
	return ok
}

// ResetEducationDetail resets all changes to the "education_detail" field.
func (m *ScreeningResultMutation) ResetEducationDetail() {
	m.education_detail = nil
	delete(m.clearedFields, screeningresult.FieldEducationDetail)
}

// SetIndustryDetail sets the "industry_detail" field.
func (m *ScreeningResultMutation) SetIndustryDetail(value map[string]interface{}) {
	m.industry_detail = &value
}

// IndustryDetail returns the value of the "industry_detail" field in the mutation.
func (m *ScreeningResultMutation) IndustryDetail() (r map[string]interface{}, exists bool) {
	v := m.industry_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustryDetail returns the old "industry_detail" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldIndustryDetail(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustryDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustryDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustryDetail: %w", err)
	}
	return oldValue.IndustryDetail, nil
}

// ClearIndustryDetail clears the value of the "industry_detail" field.
func (m *ScreeningResultMutation) ClearIndustryDetail() {
	m.industry_detail = nil
	m.clearedFields[screeningresult.FieldIndustryDetail] = struct{}{}
}

// IndustryDetailCleared returns if the "industry_detail" field was cleared in this mutation.
func (m *ScreeningResultMutation) IndustryDetailCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldIndustryDetail]
	return ok
}

// ResetIndustryDetail resets all changes to the "industry_detail" field.
func (m *ScreeningResultMutation) ResetIndustryDetail() {
	m.industry_detail = nil
	delete(m.clearedFields, screeningresult.FieldIndustryDetail)
}

// SetBasicDetail sets the "basic_detail" field.
func (m *ScreeningResultMutation) SetBasicDetail(value map[string]interface{}) {
	m.basic_detail = &value
}

// BasicDetail returns the value of the "basic_detail" field in the mutation.
func (m *ScreeningResultMutation) BasicDetail() (r map[string]interface{}, exists bool) {
	v := m.basic_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldBasicDetail returns the old "basic_detail" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldBasicDetail(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasicDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasicDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasicDetail: %w", err)
	}
	return oldValue.BasicDetail, nil
}

// ClearBasicDetail clears the value of the "basic_detail" field.
func (m *ScreeningResultMutation) ClearBasicDetail() {
	m.basic_detail = nil
	m.clearedFields[screeningresult.FieldBasicDetail] = struct{}{}
}

// BasicDetailCleared returns if the "basic_detail" field was cleared in this mutation.
func (m *ScreeningResultMutation) BasicDetailCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldBasicDetail]
	return ok
}

// ResetBasicDetail resets all changes to the "basic_detail" field.
func (m *ScreeningResultMutation) ResetBasicDetail() {
	m.basic_detail = nil
	delete(m.clearedFields, screeningresult.FieldBasicDetail)
}

// SetRecommendations sets the "recommendations" field.
func (m *ScreeningResultMutation) SetRecommendations(s []string) {
	m.recommendations = &s
	m.appendrecommendations = nil
}

// Recommendations returns the value of the "recommendations" field in the mutation.
func (m *ScreeningResultMutation) Recommendations() (r []string, exists bool) {
	v := m.recommendations
	if v == nil {
		return
	}
	return *v, true
}

// OldRecommendations returns the old "recommendations" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldRecommendations(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecommendations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecommendations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecommendations: %w", err)
	}
	return oldValue.Recommendations, nil
}

// AppendRecommendations adds s to the "recommendations" field.
func (m *ScreeningResultMutation) AppendRecommendations(s []string) {
	m.appendrecommendations = append(m.appendrecommendations, s...)
}

// AppendedRecommendations returns the list of values that were appended to the "recommendations" field in this mutation.
func (m *ScreeningResultMutation) AppendedRecommendations() ([]string, bool) {
	if len(m.appendrecommendations) == 0 {
		return nil, false
	}
	return m.appendrecommendations, true
}

// ClearRecommendations clears the value of the "recommendations" field.
func (m *ScreeningResultMutation) ClearRecommendations() {
	m.recommendations = nil
	m.appendrecommendations = nil
	m.clearedFields[screeningresult.FieldRecommendations] = struct{}{}
}

// RecommendationsCleared returns if the "recommendations" field was cleared in this mutation.
func (m *ScreeningResultMutation) RecommendationsCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldRecommendations]
	return ok
}

// ResetRecommendations resets all changes to the "recommendations" field.
func (m *ScreeningResultMutation) ResetRecommendations() {
	m.recommendations = nil
	m.appendrecommendations = nil
	delete(m.clearedFields, screeningresult.FieldRecommendations)
}

// SetTraceID sets the "trace_id" field.
func (m *ScreeningResultMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *ScreeningResultMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *ScreeningResultMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[screeningresult.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *ScreeningResultMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *ScreeningResultMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, screeningresult.FieldTraceID)
}

// SetRuntimeMetadata sets the "runtime_metadata" field.
func (m *ScreeningResultMutation) SetRuntimeMetadata(value map[string]interface{}) {
	m.runtime_metadata = &value
}

// RuntimeMetadata returns the value of the "runtime_metadata" field in the mutation.
func (m *ScreeningResultMutation) RuntimeMetadata() (r map[string]interface{}, exists bool) {
	v := m.runtime_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntimeMetadata returns the old "runtime_metadata" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldRuntimeMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRuntimeMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRuntimeMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntimeMetadata: %w", err)
	}
	return oldValue.RuntimeMetadata, nil
}

// ClearRuntimeMetadata clears the value of the "runtime_metadata" field.
func (m *ScreeningResultMutation) ClearRuntimeMetadata() {
	m.runtime_metadata = nil
	m.clearedFields[screeningresult.FieldRuntimeMetadata] = struct{}{}
}

// RuntimeMetadataCleared returns if the "runtime_metadata" field was cleared in this mutation.
func (m *ScreeningResultMutation) RuntimeMetadataCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldRuntimeMetadata]
	return ok
}

// ResetRuntimeMetadata resets all changes to the "runtime_metadata" field.
func (m *ScreeningResultMutation) ResetRuntimeMetadata() {
	m.runtime_metadata = nil
	delete(m.clearedFields, screeningresult.FieldRuntimeMetadata)
}

// SetSubAgentVersions sets the "sub_agent_versions" field.
func (m *ScreeningResultMutation) SetSubAgentVersions(value map[string]interface{}) {
	m.sub_agent_versions = &value
}

// SubAgentVersions returns the value of the "sub_agent_versions" field in the mutation.
func (m *ScreeningResultMutation) SubAgentVersions() (r map[string]interface{}, exists bool) {
	v := m.sub_agent_versions
	if v == nil {
		return
	}
	return *v, true
}

// OldSubAgentVersions returns the old "sub_agent_versions" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldSubAgentVersions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubAgentVersions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubAgentVersions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubAgentVersions: %w", err)
	}
	return oldValue.SubAgentVersions, nil
}

// ClearSubAgentVersions clears the value of the "sub_agent_versions" field.
func (m *ScreeningResultMutation) ClearSubAgentVersions() {
	m.sub_agent_versions = nil
	m.clearedFields[screeningresult.FieldSubAgentVersions] = struct{}{}
}

// SubAgentVersionsCleared returns if the "sub_agent_versions" field was cleared in this mutation.
func (m *ScreeningResultMutation) SubAgentVersionsCleared() bool {
	_, ok := m.clearedFields[screeningresult.FieldSubAgentVersions]
	return ok
}

// ResetSubAgentVersions resets all changes to the "sub_agent_versions" field.
func (m *ScreeningResultMutation) ResetSubAgentVersions() {
	m.sub_agent_versions = nil
	delete(m.clearedFields, screeningresult.FieldSubAgentVersions)
}

// SetMatchedAt sets the "matched_at" field.
func (m *ScreeningResultMutation) SetMatchedAt(t time.Time) {
	m.matched_at = &t
}

// MatchedAt returns the value of the "matched_at" field in the mutation.
func (m *ScreeningResultMutation) MatchedAt() (r time.Time, exists bool) {
	v := m.matched_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchedAt returns the old "matched_at" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldMatchedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchedAt: %w", err)
	}
	return oldValue.MatchedAt, nil
}

// ResetMatchedAt resets all changes to the "matched_at" field.
func (m *ScreeningResultMutation) ResetMatchedAt() {
	m.matched_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ScreeningResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScreeningResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScreeningResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScreeningResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScreeningResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScreeningResult entity.
// If the ScreeningResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScreeningResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the ScreeningTask entity.
func (m *ScreeningResultMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[screeningresult.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the ScreeningTask entity was cleared.
func (m *ScreeningResultMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ScreeningResultMutation) TaskIDs() (ids []uuid.UUID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *ScreeningResultMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearJobPosition clears the "job_position" edge to the JobPosition entity.
func (m *ScreeningResultMutation) ClearJobPosition() {
	m.clearedjob_position = true
	m.clearedFields[screeningresult.FieldJobPositionID] = struct{}{}
}

// JobPositionCleared reports if the "job_position" edge to the JobPosition entity was cleared.
func (m *ScreeningResultMutation) JobPositionCleared() bool {
	return m.clearedjob_position
}

// JobPositionIDs returns the "job_position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobPositionID instead. It exists only for internal usage by the builders.
func (m *ScreeningResultMutation) JobPositionIDs() (ids []uuid.UUID) {
	if id := m.job_position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobPosition resets all changes to the "job_position" edge.
func (m *ScreeningResultMutation) ResetJobPosition() {
	m.job_position = nil
	m.clearedjob_position = false
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ScreeningResultMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[screeningresult.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ScreeningResultMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ScreeningResultMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ScreeningResultMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// Where appends a list predicates to the ScreeningResultMutation builder.
func (m *ScreeningResultMutation) Where(ps ...predicate.ScreeningResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScreeningResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScreeningResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScreeningResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScreeningResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScreeningResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScreeningResult).
func (m *ScreeningResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScreeningResultMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.deleted_at != nil {
		fields = append(fields, screeningresult.FieldDeletedAt)
	}
	if m.task != nil {
		fields = append(fields, screeningresult.FieldTaskID)
	}
	if m.job_position != nil {
		fields = append(fields, screeningresult.FieldJobPositionID)
	}
	if m.resume != nil {
		fields = append(fields, screeningresult.FieldResumeID)
	}
	if m.overall_score != nil {
		fields = append(fields, screeningresult.FieldOverallScore)
	}
	if m.match_level != nil {
		fields = append(fields, screeningresult.FieldMatchLevel)
	}
	if m.dimension_scores != nil {
		fields = append(fields, screeningresult.FieldDimensionScores)
	}
	if m.skill_detail != nil {
		fields = append(fields, screeningresult.FieldSkillDetail)
	}
	if m.responsibility_detail != nil {
		fields = append(fields, screeningresult.FieldResponsibilityDetail)
	}
	if m.experience_detail != nil {
		fields = append(fields, screeningresult.FieldExperienceDetail)
	}
	if m.education_detail != nil {
		fields = append(fields, screeningresult.FieldEducationDetail)
	}
	if m.industry_detail != nil {
		fields = append(fields, screeningresult.FieldIndustryDetail)
	}
	if m.basic_detail != nil {
		fields = append(fields, screeningresult.FieldBasicDetail)
	}
	if m.recommendations != nil {
		fields = append(fields, screeningresult.FieldRecommendations)
	}
	if m.trace_id != nil {
		fields = append(fields, screeningresult.FieldTraceID)
	}
	if m.runtime_metadata != nil {
		fields = append(fields, screeningresult.FieldRuntimeMetadata)
	}
	if m.sub_agent_versions != nil {
		fields = append(fields, screeningresult.FieldSubAgentVersions)
	}
	if m.matched_at != nil {
		fields = append(fields, screeningresult.FieldMatchedAt)
	}
	if m.created_at != nil {
		fields = append(fields, screeningresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, screeningresult.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScreeningResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case screeningresult.FieldDeletedAt:
		return m.DeletedAt()
	case screeningresult.FieldTaskID:
		return m.TaskID()
	case screeningresult.FieldJobPositionID:
		return m.JobPositionID()
	case screeningresult.FieldResumeID:
		return m.ResumeID()
	case screeningresult.FieldOverallScore:
		return m.OverallScore()
	case screeningresult.FieldMatchLevel:
		return m.MatchLevel()
	case screeningresult.FieldDimensionScores:
		return m.DimensionScores()
	case screeningresult.FieldSkillDetail:
		return m.SkillDetail()
	case screeningresult.FieldResponsibilityDetail:
		return m.ResponsibilityDetail()
	case screeningresult.FieldExperienceDetail:
		return m.ExperienceDetail()
	case screeningresult.FieldEducationDetail:
		return m.EducationDetail()
	case screeningresult.FieldIndustryDetail:
		return m.IndustryDetail()
	case screeningresult.FieldBasicDetail:
		return m.BasicDetail()
	case screeningresult.FieldRecommendations:
		return m.Recommendations()
	case screeningresult.FieldTraceID:
		return m.TraceID()
	case screeningresult.FieldRuntimeMetadata:
		return m.RuntimeMetadata()
	case screeningresult.FieldSubAgentVersions:
		return m.SubAgentVersions()
	case screeningresult.FieldMatchedAt:
		return m.MatchedAt()
	case screeningresult.FieldCreatedAt:
		return m.CreatedAt()
	case screeningresult.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScreeningResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case screeningresult.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case screeningresult.FieldTaskID:
		return m.OldTaskID(ctx)
	case screeningresult.FieldJobPositionID:
		return m.OldJobPositionID(ctx)
	case screeningresult.FieldResumeID:
		return m.OldResumeID(ctx)
	case screeningresult.FieldOverallScore:
		return m.OldOverallScore(ctx)
	case screeningresult.FieldMatchLevel:
		return m.OldMatchLevel(ctx)
	case screeningresult.FieldDimensionScores:
		return m.OldDimensionScores(ctx)
	case screeningresult.FieldSkillDetail:
		return m.OldSkillDetail(ctx)
	case screeningresult.FieldResponsibilityDetail:
		return m.OldResponsibilityDetail(ctx)
	case screeningresult.FieldExperienceDetail:
		return m.OldExperienceDetail(ctx)
	case screeningresult.FieldEducationDetail:
		return m.OldEducationDetail(ctx)
	case screeningresult.FieldIndustryDetail:
		return m.OldIndustryDetail(ctx)
	case screeningresult.FieldBasicDetail:
		return m.OldBasicDetail(ctx)
	case screeningresult.FieldRecommendations:
		return m.OldRecommendations(ctx)
	case screeningresult.FieldTraceID:
		return m.OldTraceID(ctx)
	case screeningresult.FieldRuntimeMetadata:
		return m.OldRuntimeMetadata(ctx)
	case screeningresult.FieldSubAgentVersions:
		return m.OldSubAgentVersions(ctx)
	case screeningresult.FieldMatchedAt:
		return m.OldMatchedAt(ctx)
	case screeningresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case screeningresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ScreeningResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case screeningresult.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case screeningresult.FieldTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case screeningresult.FieldJobPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobPositionID(v)
		return nil
	case screeningresult.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case screeningresult.FieldOverallScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverallScore(v)
		return nil
	case screeningresult.FieldMatchLevel:
		v, ok := value.(screeningresult.MatchLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchLevel(v)
		return nil
	case screeningresult.FieldDimensionScores:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensionScores(v)
		return nil
	case screeningresult.FieldSkillDetail:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillDetail(v)
		return nil
	case screeningresult.FieldResponsibilityDetail:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsibilityDetail(v)
		return nil
	case screeningresult.FieldExperienceDetail:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceDetail(v)
		return nil
	case screeningresult.FieldEducationDetail:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationDetail(v)
		return nil
	case screeningresult.FieldIndustryDetail:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustryDetail(v)
		return nil
	case screeningresult.FieldBasicDetail:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasicDetail(v)
		return nil
	case screeningresult.FieldRecommendations:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecommendations(v)
		return nil
	case screeningresult.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case screeningresult.FieldRuntimeMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntimeMetadata(v)
		return nil
	case screeningresult.FieldSubAgentVersions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubAgentVersions(v)
		return nil
	case screeningresult.FieldMatchedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchedAt(v)
		return nil
	case screeningresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case screeningresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScreeningResultMutation) AddedFields() []string {
	var fields []string
	if m.addoverall_score != nil {
		fields = append(fields, screeningresult.FieldOverallScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScreeningResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case screeningresult.FieldOverallScore:
		return m.AddedOverallScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case screeningresult.FieldOverallScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverallScore(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScreeningResultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(screeningresult.FieldDeletedAt) {
		fields = append(fields, screeningresult.FieldDeletedAt)
	}
	if m.FieldCleared(screeningresult.FieldMatchLevel) {
		fields = append(fields, screeningresult.FieldMatchLevel)
	}
	if m.FieldCleared(screeningresult.FieldDimensionScores) {
		fields = append(fields, screeningresult.FieldDimensionScores)
	}
	if m.FieldCleared(screeningresult.FieldSkillDetail) {
		fields = append(fields, screeningresult.FieldSkillDetail)
	}
	if m.FieldCleared(screeningresult.FieldResponsibilityDetail) {
		fields = append(fields, screeningresult.FieldResponsibilityDetail)
	}
	if m.FieldCleared(screeningresult.FieldExperienceDetail) {
		fields = append(fields, screeningresult.FieldExperienceDetail)
	}
	if m.FieldCleared(screeningresult.FieldEducationDetail) {
		fields = append(fields, screeningresult.FieldEducationDetail)
	}
	if m.FieldCleared(screeningresult.FieldIndustryDetail) {
		fields = append(fields, screeningresult.FieldIndustryDetail)
	}
	if m.FieldCleared(screeningresult.FieldBasicDetail) {
		fields = append(fields, screeningresult.FieldBasicDetail)
	}
	if m.FieldCleared(screeningresult.FieldRecommendations) {
		fields = append(fields, screeningresult.FieldRecommendations)
	}
	if m.FieldCleared(screeningresult.FieldTraceID) {
		fields = append(fields, screeningresult.FieldTraceID)
	}
	if m.FieldCleared(screeningresult.FieldRuntimeMetadata) {
		fields = append(fields, screeningresult.FieldRuntimeMetadata)
	}
	if m.FieldCleared(screeningresult.FieldSubAgentVersions) {
		fields = append(fields, screeningresult.FieldSubAgentVersions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScreeningResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScreeningResultMutation) ClearField(name string) error {
	switch name {
	case screeningresult.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case screeningresult.FieldMatchLevel:
		m.ClearMatchLevel()
		return nil
	case screeningresult.FieldDimensionScores:
		m.ClearDimensionScores()
		return nil
	case screeningresult.FieldSkillDetail:
		m.ClearSkillDetail()
		return nil
	case screeningresult.FieldResponsibilityDetail:
		m.ClearResponsibilityDetail()
		return nil
	case screeningresult.FieldExperienceDetail:
		m.ClearExperienceDetail()
		return nil
	case screeningresult.FieldEducationDetail:
		m.ClearEducationDetail()
		return nil
	case screeningresult.FieldIndustryDetail:
		m.ClearIndustryDetail()
		return nil
	case screeningresult.FieldBasicDetail:
		m.ClearBasicDetail()
		return nil
	case screeningresult.FieldRecommendations:
		m.ClearRecommendations()
		return nil
	case screeningresult.FieldTraceID:
		m.ClearTraceID()
		return nil
	case screeningresult.FieldRuntimeMetadata:
		m.ClearRuntimeMetadata()
		return nil
	case screeningresult.FieldSubAgentVersions:
		m.ClearSubAgentVersions()
		return nil
	}
	return fmt.Errorf("unknown ScreeningResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScreeningResultMutation) ResetField(name string) error {
	switch name {
	case screeningresult.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case screeningresult.FieldTaskID:
		m.ResetTaskID()
		return nil
	case screeningresult.FieldJobPositionID:
		m.ResetJobPositionID()
		return nil
	case screeningresult.FieldResumeID:
		m.ResetResumeID()
		return nil
	case screeningresult.FieldOverallScore:
		m.ResetOverallScore()
		return nil
	case screeningresult.FieldMatchLevel:
		m.ResetMatchLevel()
		return nil
	case screeningresult.FieldDimensionScores:
		m.ResetDimensionScores()
		return nil
	case screeningresult.FieldSkillDetail:
		m.ResetSkillDetail()
		return nil
	case screeningresult.FieldResponsibilityDetail:
		m.ResetResponsibilityDetail()
		return nil
	case screeningresult.FieldExperienceDetail:
		m.ResetExperienceDetail()
		return nil
	case screeningresult.FieldEducationDetail:
		m.ResetEducationDetail()
		return nil
	case screeningresult.FieldIndustryDetail:
		m.ResetIndustryDetail()
		return nil
	case screeningresult.FieldBasicDetail:
		m.ResetBasicDetail()
		return nil
	case screeningresult.FieldRecommendations:
		m.ResetRecommendations()
		return nil
	case screeningresult.FieldTraceID:
		m.ResetTraceID()
		return nil
	case screeningresult.FieldRuntimeMetadata:
		m.ResetRuntimeMetadata()
		return nil
	case screeningresult.FieldSubAgentVersions:
		m.ResetSubAgentVersions()
		return nil
	case screeningresult.FieldMatchedAt:
		m.ResetMatchedAt()
		return nil
	case screeningresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case screeningresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ScreeningResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScreeningResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.task != nil {
		edges = append(edges, screeningresult.EdgeTask)
	}
	if m.job_position != nil {
		edges = append(edges, screeningresult.EdgeJobPosition)
	}
	if m.resume != nil {
		edges = append(edges, screeningresult.EdgeResume)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScreeningResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case screeningresult.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case screeningresult.EdgeJobPosition:
		if id := m.job_position; id != nil {
			return []ent.Value{*id}
		}
	case screeningresult.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScreeningResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScreeningResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScreeningResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtask {
		edges = append(edges, screeningresult.EdgeTask)
	}
	if m.clearedjob_position {
		edges = append(edges, screeningresult.EdgeJobPosition)
	}
	if m.clearedresume {
		edges = append(edges, screeningresult.EdgeResume)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScreeningResultMutation) EdgeCleared(name string) bool {
	switch name {
	case screeningresult.EdgeTask:
		return m.clearedtask
	case screeningresult.EdgeJobPosition:
		return m.clearedjob_position
	case screeningresult.EdgeResume:
		return m.clearedresume
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScreeningResultMutation) ClearEdge(name string) error {
	switch name {
	case screeningresult.EdgeTask:
		m.ClearTask()
		return nil
	case screeningresult.EdgeJobPosition:
		m.ClearJobPosition()
		return nil
	case screeningresult.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ScreeningResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScreeningResultMutation) ResetEdge(name string) error {
	switch name {
	case screeningresult.EdgeTask:
		m.ResetTask()
		return nil
	case screeningresult.EdgeJobPosition:
		m.ResetJobPosition()
		return nil
	case screeningresult.EdgeResume:
		m.ResetResume()
		return nil
	}
	return fmt.Errorf("unknown ScreeningResult edge %s", name)
}

// ScreeningRunMetricMutation represents an operation that mutates the ScreeningRunMetric nodes in the graph.
type ScreeningRunMetricMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	deleted_at       *time.Time
	avg_score        *float64
	addavg_score     *float64
	histogram        *map[string]interface{}
	tokens_input     *int64
	addtokens_input  *int64
	tokens_output    *int64
	addtokens_output *int64
	total_cost       *float64
	addtotal_cost    *float64
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	task             *uuid.UUID
	clearedtask      bool
	done             bool
	oldValue         func(context.Context) (*ScreeningRunMetric, error)
	predicates       []predicate.ScreeningRunMetric
}

var _ ent.Mutation = (*ScreeningRunMetricMutation)(nil)

// screeningrunmetricOption allows management of the mutation configuration using functional options.
type screeningrunmetricOption func(*ScreeningRunMetricMutation)

// newScreeningRunMetricMutation creates new mutation for the ScreeningRunMetric entity.
func newScreeningRunMetricMutation(c config, op Op, opts ...screeningrunmetricOption) *ScreeningRunMetricMutation {
	m := &ScreeningRunMetricMutation{
		config:        c,
		op:            op,
		typ:           TypeScreeningRunMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScreeningRunMetricID sets the ID field of the mutation.
func withScreeningRunMetricID(id uuid.UUID) screeningrunmetricOption {
	return func(m *ScreeningRunMetricMutation) {
		var (
			err   error
			once  sync.Once
			value *ScreeningRunMetric
		)
		m.oldValue = func(ctx context.Context) (*ScreeningRunMetric, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScreeningRunMetric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScreeningRunMetric sets the old ScreeningRunMetric of the mutation.
func withScreeningRunMetric(node *ScreeningRunMetric) screeningrunmetricOption {
	return func(m *ScreeningRunMetricMutation) {
		m.oldValue = func(context.Context) (*ScreeningRunMetric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScreeningRunMetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScreeningRunMetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScreeningRunMetric entities.
func (m *ScreeningRunMetricMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScreeningRunMetricMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScreeningRunMetricMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScreeningRunMetric.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScreeningRunMetricMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScreeningRunMetricMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ScreeningRunMetricMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[screeningrunmetric.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ScreeningRunMetricMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[screeningrunmetric.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScreeningRunMetricMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, screeningrunmetric.FieldDeletedAt)
}

// SetTaskID sets the "task_id" field.
func (m *ScreeningRunMetricMutation) SetTaskID(u uuid.UUID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ScreeningRunMetricMutation) TaskID() (r uuid.UUID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ScreeningRunMetricMutation) ResetTaskID() {
	m.task = nil
}

// SetAvgScore sets the "avg_score" field.
func (m *ScreeningRunMetricMutation) SetAvgScore(f float64) {
	m.avg_score = &f
	m.addavg_score = nil
}

// AvgScore returns the value of the "avg_score" field in the mutation.
func (m *ScreeningRunMetricMutation) AvgScore() (r float64, exists bool) {
	v := m.avg_score
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgScore returns the old "avg_score" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldAvgScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgScore: %w", err)
	}
	return oldValue.AvgScore, nil
}

// AddAvgScore adds f to the "avg_score" field.
func (m *ScreeningRunMetricMutation) AddAvgScore(f float64) {
	if m.addavg_score != nil {
		*m.addavg_score += f
	} else {
		m.addavg_score = &f
	}
}

// AddedAvgScore returns the value that was added to the "avg_score" field in this mutation.
func (m *ScreeningRunMetricMutation) AddedAvgScore() (r float64, exists bool) {
	v := m.addavg_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvgScore clears the value of the "avg_score" field.
func (m *ScreeningRunMetricMutation) ClearAvgScore() {
	m.avg_score = nil
	m.addavg_score = nil
	m.clearedFields[screeningrunmetric.FieldAvgScore] = struct{}{}
}

// AvgScoreCleared returns if the "avg_score" field was cleared in this mutation.
func (m *ScreeningRunMetricMutation) AvgScoreCleared() bool {
	_, ok := m.clearedFields[screeningrunmetric.FieldAvgScore]
	return ok
}

// ResetAvgScore resets all changes to the "avg_score" field.
func (m *ScreeningRunMetricMutation) ResetAvgScore() {
	m.avg_score = nil
	m.addavg_score = nil
	delete(m.clearedFields, screeningrunmetric.FieldAvgScore)
}

// SetHistogram sets the "histogram" field.
func (m *ScreeningRunMetricMutation) SetHistogram(value map[string]interface{}) {
	m.histogram = &value
}

// Histogram returns the value of the "histogram" field in the mutation.
func (m *ScreeningRunMetricMutation) Histogram() (r map[string]interface{}, exists bool) {
	v := m.histogram
	if v == nil {
		return
	}
	return *v, true
}

// OldHistogram returns the old "histogram" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldHistogram(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistogram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistogram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistogram: %w", err)
	}
	return oldValue.Histogram, nil
}

// ClearHistogram clears the value of the "histogram" field.
func (m *ScreeningRunMetricMutation) ClearHistogram() {
	m.histogram = nil
	m.clearedFields[screeningrunmetric.FieldHistogram] = struct{}{}
}

// HistogramCleared returns if the "histogram" field was cleared in this mutation.
func (m *ScreeningRunMetricMutation) HistogramCleared() bool {
	_, ok := m.clearedFields[screeningrunmetric.FieldHistogram]
	return ok
}

// ResetHistogram resets all changes to the "histogram" field.
func (m *ScreeningRunMetricMutation) ResetHistogram() {
	m.histogram = nil
	delete(m.clearedFields, screeningrunmetric.FieldHistogram)
}

// SetTokensInput sets the "tokens_input" field.
func (m *ScreeningRunMetricMutation) SetTokensInput(i int64) {
	m.tokens_input = &i
	m.addtokens_input = nil
}

// TokensInput returns the value of the "tokens_input" field in the mutation.
func (m *ScreeningRunMetricMutation) TokensInput() (r int64, exists bool) {
	v := m.tokens_input
	if v == nil {
		return
	}
	return *v, true
}

// OldTokensInput returns the old "tokens_input" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldTokensInput(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokensInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokensInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokensInput: %w", err)
	}
	return oldValue.TokensInput, nil
}

// AddTokensInput adds i to the "tokens_input" field.
func (m *ScreeningRunMetricMutation) AddTokensInput(i int64) {
	if m.addtokens_input != nil {
		*m.addtokens_input += i
	} else {
		m.addtokens_input = &i
	}
}

// AddedTokensInput returns the value that was added to the "tokens_input" field in this mutation.
func (m *ScreeningRunMetricMutation) AddedTokensInput() (r int64, exists bool) {
	v := m.addtokens_input
	if v == nil {
		return
	}
	return *v, true
}

// ClearTokensInput clears the value of the "tokens_input" field.
func (m *ScreeningRunMetricMutation) ClearTokensInput() {
	m.tokens_input = nil
	m.addtokens_input = nil
	m.clearedFields[screeningrunmetric.FieldTokensInput] = struct{}{}
}

// TokensInputCleared returns if the "tokens_input" field was cleared in this mutation.
func (m *ScreeningRunMetricMutation) TokensInputCleared() bool {
	_, ok := m.clearedFields[screeningrunmetric.FieldTokensInput]
	return ok
}

// ResetTokensInput resets all changes to the "tokens_input" field.
func (m *ScreeningRunMetricMutation) ResetTokensInput() {
	m.tokens_input = nil
	m.addtokens_input = nil
	delete(m.clearedFields, screeningrunmetric.FieldTokensInput)
}

// SetTokensOutput sets the "tokens_output" field.
func (m *ScreeningRunMetricMutation) SetTokensOutput(i int64) {
	m.tokens_output = &i
	m.addtokens_output = nil
}

// TokensOutput returns the value of the "tokens_output" field in the mutation.
func (m *ScreeningRunMetricMutation) TokensOutput() (r int64, exists bool) {
	v := m.tokens_output
	if v == nil {
		return
	}
	return *v, true
}

// OldTokensOutput returns the old "tokens_output" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldTokensOutput(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokensOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokensOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokensOutput: %w", err)
	}
	return oldValue.TokensOutput, nil
}

// AddTokensOutput adds i to the "tokens_output" field.
func (m *ScreeningRunMetricMutation) AddTokensOutput(i int64) {
	if m.addtokens_output != nil {
		*m.addtokens_output += i
	} else {
		m.addtokens_output = &i
	}
}

// AddedTokensOutput returns the value that was added to the "tokens_output" field in this mutation.
func (m *ScreeningRunMetricMutation) AddedTokensOutput() (r int64, exists bool) {
	v := m.addtokens_output
	if v == nil {
		return
	}
	return *v, true
}

// ClearTokensOutput clears the value of the "tokens_output" field.
func (m *ScreeningRunMetricMutation) ClearTokensOutput() {
	m.tokens_output = nil
	m.addtokens_output = nil
	m.clearedFields[screeningrunmetric.FieldTokensOutput] = struct{}{}
}

// TokensOutputCleared returns if the "tokens_output" field was cleared in this mutation.
func (m *ScreeningRunMetricMutation) TokensOutputCleared() bool {
	_, ok := m.clearedFields[screeningrunmetric.FieldTokensOutput]
	return ok
}

// ResetTokensOutput resets all changes to the "tokens_output" field.
func (m *ScreeningRunMetricMutation) ResetTokensOutput() {
	m.tokens_output = nil
	m.addtokens_output = nil
	delete(m.clearedFields, screeningrunmetric.FieldTokensOutput)
}

// SetTotalCost sets the "total_cost" field.
func (m *ScreeningRunMetricMutation) SetTotalCost(f float64) {
	m.total_cost = &f
	m.addtotal_cost = nil
}

// TotalCost returns the value of the "total_cost" field in the mutation.
func (m *ScreeningRunMetricMutation) TotalCost() (r float64, exists bool) {
	v := m.total_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "total_cost" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldTotalCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "total_cost" field.
func (m *ScreeningRunMetricMutation) AddTotalCost(f float64) {
	if m.addtotal_cost != nil {
		*m.addtotal_cost += f
	} else {
		m.addtotal_cost = &f
	}
}

// AddedTotalCost returns the value that was added to the "total_cost" field in this mutation.
func (m *ScreeningRunMetricMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotal_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalCost clears the value of the "total_cost" field.
func (m *ScreeningRunMetricMutation) ClearTotalCost() {
	m.total_cost = nil
	m.addtotal_cost = nil
	m.clearedFields[screeningrunmetric.FieldTotalCost] = struct{}{}
}

// TotalCostCleared returns if the "total_cost" field was cleared in this mutation.
func (m *ScreeningRunMetricMutation) TotalCostCleared() bool {
	_, ok := m.clearedFields[screeningrunmetric.FieldTotalCost]
	return ok
}

// ResetTotalCost resets all changes to the "total_cost" field.
func (m *ScreeningRunMetricMutation) ResetTotalCost() {
	m.total_cost = nil
	m.addtotal_cost = nil
	delete(m.clearedFields, screeningrunmetric.FieldTotalCost)
}

// SetCreatedAt sets the "created_at" field.
func (m *ScreeningRunMetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScreeningRunMetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScreeningRunMetricMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScreeningRunMetricMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScreeningRunMetricMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScreeningRunMetric entity.
// If the ScreeningRunMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningRunMetricMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScreeningRunMetricMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the ScreeningTask entity.
func (m *ScreeningRunMetricMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[screeningrunmetric.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the ScreeningTask entity was cleared.
func (m *ScreeningRunMetricMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ScreeningRunMetricMutation) TaskIDs() (ids []uuid.UUID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *ScreeningRunMetricMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the ScreeningRunMetricMutation builder.
func (m *ScreeningRunMetricMutation) Where(ps ...predicate.ScreeningRunMetric) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScreeningRunMetricMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScreeningRunMetricMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScreeningRunMetric, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScreeningRunMetricMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScreeningRunMetricMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScreeningRunMetric).
func (m *ScreeningRunMetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScreeningRunMetricMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, screeningrunmetric.FieldDeletedAt)
	}
	if m.task != nil {
		fields = append(fields, screeningrunmetric.FieldTaskID)
	}
	if m.avg_score != nil {
		fields = append(fields, screeningrunmetric.FieldAvgScore)
	}
	if m.histogram != nil {
		fields = append(fields, screeningrunmetric.FieldHistogram)
	}
	if m.tokens_input != nil {
		fields = append(fields, screeningrunmetric.FieldTokensInput)
	}
	if m.tokens_output != nil {
		fields = append(fields, screeningrunmetric.FieldTokensOutput)
	}
	if m.total_cost != nil {
		fields = append(fields, screeningrunmetric.FieldTotalCost)
	}
	if m.created_at != nil {
		fields = append(fields, screeningrunmetric.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, screeningrunmetric.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScreeningRunMetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case screeningrunmetric.FieldDeletedAt:
		return m.DeletedAt()
	case screeningrunmetric.FieldTaskID:
		return m.TaskID()
	case screeningrunmetric.FieldAvgScore:
		return m.AvgScore()
	case screeningrunmetric.FieldHistogram:
		return m.Histogram()
	case screeningrunmetric.FieldTokensInput:
		return m.TokensInput()
	case screeningrunmetric.FieldTokensOutput:
		return m.TokensOutput()
	case screeningrunmetric.FieldTotalCost:
		return m.TotalCost()
	case screeningrunmetric.FieldCreatedAt:
		return m.CreatedAt()
	case screeningrunmetric.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScreeningRunMetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case screeningrunmetric.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case screeningrunmetric.FieldTaskID:
		return m.OldTaskID(ctx)
	case screeningrunmetric.FieldAvgScore:
		return m.OldAvgScore(ctx)
	case screeningrunmetric.FieldHistogram:
		return m.OldHistogram(ctx)
	case screeningrunmetric.FieldTokensInput:
		return m.OldTokensInput(ctx)
	case screeningrunmetric.FieldTokensOutput:
		return m.OldTokensOutput(ctx)
	case screeningrunmetric.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case screeningrunmetric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case screeningrunmetric.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ScreeningRunMetric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningRunMetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case screeningrunmetric.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case screeningrunmetric.FieldTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case screeningrunmetric.FieldAvgScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgScore(v)
		return nil
	case screeningrunmetric.FieldHistogram:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistogram(v)
		return nil
	case screeningrunmetric.FieldTokensInput:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokensInput(v)
		return nil
	case screeningrunmetric.FieldTokensOutput:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokensOutput(v)
		return nil
	case screeningrunmetric.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case screeningrunmetric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case screeningrunmetric.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningRunMetric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScreeningRunMetricMutation) AddedFields() []string {
	var fields []string
	if m.addavg_score != nil {
		fields = append(fields, screeningrunmetric.FieldAvgScore)
	}
	if m.addtokens_input != nil {
		fields = append(fields, screeningrunmetric.FieldTokensInput)
	}
	if m.addtokens_output != nil {
		fields = append(fields, screeningrunmetric.FieldTokensOutput)
	}
	if m.addtotal_cost != nil {
		fields = append(fields, screeningrunmetric.FieldTotalCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScreeningRunMetricMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case screeningrunmetric.FieldAvgScore:
		return m.AddedAvgScore()
	case screeningrunmetric.FieldTokensInput:
		return m.AddedTokensInput()
	case screeningrunmetric.FieldTokensOutput:
		return m.AddedTokensOutput()
	case screeningrunmetric.FieldTotalCost:
		return m.AddedTotalCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningRunMetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	case screeningrunmetric.FieldAvgScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgScore(v)
		return nil
	case screeningrunmetric.FieldTokensInput:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokensInput(v)
		return nil
	case screeningrunmetric.FieldTokensOutput:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokensOutput(v)
		return nil
	case screeningrunmetric.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningRunMetric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScreeningRunMetricMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(screeningrunmetric.FieldDeletedAt) {
		fields = append(fields, screeningrunmetric.FieldDeletedAt)
	}
	if m.FieldCleared(screeningrunmetric.FieldAvgScore) {
		fields = append(fields, screeningrunmetric.FieldAvgScore)
	}
	if m.FieldCleared(screeningrunmetric.FieldHistogram) {
		fields = append(fields, screeningrunmetric.FieldHistogram)
	}
	if m.FieldCleared(screeningrunmetric.FieldTokensInput) {
		fields = append(fields, screeningrunmetric.FieldTokensInput)
	}
	if m.FieldCleared(screeningrunmetric.FieldTokensOutput) {
		fields = append(fields, screeningrunmetric.FieldTokensOutput)
	}
	if m.FieldCleared(screeningrunmetric.FieldTotalCost) {
		fields = append(fields, screeningrunmetric.FieldTotalCost)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScreeningRunMetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScreeningRunMetricMutation) ClearField(name string) error {
	switch name {
	case screeningrunmetric.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case screeningrunmetric.FieldAvgScore:
		m.ClearAvgScore()
		return nil
	case screeningrunmetric.FieldHistogram:
		m.ClearHistogram()
		return nil
	case screeningrunmetric.FieldTokensInput:
		m.ClearTokensInput()
		return nil
	case screeningrunmetric.FieldTokensOutput:
		m.ClearTokensOutput()
		return nil
	case screeningrunmetric.FieldTotalCost:
		m.ClearTotalCost()
		return nil
	}
	return fmt.Errorf("unknown ScreeningRunMetric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScreeningRunMetricMutation) ResetField(name string) error {
	switch name {
	case screeningrunmetric.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case screeningrunmetric.FieldTaskID:
		m.ResetTaskID()
		return nil
	case screeningrunmetric.FieldAvgScore:
		m.ResetAvgScore()
		return nil
	case screeningrunmetric.FieldHistogram:
		m.ResetHistogram()
		return nil
	case screeningrunmetric.FieldTokensInput:
		m.ResetTokensInput()
		return nil
	case screeningrunmetric.FieldTokensOutput:
		m.ResetTokensOutput()
		return nil
	case screeningrunmetric.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case screeningrunmetric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case screeningrunmetric.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ScreeningRunMetric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScreeningRunMetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task != nil {
		edges = append(edges, screeningrunmetric.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScreeningRunMetricMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case screeningrunmetric.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScreeningRunMetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScreeningRunMetricMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScreeningRunMetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask {
		edges = append(edges, screeningrunmetric.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScreeningRunMetricMutation) EdgeCleared(name string) bool {
	switch name {
	case screeningrunmetric.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScreeningRunMetricMutation) ClearEdge(name string) error {
	switch name {
	case screeningrunmetric.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown ScreeningRunMetric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScreeningRunMetricMutation) ResetEdge(name string) error {
	switch name {
	case screeningrunmetric.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown ScreeningRunMetric edge %s", name)
}

// ScreeningTaskMutation represents an operation that mutates the ScreeningTask nodes in the graph.
type ScreeningTaskMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	deleted_at          *time.Time
	status              *string
	dimension_weights   *map[string]interface{}
	llm_config          *map[string]interface{}
	notes               *string
	resume_total        *int
	addresume_total     *int
	resume_processed    *int
	addresume_processed *int
	resume_succeeded    *int
	addresume_succeeded *int
	resume_failed       *int
	addresume_failed    *int
	agent_version       *string
	started_at          *time.Time
	finished_at         *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	job_position        *uuid.UUID
	clearedjob_position bool
	creator             *uuid.UUID
	clearedcreator      bool
	task_resumes        map[uuid.UUID]struct{}
	removedtask_resumes map[uuid.UUID]struct{}
	clearedtask_resumes bool
	results             map[uuid.UUID]struct{}
	removedresults      map[uuid.UUID]struct{}
	clearedresults      bool
	run_metrics         map[uuid.UUID]struct{}
	removedrun_metrics  map[uuid.UUID]struct{}
	clearedrun_metrics  bool
	node_runs           map[uuid.UUID]struct{}
	removednode_runs    map[uuid.UUID]struct{}
	clearednode_runs    bool
	done                bool
	oldValue            func(context.Context) (*ScreeningTask, error)
	predicates          []predicate.ScreeningTask
}

var _ ent.Mutation = (*ScreeningTaskMutation)(nil)

// screeningtaskOption allows management of the mutation configuration using functional options.
type screeningtaskOption func(*ScreeningTaskMutation)

// newScreeningTaskMutation creates new mutation for the ScreeningTask entity.
func newScreeningTaskMutation(c config, op Op, opts ...screeningtaskOption) *ScreeningTaskMutation {
	m := &ScreeningTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeScreeningTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScreeningTaskID sets the ID field of the mutation.
func withScreeningTaskID(id uuid.UUID) screeningtaskOption {
	return func(m *ScreeningTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ScreeningTask
		)
		m.oldValue = func(ctx context.Context) (*ScreeningTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScreeningTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScreeningTask sets the old ScreeningTask of the mutation.
func withScreeningTask(node *ScreeningTask) screeningtaskOption {
	return func(m *ScreeningTaskMutation) {
		m.oldValue = func(context.Context) (*ScreeningTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScreeningTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScreeningTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScreeningTask entities.
func (m *ScreeningTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScreeningTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScreeningTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScreeningTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScreeningTaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScreeningTaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ScreeningTaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[screeningtask.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ScreeningTaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[screeningtask.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScreeningTaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, screeningtask.FieldDeletedAt)
}

// SetJobPositionID sets the "job_position_id" field.
func (m *ScreeningTaskMutation) SetJobPositionID(u uuid.UUID) {
	m.job_position = &u
}

// JobPositionID returns the value of the "job_position_id" field in the mutation.
func (m *ScreeningTaskMutation) JobPositionID() (r uuid.UUID, exists bool) {
	v := m.job_position
	if v == nil {
		return
	}
	return *v, true
}

// OldJobPositionID returns the old "job_position_id" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldJobPositionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobPositionID: %w", err)
	}
	return oldValue.JobPositionID, nil
}

// ResetJobPositionID resets all changes to the "job_position_id" field.
func (m *ScreeningTaskMutation) ResetJobPositionID() {
	m.job_position = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ScreeningTaskMutation) SetCreatedBy(u uuid.UUID) {
	m.creator = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ScreeningTaskMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ScreeningTaskMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetStatus sets the "status" field.
func (m *ScreeningTaskMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ScreeningTaskMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ScreeningTaskMutation) ResetStatus() {
	m.status = nil
}

// SetDimensionWeights sets the "dimension_weights" field.
func (m *ScreeningTaskMutation) SetDimensionWeights(value map[string]interface{}) {
	m.dimension_weights = &value
}

// DimensionWeights returns the value of the "dimension_weights" field in the mutation.
func (m *ScreeningTaskMutation) DimensionWeights() (r map[string]interface{}, exists bool) {
	v := m.dimension_weights
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensionWeights returns the old "dimension_weights" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldDimensionWeights(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensionWeights is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensionWeights requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensionWeights: %w", err)
	}
	return oldValue.DimensionWeights, nil
}

// ClearDimensionWeights clears the value of the "dimension_weights" field.
func (m *ScreeningTaskMutation) ClearDimensionWeights() {
	m.dimension_weights = nil
	m.clearedFields[screeningtask.FieldDimensionWeights] = struct{}{}
}

// DimensionWeightsCleared returns if the "dimension_weights" field was cleared in this mutation.
func (m *ScreeningTaskMutation) DimensionWeightsCleared() bool {
	_, ok := m.clearedFields[screeningtask.FieldDimensionWeights]
	return ok
}

// ResetDimensionWeights resets all changes to the "dimension_weights" field.
func (m *ScreeningTaskMutation) ResetDimensionWeights() {
	m.dimension_weights = nil
	delete(m.clearedFields, screeningtask.FieldDimensionWeights)
}

// SetLlmConfig sets the "llm_config" field.
func (m *ScreeningTaskMutation) SetLlmConfig(value map[string]interface{}) {
	m.llm_config = &value
}

// LlmConfig returns the value of the "llm_config" field in the mutation.
func (m *ScreeningTaskMutation) LlmConfig() (r map[string]interface{}, exists bool) {
	v := m.llm_config
	if v == nil {
		return
	}
	return *v, true
}

// OldLlmConfig returns the old "llm_config" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldLlmConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLlmConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLlmConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLlmConfig: %w", err)
	}
	return oldValue.LlmConfig, nil
}

// ClearLlmConfig clears the value of the "llm_config" field.
func (m *ScreeningTaskMutation) ClearLlmConfig() {
	m.llm_config = nil
	m.clearedFields[screeningtask.FieldLlmConfig] = struct{}{}
}

// LlmConfigCleared returns if the "llm_config" field was cleared in this mutation.
func (m *ScreeningTaskMutation) LlmConfigCleared() bool {
	_, ok := m.clearedFields[screeningtask.FieldLlmConfig]
	return ok
}

// ResetLlmConfig resets all changes to the "llm_config" field.
func (m *ScreeningTaskMutation) ResetLlmConfig() {
	m.llm_config = nil
	delete(m.clearedFields, screeningtask.FieldLlmConfig)
}

// SetNotes sets the "notes" field.
func (m *ScreeningTaskMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ScreeningTaskMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ScreeningTaskMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[screeningtask.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ScreeningTaskMutation) NotesCleared() bool {
	_, ok := m.clearedFields[screeningtask.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ScreeningTaskMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, screeningtask.FieldNotes)
}

// SetResumeTotal sets the "resume_total" field.
func (m *ScreeningTaskMutation) SetResumeTotal(i int) {
	m.resume_total = &i
	m.addresume_total = nil
}

// ResumeTotal returns the value of the "resume_total" field in the mutation.
func (m *ScreeningTaskMutation) ResumeTotal() (r int, exists bool) {
	v := m.resume_total
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeTotal returns the old "resume_total" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldResumeTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeTotal: %w", err)
	}
	return oldValue.ResumeTotal, nil
}

// AddResumeTotal adds i to the "resume_total" field.
func (m *ScreeningTaskMutation) AddResumeTotal(i int) {
	if m.addresume_total != nil {
		*m.addresume_total += i
	} else {
		m.addresume_total = &i
	}
}

// AddedResumeTotal returns the value that was added to the "resume_total" field in this mutation.
func (m *ScreeningTaskMutation) AddedResumeTotal() (r int, exists bool) {
	v := m.addresume_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetResumeTotal resets all changes to the "resume_total" field.
func (m *ScreeningTaskMutation) ResetResumeTotal() {
	m.resume_total = nil
	m.addresume_total = nil
}

// SetResumeProcessed sets the "resume_processed" field.
func (m *ScreeningTaskMutation) SetResumeProcessed(i int) {
	m.resume_processed = &i
	m.addresume_processed = nil
}

// ResumeProcessed returns the value of the "resume_processed" field in the mutation.
func (m *ScreeningTaskMutation) ResumeProcessed() (r int, exists bool) {
	v := m.resume_processed
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeProcessed returns the old "resume_processed" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldResumeProcessed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeProcessed: %w", err)
	}
	return oldValue.ResumeProcessed, nil
}

// AddResumeProcessed adds i to the "resume_processed" field.
func (m *ScreeningTaskMutation) AddResumeProcessed(i int) {
	if m.addresume_processed != nil {
		*m.addresume_processed += i
	} else {
		m.addresume_processed = &i
	}
}

// AddedResumeProcessed returns the value that was added to the "resume_processed" field in this mutation.
func (m *ScreeningTaskMutation) AddedResumeProcessed() (r int, exists bool) {
	v := m.addresume_processed
	if v == nil {
		return
	}
	return *v, true
}

// ResetResumeProcessed resets all changes to the "resume_processed" field.
func (m *ScreeningTaskMutation) ResetResumeProcessed() {
	m.resume_processed = nil
	m.addresume_processed = nil
}

// SetResumeSucceeded sets the "resume_succeeded" field.
func (m *ScreeningTaskMutation) SetResumeSucceeded(i int) {
	m.resume_succeeded = &i
	m.addresume_succeeded = nil
}

// ResumeSucceeded returns the value of the "resume_succeeded" field in the mutation.
func (m *ScreeningTaskMutation) ResumeSucceeded() (r int, exists bool) {
	v := m.resume_succeeded
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeSucceeded returns the old "resume_succeeded" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldResumeSucceeded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeSucceeded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeSucceeded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeSucceeded: %w", err)
	}
	return oldValue.ResumeSucceeded, nil
}

// AddResumeSucceeded adds i to the "resume_succeeded" field.
func (m *ScreeningTaskMutation) AddResumeSucceeded(i int) {
	if m.addresume_succeeded != nil {
		*m.addresume_succeeded += i
	} else {
		m.addresume_succeeded = &i
	}
}

// AddedResumeSucceeded returns the value that was added to the "resume_succeeded" field in this mutation.
func (m *ScreeningTaskMutation) AddedResumeSucceeded() (r int, exists bool) {
	v := m.addresume_succeeded
	if v == nil {
		return
	}
	return *v, true
}

// ResetResumeSucceeded resets all changes to the "resume_succeeded" field.
func (m *ScreeningTaskMutation) ResetResumeSucceeded() {
	m.resume_succeeded = nil
	m.addresume_succeeded = nil
}

// SetResumeFailed sets the "resume_failed" field.
func (m *ScreeningTaskMutation) SetResumeFailed(i int) {
	m.resume_failed = &i
	m.addresume_failed = nil
}

// ResumeFailed returns the value of the "resume_failed" field in the mutation.
func (m *ScreeningTaskMutation) ResumeFailed() (r int, exists bool) {
	v := m.resume_failed
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeFailed returns the old "resume_failed" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldResumeFailed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeFailed: %w", err)
	}
	return oldValue.ResumeFailed, nil
}

// AddResumeFailed adds i to the "resume_failed" field.
func (m *ScreeningTaskMutation) AddResumeFailed(i int) {
	if m.addresume_failed != nil {
		*m.addresume_failed += i
	} else {
		m.addresume_failed = &i
	}
}

// AddedResumeFailed returns the value that was added to the "resume_failed" field in this mutation.
func (m *ScreeningTaskMutation) AddedResumeFailed() (r int, exists bool) {
	v := m.addresume_failed
	if v == nil {
		return
	}
	return *v, true
}

// ResetResumeFailed resets all changes to the "resume_failed" field.
func (m *ScreeningTaskMutation) ResetResumeFailed() {
	m.resume_failed = nil
	m.addresume_failed = nil
}

// SetAgentVersion sets the "agent_version" field.
func (m *ScreeningTaskMutation) SetAgentVersion(s string) {
	m.agent_version = &s
}

// AgentVersion returns the value of the "agent_version" field in the mutation.
func (m *ScreeningTaskMutation) AgentVersion() (r string, exists bool) {
	v := m.agent_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentVersion returns the old "agent_version" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldAgentVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentVersion: %w", err)
	}
	return oldValue.AgentVersion, nil
}

// ClearAgentVersion clears the value of the "agent_version" field.
func (m *ScreeningTaskMutation) ClearAgentVersion() {
	m.agent_version = nil
	m.clearedFields[screeningtask.FieldAgentVersion] = struct{}{}
}

// AgentVersionCleared returns if the "agent_version" field was cleared in this mutation.
func (m *ScreeningTaskMutation) AgentVersionCleared() bool {
	_, ok := m.clearedFields[screeningtask.FieldAgentVersion]
	return ok
}

// ResetAgentVersion resets all changes to the "agent_version" field.
func (m *ScreeningTaskMutation) ResetAgentVersion() {
	m.agent_version = nil
	delete(m.clearedFields, screeningtask.FieldAgentVersion)
}

// SetStartedAt sets the "started_at" field.
func (m *ScreeningTaskMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ScreeningTaskMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *ScreeningTaskMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[screeningtask.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *ScreeningTaskMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[screeningtask.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ScreeningTaskMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, screeningtask.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *ScreeningTaskMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ScreeningTaskMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *ScreeningTaskMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[screeningtask.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *ScreeningTaskMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[screeningtask.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ScreeningTaskMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, screeningtask.FieldFinishedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ScreeningTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScreeningTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScreeningTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScreeningTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScreeningTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScreeningTask entity.
// If the ScreeningTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScreeningTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearJobPosition clears the "job_position" edge to the JobPosition entity.
func (m *ScreeningTaskMutation) ClearJobPosition() {
	m.clearedjob_position = true
	m.clearedFields[screeningtask.FieldJobPositionID] = struct{}{}
}

// JobPositionCleared reports if the "job_position" edge to the JobPosition entity was cleared.
func (m *ScreeningTaskMutation) JobPositionCleared() bool {
	return m.clearedjob_position
}

// JobPositionIDs returns the "job_position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobPositionID instead. It exists only for internal usage by the builders.
func (m *ScreeningTaskMutation) JobPositionIDs() (ids []uuid.UUID) {
	if id := m.job_position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobPosition resets all changes to the "job_position" edge.
func (m *ScreeningTaskMutation) ResetJobPosition() {
	m.job_position = nil
	m.clearedjob_position = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *ScreeningTaskMutation) SetCreatorID(id uuid.UUID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *ScreeningTaskMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[screeningtask.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *ScreeningTaskMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *ScreeningTaskMutation) CreatorID() (id uuid.UUID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *ScreeningTaskMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *ScreeningTaskMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddTaskResumeIDs adds the "task_resumes" edge to the ScreeningTaskResume entity by ids.
func (m *ScreeningTaskMutation) AddTaskResumeIDs(ids ...uuid.UUID) {
	if m.task_resumes == nil {
		m.task_resumes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.task_resumes[ids[i]] = struct{}{}
	}
}

// ClearTaskResumes clears the "task_resumes" edge to the ScreeningTaskResume entity.
func (m *ScreeningTaskMutation) ClearTaskResumes() {
	m.clearedtask_resumes = true
}

// TaskResumesCleared reports if the "task_resumes" edge to the ScreeningTaskResume entity was cleared.
func (m *ScreeningTaskMutation) TaskResumesCleared() bool {
	return m.clearedtask_resumes
}

// RemoveTaskResumeIDs removes the "task_resumes" edge to the ScreeningTaskResume entity by IDs.
func (m *ScreeningTaskMutation) RemoveTaskResumeIDs(ids ...uuid.UUID) {
	if m.removedtask_resumes == nil {
		m.removedtask_resumes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.task_resumes, ids[i])
		m.removedtask_resumes[ids[i]] = struct{}{}
	}
}

// RemovedTaskResumes returns the removed IDs of the "task_resumes" edge to the ScreeningTaskResume entity.
func (m *ScreeningTaskMutation) RemovedTaskResumesIDs() (ids []uuid.UUID) {
	for id := range m.removedtask_resumes {
		ids = append(ids, id)
	}
	return
}

// TaskResumesIDs returns the "task_resumes" edge IDs in the mutation.
func (m *ScreeningTaskMutation) TaskResumesIDs() (ids []uuid.UUID) {
	for id := range m.task_resumes {
		ids = append(ids, id)
	}
	return
}

// ResetTaskResumes resets all changes to the "task_resumes" edge.
func (m *ScreeningTaskMutation) ResetTaskResumes() {
	m.task_resumes = nil
	m.clearedtask_resumes = false
	m.removedtask_resumes = nil
}

// AddResultIDs adds the "results" edge to the ScreeningResult entity by ids.
func (m *ScreeningTaskMutation) AddResultIDs(ids ...uuid.UUID) {
	if m.results == nil {
		m.results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.results[ids[i]] = struct{}{}
	}
}

// ClearResults clears the "results" edge to the ScreeningResult entity.
func (m *ScreeningTaskMutation) ClearResults() {
	m.clearedresults = true
}

// ResultsCleared reports if the "results" edge to the ScreeningResult entity was cleared.
func (m *ScreeningTaskMutation) ResultsCleared() bool {
	return m.clearedresults
}

// RemoveResultIDs removes the "results" edge to the ScreeningResult entity by IDs.
func (m *ScreeningTaskMutation) RemoveResultIDs(ids ...uuid.UUID) {
	if m.removedresults == nil {
		m.removedresults = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.results, ids[i])
		m.removedresults[ids[i]] = struct{}{}
	}
}

// RemovedResults returns the removed IDs of the "results" edge to the ScreeningResult entity.
func (m *ScreeningTaskMutation) RemovedResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedresults {
		ids = append(ids, id)
	}
	return
}

// ResultsIDs returns the "results" edge IDs in the mutation.
func (m *ScreeningTaskMutation) ResultsIDs() (ids []uuid.UUID) {
	for id := range m.results {
		ids = append(ids, id)
	}
	return
}

// ResetResults resets all changes to the "results" edge.
func (m *ScreeningTaskMutation) ResetResults() {
	m.results = nil
	m.clearedresults = false
	m.removedresults = nil
}

// AddRunMetricIDs adds the "run_metrics" edge to the ScreeningRunMetric entity by ids.
func (m *ScreeningTaskMutation) AddRunMetricIDs(ids ...uuid.UUID) {
	if m.run_metrics == nil {
		m.run_metrics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.run_metrics[ids[i]] = struct{}{}
	}
}

// ClearRunMetrics clears the "run_metrics" edge to the ScreeningRunMetric entity.
func (m *ScreeningTaskMutation) ClearRunMetrics() {
	m.clearedrun_metrics = true
}

// RunMetricsCleared reports if the "run_metrics" edge to the ScreeningRunMetric entity was cleared.
func (m *ScreeningTaskMutation) RunMetricsCleared() bool {
	return m.clearedrun_metrics
}

// RemoveRunMetricIDs removes the "run_metrics" edge to the ScreeningRunMetric entity by IDs.
func (m *ScreeningTaskMutation) RemoveRunMetricIDs(ids ...uuid.UUID) {
	if m.removedrun_metrics == nil {
		m.removedrun_metrics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.run_metrics, ids[i])
		m.removedrun_metrics[ids[i]] = struct{}{}
	}
}

// RemovedRunMetrics returns the removed IDs of the "run_metrics" edge to the ScreeningRunMetric entity.
func (m *ScreeningTaskMutation) RemovedRunMetricsIDs() (ids []uuid.UUID) {
	for id := range m.removedrun_metrics {
		ids = append(ids, id)
	}
	return
}

// RunMetricsIDs returns the "run_metrics" edge IDs in the mutation.
func (m *ScreeningTaskMutation) RunMetricsIDs() (ids []uuid.UUID) {
	for id := range m.run_metrics {
		ids = append(ids, id)
	}
	return
}

// ResetRunMetrics resets all changes to the "run_metrics" edge.
func (m *ScreeningTaskMutation) ResetRunMetrics() {
	m.run_metrics = nil
	m.clearedrun_metrics = false
	m.removedrun_metrics = nil
}

// AddNodeRunIDs adds the "node_runs" edge to the ScreeningNodeRun entity by ids.
func (m *ScreeningTaskMutation) AddNodeRunIDs(ids ...uuid.UUID) {
	if m.node_runs == nil {
		m.node_runs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.node_runs[ids[i]] = struct{}{}
	}
}

// ClearNodeRuns clears the "node_runs" edge to the ScreeningNodeRun entity.
func (m *ScreeningTaskMutation) ClearNodeRuns() {
	m.clearednode_runs = true
}

// NodeRunsCleared reports if the "node_runs" edge to the ScreeningNodeRun entity was cleared.
func (m *ScreeningTaskMutation) NodeRunsCleared() bool {
	return m.clearednode_runs
}

// RemoveNodeRunIDs removes the "node_runs" edge to the ScreeningNodeRun entity by IDs.
func (m *ScreeningTaskMutation) RemoveNodeRunIDs(ids ...uuid.UUID) {
	if m.removednode_runs == nil {
		m.removednode_runs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.node_runs, ids[i])
		m.removednode_runs[ids[i]] = struct{}{}
	}
}

// RemovedNodeRuns returns the removed IDs of the "node_runs" edge to the ScreeningNodeRun entity.
func (m *ScreeningTaskMutation) RemovedNodeRunsIDs() (ids []uuid.UUID) {
	for id := range m.removednode_runs {
		ids = append(ids, id)
	}
	return
}

// NodeRunsIDs returns the "node_runs" edge IDs in the mutation.
func (m *ScreeningTaskMutation) NodeRunsIDs() (ids []uuid.UUID) {
	for id := range m.node_runs {
		ids = append(ids, id)
	}
	return
}

// ResetNodeRuns resets all changes to the "node_runs" edge.
func (m *ScreeningTaskMutation) ResetNodeRuns() {
	m.node_runs = nil
	m.clearednode_runs = false
	m.removednode_runs = nil
}

// Where appends a list predicates to the ScreeningTaskMutation builder.
func (m *ScreeningTaskMutation) Where(ps ...predicate.ScreeningTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScreeningTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScreeningTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScreeningTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScreeningTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScreeningTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScreeningTask).
func (m *ScreeningTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScreeningTaskMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.deleted_at != nil {
		fields = append(fields, screeningtask.FieldDeletedAt)
	}
	if m.job_position != nil {
		fields = append(fields, screeningtask.FieldJobPositionID)
	}
	if m.creator != nil {
		fields = append(fields, screeningtask.FieldCreatedBy)
	}
	if m.status != nil {
		fields = append(fields, screeningtask.FieldStatus)
	}
	if m.dimension_weights != nil {
		fields = append(fields, screeningtask.FieldDimensionWeights)
	}
	if m.llm_config != nil {
		fields = append(fields, screeningtask.FieldLlmConfig)
	}
	if m.notes != nil {
		fields = append(fields, screeningtask.FieldNotes)
	}
	if m.resume_total != nil {
		fields = append(fields, screeningtask.FieldResumeTotal)
	}
	if m.resume_processed != nil {
		fields = append(fields, screeningtask.FieldResumeProcessed)
	}
	if m.resume_succeeded != nil {
		fields = append(fields, screeningtask.FieldResumeSucceeded)
	}
	if m.resume_failed != nil {
		fields = append(fields, screeningtask.FieldResumeFailed)
	}
	if m.agent_version != nil {
		fields = append(fields, screeningtask.FieldAgentVersion)
	}
	if m.started_at != nil {
		fields = append(fields, screeningtask.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, screeningtask.FieldFinishedAt)
	}
	if m.created_at != nil {
		fields = append(fields, screeningtask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, screeningtask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScreeningTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case screeningtask.FieldDeletedAt:
		return m.DeletedAt()
	case screeningtask.FieldJobPositionID:
		return m.JobPositionID()
	case screeningtask.FieldCreatedBy:
		return m.CreatedBy()
	case screeningtask.FieldStatus:
		return m.Status()
	case screeningtask.FieldDimensionWeights:
		return m.DimensionWeights()
	case screeningtask.FieldLlmConfig:
		return m.LlmConfig()
	case screeningtask.FieldNotes:
		return m.Notes()
	case screeningtask.FieldResumeTotal:
		return m.ResumeTotal()
	case screeningtask.FieldResumeProcessed:
		return m.ResumeProcessed()
	case screeningtask.FieldResumeSucceeded:
		return m.ResumeSucceeded()
	case screeningtask.FieldResumeFailed:
		return m.ResumeFailed()
	case screeningtask.FieldAgentVersion:
		return m.AgentVersion()
	case screeningtask.FieldStartedAt:
		return m.StartedAt()
	case screeningtask.FieldFinishedAt:
		return m.FinishedAt()
	case screeningtask.FieldCreatedAt:
		return m.CreatedAt()
	case screeningtask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScreeningTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case screeningtask.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case screeningtask.FieldJobPositionID:
		return m.OldJobPositionID(ctx)
	case screeningtask.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case screeningtask.FieldStatus:
		return m.OldStatus(ctx)
	case screeningtask.FieldDimensionWeights:
		return m.OldDimensionWeights(ctx)
	case screeningtask.FieldLlmConfig:
		return m.OldLlmConfig(ctx)
	case screeningtask.FieldNotes:
		return m.OldNotes(ctx)
	case screeningtask.FieldResumeTotal:
		return m.OldResumeTotal(ctx)
	case screeningtask.FieldResumeProcessed:
		return m.OldResumeProcessed(ctx)
	case screeningtask.FieldResumeSucceeded:
		return m.OldResumeSucceeded(ctx)
	case screeningtask.FieldResumeFailed:
		return m.OldResumeFailed(ctx)
	case screeningtask.FieldAgentVersion:
		return m.OldAgentVersion(ctx)
	case screeningtask.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case screeningtask.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case screeningtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case screeningtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ScreeningTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case screeningtask.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case screeningtask.FieldJobPositionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobPositionID(v)
		return nil
	case screeningtask.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case screeningtask.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case screeningtask.FieldDimensionWeights:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensionWeights(v)
		return nil
	case screeningtask.FieldLlmConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLlmConfig(v)
		return nil
	case screeningtask.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case screeningtask.FieldResumeTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeTotal(v)
		return nil
	case screeningtask.FieldResumeProcessed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeProcessed(v)
		return nil
	case screeningtask.FieldResumeSucceeded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeSucceeded(v)
		return nil
	case screeningtask.FieldResumeFailed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeFailed(v)
		return nil
	case screeningtask.FieldAgentVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentVersion(v)
		return nil
	case screeningtask.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case screeningtask.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case screeningtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case screeningtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScreeningTaskMutation) AddedFields() []string {
	var fields []string
	if m.addresume_total != nil {
		fields = append(fields, screeningtask.FieldResumeTotal)
	}
	if m.addresume_processed != nil {
		fields = append(fields, screeningtask.FieldResumeProcessed)
	}
	if m.addresume_succeeded != nil {
		fields = append(fields, screeningtask.FieldResumeSucceeded)
	}
	if m.addresume_failed != nil {
		fields = append(fields, screeningtask.FieldResumeFailed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScreeningTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case screeningtask.FieldResumeTotal:
		return m.AddedResumeTotal()
	case screeningtask.FieldResumeProcessed:
		return m.AddedResumeProcessed()
	case screeningtask.FieldResumeSucceeded:
		return m.AddedResumeSucceeded()
	case screeningtask.FieldResumeFailed:
		return m.AddedResumeFailed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case screeningtask.FieldResumeTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResumeTotal(v)
		return nil
	case screeningtask.FieldResumeProcessed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResumeProcessed(v)
		return nil
	case screeningtask.FieldResumeSucceeded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResumeSucceeded(v)
		return nil
	case screeningtask.FieldResumeFailed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResumeFailed(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScreeningTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(screeningtask.FieldDeletedAt) {
		fields = append(fields, screeningtask.FieldDeletedAt)
	}
	if m.FieldCleared(screeningtask.FieldDimensionWeights) {
		fields = append(fields, screeningtask.FieldDimensionWeights)
	}
	if m.FieldCleared(screeningtask.FieldLlmConfig) {
		fields = append(fields, screeningtask.FieldLlmConfig)
	}
	if m.FieldCleared(screeningtask.FieldNotes) {
		fields = append(fields, screeningtask.FieldNotes)
	}
	if m.FieldCleared(screeningtask.FieldAgentVersion) {
		fields = append(fields, screeningtask.FieldAgentVersion)
	}
	if m.FieldCleared(screeningtask.FieldStartedAt) {
		fields = append(fields, screeningtask.FieldStartedAt)
	}
	if m.FieldCleared(screeningtask.FieldFinishedAt) {
		fields = append(fields, screeningtask.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScreeningTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScreeningTaskMutation) ClearField(name string) error {
	switch name {
	case screeningtask.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case screeningtask.FieldDimensionWeights:
		m.ClearDimensionWeights()
		return nil
	case screeningtask.FieldLlmConfig:
		m.ClearLlmConfig()
		return nil
	case screeningtask.FieldNotes:
		m.ClearNotes()
		return nil
	case screeningtask.FieldAgentVersion:
		m.ClearAgentVersion()
		return nil
	case screeningtask.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case screeningtask.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ScreeningTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScreeningTaskMutation) ResetField(name string) error {
	switch name {
	case screeningtask.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case screeningtask.FieldJobPositionID:
		m.ResetJobPositionID()
		return nil
	case screeningtask.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case screeningtask.FieldStatus:
		m.ResetStatus()
		return nil
	case screeningtask.FieldDimensionWeights:
		m.ResetDimensionWeights()
		return nil
	case screeningtask.FieldLlmConfig:
		m.ResetLlmConfig()
		return nil
	case screeningtask.FieldNotes:
		m.ResetNotes()
		return nil
	case screeningtask.FieldResumeTotal:
		m.ResetResumeTotal()
		return nil
	case screeningtask.FieldResumeProcessed:
		m.ResetResumeProcessed()
		return nil
	case screeningtask.FieldResumeSucceeded:
		m.ResetResumeSucceeded()
		return nil
	case screeningtask.FieldResumeFailed:
		m.ResetResumeFailed()
		return nil
	case screeningtask.FieldAgentVersion:
		m.ResetAgentVersion()
		return nil
	case screeningtask.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case screeningtask.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case screeningtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case screeningtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ScreeningTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScreeningTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.job_position != nil {
		edges = append(edges, screeningtask.EdgeJobPosition)
	}
	if m.creator != nil {
		edges = append(edges, screeningtask.EdgeCreator)
	}
	if m.task_resumes != nil {
		edges = append(edges, screeningtask.EdgeTaskResumes)
	}
	if m.results != nil {
		edges = append(edges, screeningtask.EdgeResults)
	}
	if m.run_metrics != nil {
		edges = append(edges, screeningtask.EdgeRunMetrics)
	}
	if m.node_runs != nil {
		edges = append(edges, screeningtask.EdgeNodeRuns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScreeningTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case screeningtask.EdgeJobPosition:
		if id := m.job_position; id != nil {
			return []ent.Value{*id}
		}
	case screeningtask.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case screeningtask.EdgeTaskResumes:
		ids := make([]ent.Value, 0, len(m.task_resumes))
		for id := range m.task_resumes {
			ids = append(ids, id)
		}
		return ids
	case screeningtask.EdgeResults:
		ids := make([]ent.Value, 0, len(m.results))
		for id := range m.results {
			ids = append(ids, id)
		}
		return ids
	case screeningtask.EdgeRunMetrics:
		ids := make([]ent.Value, 0, len(m.run_metrics))
		for id := range m.run_metrics {
			ids = append(ids, id)
		}
		return ids
	case screeningtask.EdgeNodeRuns:
		ids := make([]ent.Value, 0, len(m.node_runs))
		for id := range m.node_runs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScreeningTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtask_resumes != nil {
		edges = append(edges, screeningtask.EdgeTaskResumes)
	}
	if m.removedresults != nil {
		edges = append(edges, screeningtask.EdgeResults)
	}
	if m.removedrun_metrics != nil {
		edges = append(edges, screeningtask.EdgeRunMetrics)
	}
	if m.removednode_runs != nil {
		edges = append(edges, screeningtask.EdgeNodeRuns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScreeningTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case screeningtask.EdgeTaskResumes:
		ids := make([]ent.Value, 0, len(m.removedtask_resumes))
		for id := range m.removedtask_resumes {
			ids = append(ids, id)
		}
		return ids
	case screeningtask.EdgeResults:
		ids := make([]ent.Value, 0, len(m.removedresults))
		for id := range m.removedresults {
			ids = append(ids, id)
		}
		return ids
	case screeningtask.EdgeRunMetrics:
		ids := make([]ent.Value, 0, len(m.removedrun_metrics))
		for id := range m.removedrun_metrics {
			ids = append(ids, id)
		}
		return ids
	case screeningtask.EdgeNodeRuns:
		ids := make([]ent.Value, 0, len(m.removednode_runs))
		for id := range m.removednode_runs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScreeningTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedjob_position {
		edges = append(edges, screeningtask.EdgeJobPosition)
	}
	if m.clearedcreator {
		edges = append(edges, screeningtask.EdgeCreator)
	}
	if m.clearedtask_resumes {
		edges = append(edges, screeningtask.EdgeTaskResumes)
	}
	if m.clearedresults {
		edges = append(edges, screeningtask.EdgeResults)
	}
	if m.clearedrun_metrics {
		edges = append(edges, screeningtask.EdgeRunMetrics)
	}
	if m.clearednode_runs {
		edges = append(edges, screeningtask.EdgeNodeRuns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScreeningTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case screeningtask.EdgeJobPosition:
		return m.clearedjob_position
	case screeningtask.EdgeCreator:
		return m.clearedcreator
	case screeningtask.EdgeTaskResumes:
		return m.clearedtask_resumes
	case screeningtask.EdgeResults:
		return m.clearedresults
	case screeningtask.EdgeRunMetrics:
		return m.clearedrun_metrics
	case screeningtask.EdgeNodeRuns:
		return m.clearednode_runs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScreeningTaskMutation) ClearEdge(name string) error {
	switch name {
	case screeningtask.EdgeJobPosition:
		m.ClearJobPosition()
		return nil
	case screeningtask.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown ScreeningTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScreeningTaskMutation) ResetEdge(name string) error {
	switch name {
	case screeningtask.EdgeJobPosition:
		m.ResetJobPosition()
		return nil
	case screeningtask.EdgeCreator:
		m.ResetCreator()
		return nil
	case screeningtask.EdgeTaskResumes:
		m.ResetTaskResumes()
		return nil
	case screeningtask.EdgeResults:
		m.ResetResults()
		return nil
	case screeningtask.EdgeRunMetrics:
		m.ResetRunMetrics()
		return nil
	case screeningtask.EdgeNodeRuns:
		m.ResetNodeRuns()
		return nil
	}
	return fmt.Errorf("unknown ScreeningTask edge %s", name)
}

// ScreeningTaskResumeMutation represents an operation that mutates the ScreeningTaskResume nodes in the graph.
type ScreeningTaskResumeMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	deleted_at       *time.Time
	status           *string
	error_message    *string
	ranking          *int
	addranking       *int
	score            *float64
	addscore         *float64
	processed_at     *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	task             *uuid.UUID
	clearedtask      bool
	resume           *uuid.UUID
	clearedresume    bool
	node_runs        map[uuid.UUID]struct{}
	removednode_runs map[uuid.UUID]struct{}
	clearednode_runs bool
	done             bool
	oldValue         func(context.Context) (*ScreeningTaskResume, error)
	predicates       []predicate.ScreeningTaskResume
}

var _ ent.Mutation = (*ScreeningTaskResumeMutation)(nil)

// screeningtaskresumeOption allows management of the mutation configuration using functional options.
type screeningtaskresumeOption func(*ScreeningTaskResumeMutation)

// newScreeningTaskResumeMutation creates new mutation for the ScreeningTaskResume entity.
func newScreeningTaskResumeMutation(c config, op Op, opts ...screeningtaskresumeOption) *ScreeningTaskResumeMutation {
	m := &ScreeningTaskResumeMutation{
		config:        c,
		op:            op,
		typ:           TypeScreeningTaskResume,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScreeningTaskResumeID sets the ID field of the mutation.
func withScreeningTaskResumeID(id uuid.UUID) screeningtaskresumeOption {
	return func(m *ScreeningTaskResumeMutation) {
		var (
			err   error
			once  sync.Once
			value *ScreeningTaskResume
		)
		m.oldValue = func(ctx context.Context) (*ScreeningTaskResume, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScreeningTaskResume.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScreeningTaskResume sets the old ScreeningTaskResume of the mutation.
func withScreeningTaskResume(node *ScreeningTaskResume) screeningtaskresumeOption {
	return func(m *ScreeningTaskResumeMutation) {
		m.oldValue = func(context.Context) (*ScreeningTaskResume, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScreeningTaskResumeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScreeningTaskResumeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScreeningTaskResume entities.
func (m *ScreeningTaskResumeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScreeningTaskResumeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScreeningTaskResumeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScreeningTaskResume.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScreeningTaskResumeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScreeningTaskResumeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ScreeningTaskResumeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[screeningtaskresume.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ScreeningTaskResumeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[screeningtaskresume.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScreeningTaskResumeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, screeningtaskresume.FieldDeletedAt)
}

// SetTaskID sets the "task_id" field.
func (m *ScreeningTaskResumeMutation) SetTaskID(u uuid.UUID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ScreeningTaskResumeMutation) TaskID() (r uuid.UUID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ScreeningTaskResumeMutation) ResetTaskID() {
	m.task = nil
}

// SetResumeID sets the "resume_id" field.
func (m *ScreeningTaskResumeMutation) SetResumeID(u uuid.UUID) {
	m.resume = &u
}

// ResumeID returns the value of the "resume_id" field in the mutation.
func (m *ScreeningTaskResumeMutation) ResumeID() (r uuid.UUID, exists bool) {
	v := m.resume
	if v == nil {
		return
	}
	return *v, true
}

// OldResumeID returns the old "resume_id" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldResumeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResumeID: %w", err)
	}
	return oldValue.ResumeID, nil
}

// ResetResumeID resets all changes to the "resume_id" field.
func (m *ScreeningTaskResumeMutation) ResetResumeID() {
	m.resume = nil
}

// SetStatus sets the "status" field.
func (m *ScreeningTaskResumeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ScreeningTaskResumeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ScreeningTaskResumeMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *ScreeningTaskResumeMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ScreeningTaskResumeMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ScreeningTaskResumeMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[screeningtaskresume.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ScreeningTaskResumeMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[screeningtaskresume.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ScreeningTaskResumeMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, screeningtaskresume.FieldErrorMessage)
}

// SetRanking sets the "ranking" field.
func (m *ScreeningTaskResumeMutation) SetRanking(i int) {
	m.ranking = &i
	m.addranking = nil
}

// Ranking returns the value of the "ranking" field in the mutation.
func (m *ScreeningTaskResumeMutation) Ranking() (r int, exists bool) {
	v := m.ranking
	if v == nil {
		return
	}
	return *v, true
}

// OldRanking returns the old "ranking" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldRanking(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRanking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRanking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRanking: %w", err)
	}
	return oldValue.Ranking, nil
}

// AddRanking adds i to the "ranking" field.
func (m *ScreeningTaskResumeMutation) AddRanking(i int) {
	if m.addranking != nil {
		*m.addranking += i
	} else {
		m.addranking = &i
	}
}

// AddedRanking returns the value that was added to the "ranking" field in this mutation.
func (m *ScreeningTaskResumeMutation) AddedRanking() (r int, exists bool) {
	v := m.addranking
	if v == nil {
		return
	}
	return *v, true
}

// ClearRanking clears the value of the "ranking" field.
func (m *ScreeningTaskResumeMutation) ClearRanking() {
	m.ranking = nil
	m.addranking = nil
	m.clearedFields[screeningtaskresume.FieldRanking] = struct{}{}
}

// RankingCleared returns if the "ranking" field was cleared in this mutation.
func (m *ScreeningTaskResumeMutation) RankingCleared() bool {
	_, ok := m.clearedFields[screeningtaskresume.FieldRanking]
	return ok
}

// ResetRanking resets all changes to the "ranking" field.
func (m *ScreeningTaskResumeMutation) ResetRanking() {
	m.ranking = nil
	m.addranking = nil
	delete(m.clearedFields, screeningtaskresume.FieldRanking)
}

// SetScore sets the "score" field.
func (m *ScreeningTaskResumeMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *ScreeningTaskResumeMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *ScreeningTaskResumeMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *ScreeningTaskResumeMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ClearScore clears the value of the "score" field.
func (m *ScreeningTaskResumeMutation) ClearScore() {
	m.score = nil
	m.addscore = nil
	m.clearedFields[screeningtaskresume.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *ScreeningTaskResumeMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[screeningtaskresume.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *ScreeningTaskResumeMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
	delete(m.clearedFields, screeningtaskresume.FieldScore)
}

// SetProcessedAt sets the "processed_at" field.
func (m *ScreeningTaskResumeMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *ScreeningTaskResumeMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldProcessedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *ScreeningTaskResumeMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[screeningtaskresume.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *ScreeningTaskResumeMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[screeningtaskresume.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *ScreeningTaskResumeMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, screeningtaskresume.FieldProcessedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ScreeningTaskResumeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScreeningTaskResumeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScreeningTaskResumeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScreeningTaskResumeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScreeningTaskResumeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScreeningTaskResume entity.
// If the ScreeningTaskResume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScreeningTaskResumeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScreeningTaskResumeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the ScreeningTask entity.
func (m *ScreeningTaskResumeMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[screeningtaskresume.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the ScreeningTask entity was cleared.
func (m *ScreeningTaskResumeMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ScreeningTaskResumeMutation) TaskIDs() (ids []uuid.UUID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *ScreeningTaskResumeMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearResume clears the "resume" edge to the Resume entity.
func (m *ScreeningTaskResumeMutation) ClearResume() {
	m.clearedresume = true
	m.clearedFields[screeningtaskresume.FieldResumeID] = struct{}{}
}

// ResumeCleared reports if the "resume" edge to the Resume entity was cleared.
func (m *ScreeningTaskResumeMutation) ResumeCleared() bool {
	return m.clearedresume
}

// ResumeIDs returns the "resume" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResumeID instead. It exists only for internal usage by the builders.
func (m *ScreeningTaskResumeMutation) ResumeIDs() (ids []uuid.UUID) {
	if id := m.resume; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResume resets all changes to the "resume" edge.
func (m *ScreeningTaskResumeMutation) ResetResume() {
	m.resume = nil
	m.clearedresume = false
}

// AddNodeRunIDs adds the "node_runs" edge to the ScreeningNodeRun entity by ids.
func (m *ScreeningTaskResumeMutation) AddNodeRunIDs(ids ...uuid.UUID) {
	if m.node_runs == nil {
		m.node_runs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.node_runs[ids[i]] = struct{}{}
	}
}

// ClearNodeRuns clears the "node_runs" edge to the ScreeningNodeRun entity.
func (m *ScreeningTaskResumeMutation) ClearNodeRuns() {
	m.clearednode_runs = true
}

// NodeRunsCleared reports if the "node_runs" edge to the ScreeningNodeRun entity was cleared.
func (m *ScreeningTaskResumeMutation) NodeRunsCleared() bool {
	return m.clearednode_runs
}

// RemoveNodeRunIDs removes the "node_runs" edge to the ScreeningNodeRun entity by IDs.
func (m *ScreeningTaskResumeMutation) RemoveNodeRunIDs(ids ...uuid.UUID) {
	if m.removednode_runs == nil {
		m.removednode_runs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.node_runs, ids[i])
		m.removednode_runs[ids[i]] = struct{}{}
	}
}

// RemovedNodeRuns returns the removed IDs of the "node_runs" edge to the ScreeningNodeRun entity.
func (m *ScreeningTaskResumeMutation) RemovedNodeRunsIDs() (ids []uuid.UUID) {
	for id := range m.removednode_runs {
		ids = append(ids, id)
	}
	return
}

// NodeRunsIDs returns the "node_runs" edge IDs in the mutation.
func (m *ScreeningTaskResumeMutation) NodeRunsIDs() (ids []uuid.UUID) {
	for id := range m.node_runs {
		ids = append(ids, id)
	}
	return
}

// ResetNodeRuns resets all changes to the "node_runs" edge.
func (m *ScreeningTaskResumeMutation) ResetNodeRuns() {
	m.node_runs = nil
	m.clearednode_runs = false
	m.removednode_runs = nil
}

// Where appends a list predicates to the ScreeningTaskResumeMutation builder.
func (m *ScreeningTaskResumeMutation) Where(ps ...predicate.ScreeningTaskResume) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScreeningTaskResumeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScreeningTaskResumeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScreeningTaskResume, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScreeningTaskResumeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScreeningTaskResumeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScreeningTaskResume).
func (m *ScreeningTaskResumeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScreeningTaskResumeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.deleted_at != nil {
		fields = append(fields, screeningtaskresume.FieldDeletedAt)
	}
	if m.task != nil {
		fields = append(fields, screeningtaskresume.FieldTaskID)
	}
	if m.resume != nil {
		fields = append(fields, screeningtaskresume.FieldResumeID)
	}
	if m.status != nil {
		fields = append(fields, screeningtaskresume.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, screeningtaskresume.FieldErrorMessage)
	}
	if m.ranking != nil {
		fields = append(fields, screeningtaskresume.FieldRanking)
	}
	if m.score != nil {
		fields = append(fields, screeningtaskresume.FieldScore)
	}
	if m.processed_at != nil {
		fields = append(fields, screeningtaskresume.FieldProcessedAt)
	}
	if m.created_at != nil {
		fields = append(fields, screeningtaskresume.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, screeningtaskresume.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScreeningTaskResumeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case screeningtaskresume.FieldDeletedAt:
		return m.DeletedAt()
	case screeningtaskresume.FieldTaskID:
		return m.TaskID()
	case screeningtaskresume.FieldResumeID:
		return m.ResumeID()
	case screeningtaskresume.FieldStatus:
		return m.Status()
	case screeningtaskresume.FieldErrorMessage:
		return m.ErrorMessage()
	case screeningtaskresume.FieldRanking:
		return m.Ranking()
	case screeningtaskresume.FieldScore:
		return m.Score()
	case screeningtaskresume.FieldProcessedAt:
		return m.ProcessedAt()
	case screeningtaskresume.FieldCreatedAt:
		return m.CreatedAt()
	case screeningtaskresume.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScreeningTaskResumeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case screeningtaskresume.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case screeningtaskresume.FieldTaskID:
		return m.OldTaskID(ctx)
	case screeningtaskresume.FieldResumeID:
		return m.OldResumeID(ctx)
	case screeningtaskresume.FieldStatus:
		return m.OldStatus(ctx)
	case screeningtaskresume.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case screeningtaskresume.FieldRanking:
		return m.OldRanking(ctx)
	case screeningtaskresume.FieldScore:
		return m.OldScore(ctx)
	case screeningtaskresume.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	case screeningtaskresume.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case screeningtaskresume.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ScreeningTaskResume field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningTaskResumeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case screeningtaskresume.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case screeningtaskresume.FieldTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case screeningtaskresume.FieldResumeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResumeID(v)
		return nil
	case screeningtaskresume.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case screeningtaskresume.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case screeningtaskresume.FieldRanking:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRanking(v)
		return nil
	case screeningtaskresume.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case screeningtaskresume.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	case screeningtaskresume.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case screeningtaskresume.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningTaskResume field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScreeningTaskResumeMutation) AddedFields() []string {
	var fields []string
	if m.addranking != nil {
		fields = append(fields, screeningtaskresume.FieldRanking)
	}
	if m.addscore != nil {
		fields = append(fields, screeningtaskresume.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScreeningTaskResumeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case screeningtaskresume.FieldRanking:
		return m.AddedRanking()
	case screeningtaskresume.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScreeningTaskResumeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case screeningtaskresume.FieldRanking:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRanking(v)
		return nil
	case screeningtaskresume.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown ScreeningTaskResume numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScreeningTaskResumeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(screeningtaskresume.FieldDeletedAt) {
		fields = append(fields, screeningtaskresume.FieldDeletedAt)
	}
	if m.FieldCleared(screeningtaskresume.FieldErrorMessage) {
		fields = append(fields, screeningtaskresume.FieldErrorMessage)
	}
	if m.FieldCleared(screeningtaskresume.FieldRanking) {
		fields = append(fields, screeningtaskresume.FieldRanking)
	}
	if m.FieldCleared(screeningtaskresume.FieldScore) {
		fields = append(fields, screeningtaskresume.FieldScore)
	}
	if m.FieldCleared(screeningtaskresume.FieldProcessedAt) {
		fields = append(fields, screeningtaskresume.FieldProcessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScreeningTaskResumeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScreeningTaskResumeMutation) ClearField(name string) error {
	switch name {
	case screeningtaskresume.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case screeningtaskresume.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case screeningtaskresume.FieldRanking:
		m.ClearRanking()
		return nil
	case screeningtaskresume.FieldScore:
		m.ClearScore()
		return nil
	case screeningtaskresume.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown ScreeningTaskResume nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScreeningTaskResumeMutation) ResetField(name string) error {
	switch name {
	case screeningtaskresume.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case screeningtaskresume.FieldTaskID:
		m.ResetTaskID()
		return nil
	case screeningtaskresume.FieldResumeID:
		m.ResetResumeID()
		return nil
	case screeningtaskresume.FieldStatus:
		m.ResetStatus()
		return nil
	case screeningtaskresume.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case screeningtaskresume.FieldRanking:
		m.ResetRanking()
		return nil
	case screeningtaskresume.FieldScore:
		m.ResetScore()
		return nil
	case screeningtaskresume.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	case screeningtaskresume.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case screeningtaskresume.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ScreeningTaskResume field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScreeningTaskResumeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.task != nil {
		edges = append(edges, screeningtaskresume.EdgeTask)
	}
	if m.resume != nil {
		edges = append(edges, screeningtaskresume.EdgeResume)
	}
	if m.node_runs != nil {
		edges = append(edges, screeningtaskresume.EdgeNodeRuns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScreeningTaskResumeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case screeningtaskresume.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case screeningtaskresume.EdgeResume:
		if id := m.resume; id != nil {
			return []ent.Value{*id}
		}
	case screeningtaskresume.EdgeNodeRuns:
		ids := make([]ent.Value, 0, len(m.node_runs))
		for id := range m.node_runs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScreeningTaskResumeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednode_runs != nil {
		edges = append(edges, screeningtaskresume.EdgeNodeRuns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScreeningTaskResumeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case screeningtaskresume.EdgeNodeRuns:
		ids := make([]ent.Value, 0, len(m.removednode_runs))
		for id := range m.removednode_runs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScreeningTaskResumeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtask {
		edges = append(edges, screeningtaskresume.EdgeTask)
	}
	if m.clearedresume {
		edges = append(edges, screeningtaskresume.EdgeResume)
	}
	if m.clearednode_runs {
		edges = append(edges, screeningtaskresume.EdgeNodeRuns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScreeningTaskResumeMutation) EdgeCleared(name string) bool {
	switch name {
	case screeningtaskresume.EdgeTask:
		return m.clearedtask
	case screeningtaskresume.EdgeResume:
		return m.clearedresume
	case screeningtaskresume.EdgeNodeRuns:
		return m.clearednode_runs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScreeningTaskResumeMutation) ClearEdge(name string) error {
	switch name {
	case screeningtaskresume.EdgeTask:
		m.ClearTask()
		return nil
	case screeningtaskresume.EdgeResume:
		m.ClearResume()
		return nil
	}
	return fmt.Errorf("unknown ScreeningTaskResume unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScreeningTaskResumeMutation) ResetEdge(name string) error {
	switch name {
	case screeningtaskresume.EdgeTask:
		m.ResetTask()
		return nil
	case screeningtaskresume.EdgeResume:
		m.ResetResume()
		return nil
	case screeningtaskresume.EdgeNodeRuns:
		m.ResetNodeRuns()
		return nil
	}
	return fmt.Errorf("unknown ScreeningTaskResume edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	enable_sso             *bool
	force_two_factor_auth  *bool
	disable_password_login *bool
	enable_auto_login      *bool
	dingtalk_oauth         **types.DingtalkOAuth
	custom_oauth           **types.CustomOAuth
	base_url               *string
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*Setting, error)
	predicates             []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uuid.UUID) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnableSSO sets the "enable_sso" field.
func (m *SettingMutation) SetEnableSSO(b bool) {
	m.enable_sso = &b
}

// EnableSSO returns the value of the "enable_sso" field in the mutation.
func (m *SettingMutation) EnableSSO() (r bool, exists bool) {
	v := m.enable_sso
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableSSO returns the old "enable_sso" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldEnableSSO(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableSSO is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableSSO requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableSSO: %w", err)
	}
	return oldValue.EnableSSO, nil
}

// ResetEnableSSO resets all changes to the "enable_sso" field.
func (m *SettingMutation) ResetEnableSSO() {
	m.enable_sso = nil
}

// SetForceTwoFactorAuth sets the "force_two_factor_auth" field.
func (m *SettingMutation) SetForceTwoFactorAuth(b bool) {
	m.force_two_factor_auth = &b
}

// ForceTwoFactorAuth returns the value of the "force_two_factor_auth" field in the mutation.
func (m *SettingMutation) ForceTwoFactorAuth() (r bool, exists bool) {
	v := m.force_two_factor_auth
	if v == nil {
		return
	}
	return *v, true
}

// OldForceTwoFactorAuth returns the old "force_two_factor_auth" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldForceTwoFactorAuth(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForceTwoFactorAuth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForceTwoFactorAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForceTwoFactorAuth: %w", err)
	}
	return oldValue.ForceTwoFactorAuth, nil
}

// ResetForceTwoFactorAuth resets all changes to the "force_two_factor_auth" field.
func (m *SettingMutation) ResetForceTwoFactorAuth() {
	m.force_two_factor_auth = nil
}

// SetDisablePasswordLogin sets the "disable_password_login" field.
func (m *SettingMutation) SetDisablePasswordLogin(b bool) {
	m.disable_password_login = &b
}

// DisablePasswordLogin returns the value of the "disable_password_login" field in the mutation.
func (m *SettingMutation) DisablePasswordLogin() (r bool, exists bool) {
	v := m.disable_password_login
	if v == nil {
		return
	}
	return *v, true
}

// OldDisablePasswordLogin returns the old "disable_password_login" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDisablePasswordLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisablePasswordLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisablePasswordLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisablePasswordLogin: %w", err)
	}
	return oldValue.DisablePasswordLogin, nil
}

// ResetDisablePasswordLogin resets all changes to the "disable_password_login" field.
func (m *SettingMutation) ResetDisablePasswordLogin() {
	m.disable_password_login = nil
}

// SetEnableAutoLogin sets the "enable_auto_login" field.
func (m *SettingMutation) SetEnableAutoLogin(b bool) {
	m.enable_auto_login = &b
}

// EnableAutoLogin returns the value of the "enable_auto_login" field in the mutation.
func (m *SettingMutation) EnableAutoLogin() (r bool, exists bool) {
	v := m.enable_auto_login
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableAutoLogin returns the old "enable_auto_login" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldEnableAutoLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableAutoLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableAutoLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableAutoLogin: %w", err)
	}
	return oldValue.EnableAutoLogin, nil
}

// ResetEnableAutoLogin resets all changes to the "enable_auto_login" field.
func (m *SettingMutation) ResetEnableAutoLogin() {
	m.enable_auto_login = nil
}

// SetDingtalkOauth sets the "dingtalk_oauth" field.
func (m *SettingMutation) SetDingtalkOauth(to *types.DingtalkOAuth) {
	m.dingtalk_oauth = &to
}

// DingtalkOauth returns the value of the "dingtalk_oauth" field in the mutation.
func (m *SettingMutation) DingtalkOauth() (r *types.DingtalkOAuth, exists bool) {
	v := m.dingtalk_oauth
	if v == nil {
		return
	}
	return *v, true
}

// OldDingtalkOauth returns the old "dingtalk_oauth" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDingtalkOauth(ctx context.Context) (v *types.DingtalkOAuth, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDingtalkOauth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDingtalkOauth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDingtalkOauth: %w", err)
	}
	return oldValue.DingtalkOauth, nil
}

// ClearDingtalkOauth clears the value of the "dingtalk_oauth" field.
func (m *SettingMutation) ClearDingtalkOauth() {
	m.dingtalk_oauth = nil
	m.clearedFields[setting.FieldDingtalkOauth] = struct{}{}
}

// DingtalkOauthCleared returns if the "dingtalk_oauth" field was cleared in this mutation.
func (m *SettingMutation) DingtalkOauthCleared() bool {
	_, ok := m.clearedFields[setting.FieldDingtalkOauth]
	return ok
}

// ResetDingtalkOauth resets all changes to the "dingtalk_oauth" field.
func (m *SettingMutation) ResetDingtalkOauth() {
	m.dingtalk_oauth = nil
	delete(m.clearedFields, setting.FieldDingtalkOauth)
}

// SetCustomOauth sets the "custom_oauth" field.
func (m *SettingMutation) SetCustomOauth(to *types.CustomOAuth) {
	m.custom_oauth = &to
}

// CustomOauth returns the value of the "custom_oauth" field in the mutation.
func (m *SettingMutation) CustomOauth() (r *types.CustomOAuth, exists bool) {
	v := m.custom_oauth
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomOauth returns the old "custom_oauth" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCustomOauth(ctx context.Context) (v *types.CustomOAuth, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomOauth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomOauth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomOauth: %w", err)
	}
	return oldValue.CustomOauth, nil
}

// ClearCustomOauth clears the value of the "custom_oauth" field.
func (m *SettingMutation) ClearCustomOauth() {
	m.custom_oauth = nil
	m.clearedFields[setting.FieldCustomOauth] = struct{}{}
}

// CustomOauthCleared returns if the "custom_oauth" field was cleared in this mutation.
func (m *SettingMutation) CustomOauthCleared() bool {
	_, ok := m.clearedFields[setting.FieldCustomOauth]
	return ok
}

// ResetCustomOauth resets all changes to the "custom_oauth" field.
func (m *SettingMutation) ResetCustomOauth() {
	m.custom_oauth = nil
	delete(m.clearedFields, setting.FieldCustomOauth)
}

// SetBaseURL sets the "base_url" field.
func (m *SettingMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *SettingMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldBaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ClearBaseURL clears the value of the "base_url" field.
func (m *SettingMutation) ClearBaseURL() {
	m.base_url = nil
	m.clearedFields[setting.FieldBaseURL] = struct{}{}
}

// BaseURLCleared returns if the "base_url" field was cleared in this mutation.
func (m *SettingMutation) BaseURLCleared() bool {
	_, ok := m.clearedFields[setting.FieldBaseURL]
	return ok
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *SettingMutation) ResetBaseURL() {
	m.base_url = nil
	delete(m.clearedFields, setting.FieldBaseURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.enable_sso != nil {
		fields = append(fields, setting.FieldEnableSSO)
	}
	if m.force_two_factor_auth != nil {
		fields = append(fields, setting.FieldForceTwoFactorAuth)
	}
	if m.disable_password_login != nil {
		fields = append(fields, setting.FieldDisablePasswordLogin)
	}
	if m.enable_auto_login != nil {
		fields = append(fields, setting.FieldEnableAutoLogin)
	}
	if m.dingtalk_oauth != nil {
		fields = append(fields, setting.FieldDingtalkOauth)
	}
	if m.custom_oauth != nil {
		fields = append(fields, setting.FieldCustomOauth)
	}
	if m.base_url != nil {
		fields = append(fields, setting.FieldBaseURL)
	}
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldEnableSSO:
		return m.EnableSSO()
	case setting.FieldForceTwoFactorAuth:
		return m.ForceTwoFactorAuth()
	case setting.FieldDisablePasswordLogin:
		return m.DisablePasswordLogin()
	case setting.FieldEnableAutoLogin:
		return m.EnableAutoLogin()
	case setting.FieldDingtalkOauth:
		return m.DingtalkOauth()
	case setting.FieldCustomOauth:
		return m.CustomOauth()
	case setting.FieldBaseURL:
		return m.BaseURL()
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldEnableSSO:
		return m.OldEnableSSO(ctx)
	case setting.FieldForceTwoFactorAuth:
		return m.OldForceTwoFactorAuth(ctx)
	case setting.FieldDisablePasswordLogin:
		return m.OldDisablePasswordLogin(ctx)
	case setting.FieldEnableAutoLogin:
		return m.OldEnableAutoLogin(ctx)
	case setting.FieldDingtalkOauth:
		return m.OldDingtalkOauth(ctx)
	case setting.FieldCustomOauth:
		return m.OldCustomOauth(ctx)
	case setting.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldEnableSSO:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableSSO(v)
		return nil
	case setting.FieldForceTwoFactorAuth:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForceTwoFactorAuth(v)
		return nil
	case setting.FieldDisablePasswordLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisablePasswordLogin(v)
		return nil
	case setting.FieldEnableAutoLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableAutoLogin(v)
		return nil
	case setting.FieldDingtalkOauth:
		v, ok := value.(*types.DingtalkOAuth)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDingtalkOauth(v)
		return nil
	case setting.FieldCustomOauth:
		v, ok := value.(*types.CustomOAuth)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomOauth(v)
		return nil
	case setting.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldDingtalkOauth) {
		fields = append(fields, setting.FieldDingtalkOauth)
	}
	if m.FieldCleared(setting.FieldCustomOauth) {
		fields = append(fields, setting.FieldCustomOauth)
	}
	if m.FieldCleared(setting.FieldBaseURL) {
		fields = append(fields, setting.FieldBaseURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldDingtalkOauth:
		m.ClearDingtalkOauth()
		return nil
	case setting.FieldCustomOauth:
		m.ClearCustomOauth()
		return nil
	case setting.FieldBaseURL:
		m.ClearBaseURL()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldEnableSSO:
		m.ResetEnableSSO()
		return nil
	case setting.FieldForceTwoFactorAuth:
		m.ResetForceTwoFactorAuth()
		return nil
	case setting.FieldDisablePasswordLogin:
		m.ResetDisablePasswordLogin()
		return nil
	case setting.FieldEnableAutoLogin:
		m.ResetEnableAutoLogin()
		return nil
	case setting.FieldDingtalkOauth:
		m.ResetDingtalkOauth()
		return nil
	case setting.FieldCustomOauth:
		m.ResetCustomOauth()
		return nil
	case setting.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	deleted_at                     *time.Time
	username                       *string
	password                       *string
	email                          *string
	avatar_url                     *string
	platform                       *consts.UserPlatform
	status                         *consts.UserStatus
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	login_histories                map[uuid.UUID]struct{}
	removedlogin_histories         map[uuid.UUID]struct{}
	clearedlogin_histories         bool
	identities                     map[uuid.UUID]struct{}
	removedidentities              map[uuid.UUID]struct{}
	clearedidentities              bool
	conversations                  map[uuid.UUID]struct{}
	removedconversations           map[uuid.UUID]struct{}
	clearedconversations           bool
	resumes                        map[uuid.UUID]struct{}
	removedresumes                 map[uuid.UUID]struct{}
	clearedresumes                 bool
	created_positions              map[uuid.UUID]struct{}
	removedcreated_positions       map[uuid.UUID]struct{}
	clearedcreated_positions       bool
	created_screening_tasks        map[uuid.UUID]struct{}
	removedcreated_screening_tasks map[uuid.UUID]struct{}
	clearedcreated_screening_tasks bool
	done                           bool
	oldValue                       func(context.Context) (*User, error)
	predicates                     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetPlatform sets the "platform" field.
func (m *UserMutation) SetPlatform(cp consts.UserPlatform) {
	m.platform = &cp
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserMutation) Platform() (r consts.UserPlatform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatform(ctx context.Context) (v consts.UserPlatform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserMutation) ResetPlatform() {
	m.platform = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(cs consts.UserStatus) {
	m.status = &cs
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r consts.UserStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v consts.UserStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddLoginHistoryIDs adds the "login_histories" edge to the UserLoginHistory entity by ids.
func (m *UserMutation) AddLoginHistoryIDs(ids ...uuid.UUID) {
	if m.login_histories == nil {
		m.login_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.login_histories[ids[i]] = struct{}{}
	}
}

// ClearLoginHistories clears the "login_histories" edge to the UserLoginHistory entity.
func (m *UserMutation) ClearLoginHistories() {
	m.clearedlogin_histories = true
}

// LoginHistoriesCleared reports if the "login_histories" edge to the UserLoginHistory entity was cleared.
func (m *UserMutation) LoginHistoriesCleared() bool {
	return m.clearedlogin_histories
}

// RemoveLoginHistoryIDs removes the "login_histories" edge to the UserLoginHistory entity by IDs.
func (m *UserMutation) RemoveLoginHistoryIDs(ids ...uuid.UUID) {
	if m.removedlogin_histories == nil {
		m.removedlogin_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.login_histories, ids[i])
		m.removedlogin_histories[ids[i]] = struct{}{}
	}
}

// RemovedLoginHistories returns the removed IDs of the "login_histories" edge to the UserLoginHistory entity.
func (m *UserMutation) RemovedLoginHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedlogin_histories {
		ids = append(ids, id)
	}
	return
}

// LoginHistoriesIDs returns the "login_histories" edge IDs in the mutation.
func (m *UserMutation) LoginHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.login_histories {
		ids = append(ids, id)
	}
	return
}

// ResetLoginHistories resets all changes to the "login_histories" edge.
func (m *UserMutation) ResetLoginHistories() {
	m.login_histories = nil
	m.clearedlogin_histories = false
	m.removedlogin_histories = nil
}

// AddIdentityIDs adds the "identities" edge to the UserIdentity entity by ids.
func (m *UserMutation) AddIdentityIDs(ids ...uuid.UUID) {
	if m.identities == nil {
		m.identities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the UserIdentity entity.
func (m *UserMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the UserIdentity entity was cleared.
func (m *UserMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the UserIdentity entity by IDs.
func (m *UserMutation) RemoveIdentityIDs(ids ...uuid.UUID) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the UserIdentity entity.
func (m *UserMutation) RemovedIdentitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *UserMutation) IdentitiesIDs() (ids []uuid.UUID) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *UserMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// AddConversationIDs adds the "conversations" edge to the Conversation entity by ids.
func (m *UserMutation) AddConversationIDs(ids ...uuid.UUID) {
	if m.conversations == nil {
		m.conversations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.conversations[ids[i]] = struct{}{}
	}
}

// ClearConversations clears the "conversations" edge to the Conversation entity.
func (m *UserMutation) ClearConversations() {
	m.clearedconversations = true
}

// ConversationsCleared reports if the "conversations" edge to the Conversation entity was cleared.
func (m *UserMutation) ConversationsCleared() bool {
	return m.clearedconversations
}

// RemoveConversationIDs removes the "conversations" edge to the Conversation entity by IDs.
func (m *UserMutation) RemoveConversationIDs(ids ...uuid.UUID) {
	if m.removedconversations == nil {
		m.removedconversations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.conversations, ids[i])
		m.removedconversations[ids[i]] = struct{}{}
	}
}

// RemovedConversations returns the removed IDs of the "conversations" edge to the Conversation entity.
func (m *UserMutation) RemovedConversationsIDs() (ids []uuid.UUID) {
	for id := range m.removedconversations {
		ids = append(ids, id)
	}
	return
}

// ConversationsIDs returns the "conversations" edge IDs in the mutation.
func (m *UserMutation) ConversationsIDs() (ids []uuid.UUID) {
	for id := range m.conversations {
		ids = append(ids, id)
	}
	return
}

// ResetConversations resets all changes to the "conversations" edge.
func (m *UserMutation) ResetConversations() {
	m.conversations = nil
	m.clearedconversations = false
	m.removedconversations = nil
}

// AddResumeIDs adds the "resumes" edge to the Resume entity by ids.
func (m *UserMutation) AddResumeIDs(ids ...uuid.UUID) {
	if m.resumes == nil {
		m.resumes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.resumes[ids[i]] = struct{}{}
	}
}

// ClearResumes clears the "resumes" edge to the Resume entity.
func (m *UserMutation) ClearResumes() {
	m.clearedresumes = true
}

// ResumesCleared reports if the "resumes" edge to the Resume entity was cleared.
func (m *UserMutation) ResumesCleared() bool {
	return m.clearedresumes
}

// RemoveResumeIDs removes the "resumes" edge to the Resume entity by IDs.
func (m *UserMutation) RemoveResumeIDs(ids ...uuid.UUID) {
	if m.removedresumes == nil {
		m.removedresumes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.resumes, ids[i])
		m.removedresumes[ids[i]] = struct{}{}
	}
}

// RemovedResumes returns the removed IDs of the "resumes" edge to the Resume entity.
func (m *UserMutation) RemovedResumesIDs() (ids []uuid.UUID) {
	for id := range m.removedresumes {
		ids = append(ids, id)
	}
	return
}

// ResumesIDs returns the "resumes" edge IDs in the mutation.
func (m *UserMutation) ResumesIDs() (ids []uuid.UUID) {
	for id := range m.resumes {
		ids = append(ids, id)
	}
	return
}

// ResetResumes resets all changes to the "resumes" edge.
func (m *UserMutation) ResetResumes() {
	m.resumes = nil
	m.clearedresumes = false
	m.removedresumes = nil
}

// AddCreatedPositionIDs adds the "created_positions" edge to the JobPosition entity by ids.
func (m *UserMutation) AddCreatedPositionIDs(ids ...uuid.UUID) {
	if m.created_positions == nil {
		m.created_positions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_positions[ids[i]] = struct{}{}
	}
}

// ClearCreatedPositions clears the "created_positions" edge to the JobPosition entity.
func (m *UserMutation) ClearCreatedPositions() {
	m.clearedcreated_positions = true
}

// CreatedPositionsCleared reports if the "created_positions" edge to the JobPosition entity was cleared.
func (m *UserMutation) CreatedPositionsCleared() bool {
	return m.clearedcreated_positions
}

// RemoveCreatedPositionIDs removes the "created_positions" edge to the JobPosition entity by IDs.
func (m *UserMutation) RemoveCreatedPositionIDs(ids ...uuid.UUID) {
	if m.removedcreated_positions == nil {
		m.removedcreated_positions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_positions, ids[i])
		m.removedcreated_positions[ids[i]] = struct{}{}
	}
}

// RemovedCreatedPositions returns the removed IDs of the "created_positions" edge to the JobPosition entity.
func (m *UserMutation) RemovedCreatedPositionsIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_positions {
		ids = append(ids, id)
	}
	return
}

// CreatedPositionsIDs returns the "created_positions" edge IDs in the mutation.
func (m *UserMutation) CreatedPositionsIDs() (ids []uuid.UUID) {
	for id := range m.created_positions {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedPositions resets all changes to the "created_positions" edge.
func (m *UserMutation) ResetCreatedPositions() {
	m.created_positions = nil
	m.clearedcreated_positions = false
	m.removedcreated_positions = nil
}

// AddCreatedScreeningTaskIDs adds the "created_screening_tasks" edge to the ScreeningTask entity by ids.
func (m *UserMutation) AddCreatedScreeningTaskIDs(ids ...uuid.UUID) {
	if m.created_screening_tasks == nil {
		m.created_screening_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_screening_tasks[ids[i]] = struct{}{}
	}
}

// ClearCreatedScreeningTasks clears the "created_screening_tasks" edge to the ScreeningTask entity.
func (m *UserMutation) ClearCreatedScreeningTasks() {
	m.clearedcreated_screening_tasks = true
}

// CreatedScreeningTasksCleared reports if the "created_screening_tasks" edge to the ScreeningTask entity was cleared.
func (m *UserMutation) CreatedScreeningTasksCleared() bool {
	return m.clearedcreated_screening_tasks
}

// RemoveCreatedScreeningTaskIDs removes the "created_screening_tasks" edge to the ScreeningTask entity by IDs.
func (m *UserMutation) RemoveCreatedScreeningTaskIDs(ids ...uuid.UUID) {
	if m.removedcreated_screening_tasks == nil {
		m.removedcreated_screening_tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_screening_tasks, ids[i])
		m.removedcreated_screening_tasks[ids[i]] = struct{}{}
	}
}

// RemovedCreatedScreeningTasks returns the removed IDs of the "created_screening_tasks" edge to the ScreeningTask entity.
func (m *UserMutation) RemovedCreatedScreeningTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_screening_tasks {
		ids = append(ids, id)
	}
	return
}

// CreatedScreeningTasksIDs returns the "created_screening_tasks" edge IDs in the mutation.
func (m *UserMutation) CreatedScreeningTasksIDs() (ids []uuid.UUID) {
	for id := range m.created_screening_tasks {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedScreeningTasks resets all changes to the "created_screening_tasks" edge.
func (m *UserMutation) ResetCreatedScreeningTasks() {
	m.created_screening_tasks = nil
	m.clearedcreated_screening_tasks = false
	m.removedcreated_screening_tasks = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.platform != nil {
		fields = append(fields, user.FieldPlatform)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldPlatform:
		return m.Platform()
	case user.FieldStatus:
		return m.Status()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldPlatform:
		return m.OldPlatform(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldPlatform:
		v, ok := value.(consts.UserPlatform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(consts.UserStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldPlatform:
		m.ResetPlatform()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.login_histories != nil {
		edges = append(edges, user.EdgeLoginHistories)
	}
	if m.identities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.conversations != nil {
		edges = append(edges, user.EdgeConversations)
	}
	if m.resumes != nil {
		edges = append(edges, user.EdgeResumes)
	}
	if m.created_positions != nil {
		edges = append(edges, user.EdgeCreatedPositions)
	}
	if m.created_screening_tasks != nil {
		edges = append(edges, user.EdgeCreatedScreeningTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeLoginHistories:
		ids := make([]ent.Value, 0, len(m.login_histories))
		for id := range m.login_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConversations:
		ids := make([]ent.Value, 0, len(m.conversations))
		for id := range m.conversations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.resumes))
		for id := range m.resumes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedPositions:
		ids := make([]ent.Value, 0, len(m.created_positions))
		for id := range m.created_positions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedScreeningTasks:
		ids := make([]ent.Value, 0, len(m.created_screening_tasks))
		for id := range m.created_screening_tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedlogin_histories != nil {
		edges = append(edges, user.EdgeLoginHistories)
	}
	if m.removedidentities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.removedconversations != nil {
		edges = append(edges, user.EdgeConversations)
	}
	if m.removedresumes != nil {
		edges = append(edges, user.EdgeResumes)
	}
	if m.removedcreated_positions != nil {
		edges = append(edges, user.EdgeCreatedPositions)
	}
	if m.removedcreated_screening_tasks != nil {
		edges = append(edges, user.EdgeCreatedScreeningTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeLoginHistories:
		ids := make([]ent.Value, 0, len(m.removedlogin_histories))
		for id := range m.removedlogin_histories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConversations:
		ids := make([]ent.Value, 0, len(m.removedconversations))
		for id := range m.removedconversations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResumes:
		ids := make([]ent.Value, 0, len(m.removedresumes))
		for id := range m.removedresumes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedPositions:
		ids := make([]ent.Value, 0, len(m.removedcreated_positions))
		for id := range m.removedcreated_positions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedScreeningTasks:
		ids := make([]ent.Value, 0, len(m.removedcreated_screening_tasks))
		for id := range m.removedcreated_screening_tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedlogin_histories {
		edges = append(edges, user.EdgeLoginHistories)
	}
	if m.clearedidentities {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.clearedconversations {
		edges = append(edges, user.EdgeConversations)
	}
	if m.clearedresumes {
		edges = append(edges, user.EdgeResumes)
	}
	if m.clearedcreated_positions {
		edges = append(edges, user.EdgeCreatedPositions)
	}
	if m.clearedcreated_screening_tasks {
		edges = append(edges, user.EdgeCreatedScreeningTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeLoginHistories:
		return m.clearedlogin_histories
	case user.EdgeIdentities:
		return m.clearedidentities
	case user.EdgeConversations:
		return m.clearedconversations
	case user.EdgeResumes:
		return m.clearedresumes
	case user.EdgeCreatedPositions:
		return m.clearedcreated_positions
	case user.EdgeCreatedScreeningTasks:
		return m.clearedcreated_screening_tasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeLoginHistories:
		m.ResetLoginHistories()
		return nil
	case user.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case user.EdgeConversations:
		m.ResetConversations()
		return nil
	case user.EdgeResumes:
		m.ResetResumes()
		return nil
	case user.EdgeCreatedPositions:
		m.ResetCreatedPositions()
		return nil
	case user.EdgeCreatedScreeningTasks:
		m.ResetCreatedScreeningTasks()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserIdentityMutation represents an operation that mutates the UserIdentity nodes in the graph.
type UserIdentityMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	deleted_at    *time.Time
	platform      *consts.UserPlatform
	identity_id   *string
	union_id      *string
	nickname      *string
	email         *string
	avatar_url    *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserIdentity, error)
	predicates    []predicate.UserIdentity
}

var _ ent.Mutation = (*UserIdentityMutation)(nil)

// useridentityOption allows management of the mutation configuration using functional options.
type useridentityOption func(*UserIdentityMutation)

// newUserIdentityMutation creates new mutation for the UserIdentity entity.
func newUserIdentityMutation(c config, op Op, opts ...useridentityOption) *UserIdentityMutation {
	m := &UserIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserIdentityID sets the ID field of the mutation.
func withUserIdentityID(id uuid.UUID) useridentityOption {
	return func(m *UserIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserIdentity
		)
		m.oldValue = func(ctx context.Context) (*UserIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserIdentity sets the old UserIdentity of the mutation.
func withUserIdentity(node *UserIdentity) useridentityOption {
	return func(m *UserIdentityMutation) {
		m.oldValue = func(context.Context) (*UserIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserIdentity entities.
func (m *UserIdentityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserIdentityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserIdentityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserIdentityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserIdentityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserIdentityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[useridentity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserIdentityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserIdentityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, useridentity.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserIdentityMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserIdentityMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserIdentityMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserIdentityMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserIdentityMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, useridentity.FieldUserID)
}

// SetPlatform sets the "platform" field.
func (m *UserIdentityMutation) SetPlatform(cp consts.UserPlatform) {
	m.platform = &cp
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserIdentityMutation) Platform() (r consts.UserPlatform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldPlatform(ctx context.Context) (v consts.UserPlatform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserIdentityMutation) ResetPlatform() {
	m.platform = nil
}

// SetIdentityID sets the "identity_id" field.
func (m *UserIdentityMutation) SetIdentityID(s string) {
	m.identity_id = &s
}

// IdentityID returns the value of the "identity_id" field in the mutation.
func (m *UserIdentityMutation) IdentityID() (r string, exists bool) {
	v := m.identity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentityID returns the old "identity_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldIdentityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentityID: %w", err)
	}
	return oldValue.IdentityID, nil
}

// ResetIdentityID resets all changes to the "identity_id" field.
func (m *UserIdentityMutation) ResetIdentityID() {
	m.identity_id = nil
}

// SetUnionID sets the "union_id" field.
func (m *UserIdentityMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *UserIdentityMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ClearUnionID clears the value of the "union_id" field.
func (m *UserIdentityMutation) ClearUnionID() {
	m.union_id = nil
	m.clearedFields[useridentity.FieldUnionID] = struct{}{}
}

// UnionIDCleared returns if the "union_id" field was cleared in this mutation.
func (m *UserIdentityMutation) UnionIDCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUnionID]
	return ok
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *UserIdentityMutation) ResetUnionID() {
	m.union_id = nil
	delete(m.clearedFields, useridentity.FieldUnionID)
}

// SetNickname sets the "nickname" field.
func (m *UserIdentityMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserIdentityMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserIdentityMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[useridentity.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserIdentityMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserIdentityMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, useridentity.FieldNickname)
}

// SetEmail sets the "email" field.
func (m *UserIdentityMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserIdentityMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserIdentityMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[useridentity.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserIdentityMutation) EmailCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserIdentityMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, useridentity.FieldEmail)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserIdentityMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserIdentityMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserIdentityMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[useridentity.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserIdentityMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserIdentityMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, useridentity.FieldAvatarURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserIdentityMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserIdentityMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserIdentityMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserIdentityMutation builder.
func (m *UserIdentityMutation) Where(ps ...predicate.UserIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserIdentity).
func (m *UserIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserIdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.deleted_at != nil {
		fields = append(fields, useridentity.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.platform != nil {
		fields = append(fields, useridentity.FieldPlatform)
	}
	if m.identity_id != nil {
		fields = append(fields, useridentity.FieldIdentityID)
	}
	if m.union_id != nil {
		fields = append(fields, useridentity.FieldUnionID)
	}
	if m.nickname != nil {
		fields = append(fields, useridentity.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, useridentity.FieldEmail)
	}
	if m.avatar_url != nil {
		fields = append(fields, useridentity.FieldAvatarURL)
	}
	if m.created_at != nil {
		fields = append(fields, useridentity.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldDeletedAt:
		return m.DeletedAt()
	case useridentity.FieldUserID:
		return m.UserID()
	case useridentity.FieldPlatform:
		return m.Platform()
	case useridentity.FieldIdentityID:
		return m.IdentityID()
	case useridentity.FieldUnionID:
		return m.UnionID()
	case useridentity.FieldNickname:
		return m.Nickname()
	case useridentity.FieldEmail:
		return m.Email()
	case useridentity.FieldAvatarURL:
		return m.AvatarURL()
	case useridentity.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useridentity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case useridentity.FieldUserID:
		return m.OldUserID(ctx)
	case useridentity.FieldPlatform:
		return m.OldPlatform(ctx)
	case useridentity.FieldIdentityID:
		return m.OldIdentityID(ctx)
	case useridentity.FieldUnionID:
		return m.OldUnionID(ctx)
	case useridentity.FieldNickname:
		return m.OldNickname(ctx)
	case useridentity.FieldEmail:
		return m.OldEmail(ctx)
	case useridentity.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case useridentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case useridentity.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useridentity.FieldPlatform:
		v, ok := value.(consts.UserPlatform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case useridentity.FieldIdentityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentityID(v)
		return nil
	case useridentity.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	case useridentity.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case useridentity.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case useridentity.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case useridentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserIdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserIdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useridentity.FieldDeletedAt) {
		fields = append(fields, useridentity.FieldDeletedAt)
	}
	if m.FieldCleared(useridentity.FieldUserID) {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.FieldCleared(useridentity.FieldUnionID) {
		fields = append(fields, useridentity.FieldUnionID)
	}
	if m.FieldCleared(useridentity.FieldNickname) {
		fields = append(fields, useridentity.FieldNickname)
	}
	if m.FieldCleared(useridentity.FieldEmail) {
		fields = append(fields, useridentity.FieldEmail)
	}
	if m.FieldCleared(useridentity.FieldAvatarURL) {
		fields = append(fields, useridentity.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserIdentityMutation) ClearField(name string) error {
	switch name {
	case useridentity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case useridentity.FieldUserID:
		m.ClearUserID()
		return nil
	case useridentity.FieldUnionID:
		m.ClearUnionID()
		return nil
	case useridentity.FieldNickname:
		m.ClearNickname()
		return nil
	case useridentity.FieldEmail:
		m.ClearEmail()
		return nil
	case useridentity.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserIdentityMutation) ResetField(name string) error {
	switch name {
	case useridentity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case useridentity.FieldUserID:
		m.ResetUserID()
		return nil
	case useridentity.FieldPlatform:
		m.ResetPlatform()
		return nil
	case useridentity.FieldIdentityID:
		m.ResetIdentityID()
		return nil
	case useridentity.FieldUnionID:
		m.ResetUnionID()
		return nil
	case useridentity.FieldNickname:
		m.ResetNickname()
		return nil
	case useridentity.FieldEmail:
		m.ResetEmail()
		return nil
	case useridentity.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case useridentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useridentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserIdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case useridentity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserIdentityMutation) ClearEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserIdentityMutation) ResetEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity edge %s", name)
}

// UserLoginHistoryMutation represents an operation that mutates the UserLoginHistory nodes in the graph.
type UserLoginHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	ip             *string
	country        *string
	province       *string
	city           *string
	isp            *string
	asn            *string
	client_version *string
	os_type        *consts.OSType
	os_release     *consts.OSRelease
	hostname       *string
	client_id      *string
	created_at     *time.Time
	clearedFields  map[string]struct{}
	owner          *uuid.UUID
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*UserLoginHistory, error)
	predicates     []predicate.UserLoginHistory
}

var _ ent.Mutation = (*UserLoginHistoryMutation)(nil)

// userloginhistoryOption allows management of the mutation configuration using functional options.
type userloginhistoryOption func(*UserLoginHistoryMutation)

// newUserLoginHistoryMutation creates new mutation for the UserLoginHistory entity.
func newUserLoginHistoryMutation(c config, op Op, opts ...userloginhistoryOption) *UserLoginHistoryMutation {
	m := &UserLoginHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginHistoryID sets the ID field of the mutation.
func withUserLoginHistoryID(id uuid.UUID) userloginhistoryOption {
	return func(m *UserLoginHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginHistory
		)
		m.oldValue = func(ctx context.Context) (*UserLoginHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginHistory sets the old UserLoginHistory of the mutation.
func withUserLoginHistory(node *UserLoginHistory) userloginhistoryOption {
	return func(m *UserLoginHistoryMutation) {
		m.oldValue = func(context.Context) (*UserLoginHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLoginHistory entities.
func (m *UserLoginHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLoginHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLoginHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLoginHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserLoginHistoryMutation) SetUserID(u uuid.UUID) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLoginHistoryMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserLoginHistoryMutation) ClearUserID() {
	m.owner = nil
	m.clearedFields[userloginhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLoginHistoryMutation) ResetUserID() {
	m.owner = nil
	delete(m.clearedFields, userloginhistory.FieldUserID)
}

// SetIP sets the "ip" field.
func (m *UserLoginHistoryMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *UserLoginHistoryMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *UserLoginHistoryMutation) ResetIP() {
	m.ip = nil
}

// SetCountry sets the "country" field.
func (m *UserLoginHistoryMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserLoginHistoryMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *UserLoginHistoryMutation) ResetCountry() {
	m.country = nil
}

// SetProvince sets the "province" field.
func (m *UserLoginHistoryMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *UserLoginHistoryMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *UserLoginHistoryMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *UserLoginHistoryMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserLoginHistoryMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UserLoginHistoryMutation) ResetCity() {
	m.city = nil
}

// SetIsp sets the "isp" field.
func (m *UserLoginHistoryMutation) SetIsp(s string) {
	m.isp = &s
}

// Isp returns the value of the "isp" field in the mutation.
func (m *UserLoginHistoryMutation) Isp() (r string, exists bool) {
	v := m.isp
	if v == nil {
		return
	}
	return *v, true
}

// OldIsp returns the old "isp" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldIsp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsp: %w", err)
	}
	return oldValue.Isp, nil
}

// ClearIsp clears the value of the "isp" field.
func (m *UserLoginHistoryMutation) ClearIsp() {
	m.isp = nil
	m.clearedFields[userloginhistory.FieldIsp] = struct{}{}
}

// IspCleared returns if the "isp" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) IspCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldIsp]
	return ok
}

// ResetIsp resets all changes to the "isp" field.
func (m *UserLoginHistoryMutation) ResetIsp() {
	m.isp = nil
	delete(m.clearedFields, userloginhistory.FieldIsp)
}

// SetAsn sets the "asn" field.
func (m *UserLoginHistoryMutation) SetAsn(s string) {
	m.asn = &s
}

// Asn returns the value of the "asn" field in the mutation.
func (m *UserLoginHistoryMutation) Asn() (r string, exists bool) {
	v := m.asn
	if v == nil {
		return
	}
	return *v, true
}

// OldAsn returns the old "asn" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldAsn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAsn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAsn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAsn: %w", err)
	}
	return oldValue.Asn, nil
}

// ClearAsn clears the value of the "asn" field.
func (m *UserLoginHistoryMutation) ClearAsn() {
	m.asn = nil
	m.clearedFields[userloginhistory.FieldAsn] = struct{}{}
}

// AsnCleared returns if the "asn" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) AsnCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldAsn]
	return ok
}

// ResetAsn resets all changes to the "asn" field.
func (m *UserLoginHistoryMutation) ResetAsn() {
	m.asn = nil
	delete(m.clearedFields, userloginhistory.FieldAsn)
}

// SetClientVersion sets the "client_version" field.
func (m *UserLoginHistoryMutation) SetClientVersion(s string) {
	m.client_version = &s
}

// ClientVersion returns the value of the "client_version" field in the mutation.
func (m *UserLoginHistoryMutation) ClientVersion() (r string, exists bool) {
	v := m.client_version
	if v == nil {
		return
	}
	return *v, true
}

// OldClientVersion returns the old "client_version" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldClientVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientVersion: %w", err)
	}
	return oldValue.ClientVersion, nil
}

// ClearClientVersion clears the value of the "client_version" field.
func (m *UserLoginHistoryMutation) ClearClientVersion() {
	m.client_version = nil
	m.clearedFields[userloginhistory.FieldClientVersion] = struct{}{}
}

// ClientVersionCleared returns if the "client_version" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) ClientVersionCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldClientVersion]
	return ok
}

// ResetClientVersion resets all changes to the "client_version" field.
func (m *UserLoginHistoryMutation) ResetClientVersion() {
	m.client_version = nil
	delete(m.clearedFields, userloginhistory.FieldClientVersion)
}

// SetOsType sets the "os_type" field.
func (m *UserLoginHistoryMutation) SetOsType(ct consts.OSType) {
	m.os_type = &ct
}

// OsType returns the value of the "os_type" field in the mutation.
func (m *UserLoginHistoryMutation) OsType() (r consts.OSType, exists bool) {
	v := m.os_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOsType returns the old "os_type" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldOsType(ctx context.Context) (v consts.OSType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsType: %w", err)
	}
	return oldValue.OsType, nil
}

// ClearOsType clears the value of the "os_type" field.
func (m *UserLoginHistoryMutation) ClearOsType() {
	m.os_type = nil
	m.clearedFields[userloginhistory.FieldOsType] = struct{}{}
}

// OsTypeCleared returns if the "os_type" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) OsTypeCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldOsType]
	return ok
}

// ResetOsType resets all changes to the "os_type" field.
func (m *UserLoginHistoryMutation) ResetOsType() {
	m.os_type = nil
	delete(m.clearedFields, userloginhistory.FieldOsType)
}

// SetOsRelease sets the "os_release" field.
func (m *UserLoginHistoryMutation) SetOsRelease(cr consts.OSRelease) {
	m.os_release = &cr
}

// OsRelease returns the value of the "os_release" field in the mutation.
func (m *UserLoginHistoryMutation) OsRelease() (r consts.OSRelease, exists bool) {
	v := m.os_release
	if v == nil {
		return
	}
	return *v, true
}

// OldOsRelease returns the old "os_release" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldOsRelease(ctx context.Context) (v consts.OSRelease, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOsRelease is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOsRelease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOsRelease: %w", err)
	}
	return oldValue.OsRelease, nil
}

// ClearOsRelease clears the value of the "os_release" field.
func (m *UserLoginHistoryMutation) ClearOsRelease() {
	m.os_release = nil
	m.clearedFields[userloginhistory.FieldOsRelease] = struct{}{}
}

// OsReleaseCleared returns if the "os_release" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) OsReleaseCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldOsRelease]
	return ok
}

// ResetOsRelease resets all changes to the "os_release" field.
func (m *UserLoginHistoryMutation) ResetOsRelease() {
	m.os_release = nil
	delete(m.clearedFields, userloginhistory.FieldOsRelease)
}

// SetHostname sets the "hostname" field.
func (m *UserLoginHistoryMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *UserLoginHistoryMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *UserLoginHistoryMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[userloginhistory.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *UserLoginHistoryMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, userloginhistory.FieldHostname)
}

// SetClientID sets the "client_id" field.
func (m *UserLoginHistoryMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *UserLoginHistoryMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *UserLoginHistoryMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[userloginhistory.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *UserLoginHistoryMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[userloginhistory.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *UserLoginHistoryMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, userloginhistory.FieldClientID)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLoginHistory entity.
// If the UserLoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *UserLoginHistoryMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *UserLoginHistoryMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[userloginhistory.FieldUserID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *UserLoginHistoryMutation) OwnerCleared() bool {
	return m.UserIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *UserLoginHistoryMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *UserLoginHistoryMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UserLoginHistoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the UserLoginHistoryMutation builder.
func (m *UserLoginHistoryMutation) Where(ps ...predicate.UserLoginHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLoginHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLoginHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLoginHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLoginHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLoginHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLoginHistory).
func (m *UserLoginHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginHistoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.owner != nil {
		fields = append(fields, userloginhistory.FieldUserID)
	}
	if m.ip != nil {
		fields = append(fields, userloginhistory.FieldIP)
	}
	if m.country != nil {
		fields = append(fields, userloginhistory.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, userloginhistory.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, userloginhistory.FieldCity)
	}
	if m.isp != nil {
		fields = append(fields, userloginhistory.FieldIsp)
	}
	if m.asn != nil {
		fields = append(fields, userloginhistory.FieldAsn)
	}
	if m.client_version != nil {
		fields = append(fields, userloginhistory.FieldClientVersion)
	}
	if m.os_type != nil {
		fields = append(fields, userloginhistory.FieldOsType)
	}
	if m.os_release != nil {
		fields = append(fields, userloginhistory.FieldOsRelease)
	}
	if m.hostname != nil {
		fields = append(fields, userloginhistory.FieldHostname)
	}
	if m.client_id != nil {
		fields = append(fields, userloginhistory.FieldClientID)
	}
	if m.created_at != nil {
		fields = append(fields, userloginhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginhistory.FieldUserID:
		return m.UserID()
	case userloginhistory.FieldIP:
		return m.IP()
	case userloginhistory.FieldCountry:
		return m.Country()
	case userloginhistory.FieldProvince:
		return m.Province()
	case userloginhistory.FieldCity:
		return m.City()
	case userloginhistory.FieldIsp:
		return m.Isp()
	case userloginhistory.FieldAsn:
		return m.Asn()
	case userloginhistory.FieldClientVersion:
		return m.ClientVersion()
	case userloginhistory.FieldOsType:
		return m.OsType()
	case userloginhistory.FieldOsRelease:
		return m.OsRelease()
	case userloginhistory.FieldHostname:
		return m.Hostname()
	case userloginhistory.FieldClientID:
		return m.ClientID()
	case userloginhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginhistory.FieldUserID:
		return m.OldUserID(ctx)
	case userloginhistory.FieldIP:
		return m.OldIP(ctx)
	case userloginhistory.FieldCountry:
		return m.OldCountry(ctx)
	case userloginhistory.FieldProvince:
		return m.OldProvince(ctx)
	case userloginhistory.FieldCity:
		return m.OldCity(ctx)
	case userloginhistory.FieldIsp:
		return m.OldIsp(ctx)
	case userloginhistory.FieldAsn:
		return m.OldAsn(ctx)
	case userloginhistory.FieldClientVersion:
		return m.OldClientVersion(ctx)
	case userloginhistory.FieldOsType:
		return m.OldOsType(ctx)
	case userloginhistory.FieldOsRelease:
		return m.OldOsRelease(ctx)
	case userloginhistory.FieldHostname:
		return m.OldHostname(ctx)
	case userloginhistory.FieldClientID:
		return m.OldClientID(ctx)
	case userloginhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginhistory.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userloginhistory.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case userloginhistory.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case userloginhistory.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case userloginhistory.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case userloginhistory.FieldIsp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsp(v)
		return nil
	case userloginhistory.FieldAsn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAsn(v)
		return nil
	case userloginhistory.FieldClientVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientVersion(v)
		return nil
	case userloginhistory.FieldOsType:
		v, ok := value.(consts.OSType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsType(v)
		return nil
	case userloginhistory.FieldOsRelease:
		v, ok := value.(consts.OSRelease)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOsRelease(v)
		return nil
	case userloginhistory.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case userloginhistory.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case userloginhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLoginHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginhistory.FieldUserID) {
		fields = append(fields, userloginhistory.FieldUserID)
	}
	if m.FieldCleared(userloginhistory.FieldIsp) {
		fields = append(fields, userloginhistory.FieldIsp)
	}
	if m.FieldCleared(userloginhistory.FieldAsn) {
		fields = append(fields, userloginhistory.FieldAsn)
	}
	if m.FieldCleared(userloginhistory.FieldClientVersion) {
		fields = append(fields, userloginhistory.FieldClientVersion)
	}
	if m.FieldCleared(userloginhistory.FieldOsType) {
		fields = append(fields, userloginhistory.FieldOsType)
	}
	if m.FieldCleared(userloginhistory.FieldOsRelease) {
		fields = append(fields, userloginhistory.FieldOsRelease)
	}
	if m.FieldCleared(userloginhistory.FieldHostname) {
		fields = append(fields, userloginhistory.FieldHostname)
	}
	if m.FieldCleared(userloginhistory.FieldClientID) {
		fields = append(fields, userloginhistory.FieldClientID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginHistoryMutation) ClearField(name string) error {
	switch name {
	case userloginhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case userloginhistory.FieldIsp:
		m.ClearIsp()
		return nil
	case userloginhistory.FieldAsn:
		m.ClearAsn()
		return nil
	case userloginhistory.FieldClientVersion:
		m.ClearClientVersion()
		return nil
	case userloginhistory.FieldOsType:
		m.ClearOsType()
		return nil
	case userloginhistory.FieldOsRelease:
		m.ClearOsRelease()
		return nil
	case userloginhistory.FieldHostname:
		m.ClearHostname()
		return nil
	case userloginhistory.FieldClientID:
		m.ClearClientID()
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginHistoryMutation) ResetField(name string) error {
	switch name {
	case userloginhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case userloginhistory.FieldIP:
		m.ResetIP()
		return nil
	case userloginhistory.FieldCountry:
		m.ResetCountry()
		return nil
	case userloginhistory.FieldProvince:
		m.ResetProvince()
		return nil
	case userloginhistory.FieldCity:
		m.ResetCity()
		return nil
	case userloginhistory.FieldIsp:
		m.ResetIsp()
		return nil
	case userloginhistory.FieldAsn:
		m.ResetAsn()
		return nil
	case userloginhistory.FieldClientVersion:
		m.ResetClientVersion()
		return nil
	case userloginhistory.FieldOsType:
		m.ResetOsType()
		return nil
	case userloginhistory.FieldOsRelease:
		m.ResetOsRelease()
		return nil
	case userloginhistory.FieldHostname:
		m.ResetHostname()
		return nil
	case userloginhistory.FieldClientID:
		m.ResetClientID()
		return nil
	case userloginhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, userloginhistory.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userloginhistory.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, userloginhistory.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case userloginhistory.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginHistoryMutation) ClearEdge(name string) error {
	switch name {
	case userloginhistory.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginHistoryMutation) ResetEdge(name string) error {
	switch name {
	case userloginhistory.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown UserLoginHistory edge %s", name)
}
